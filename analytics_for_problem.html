<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <!-- Cache busting to ensure browser loads latest version -->
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <title>Analytics ‚Äî Student Progress Analyzer</title>

  <script>
window.MathJax = {
  tex: {
    inlineMath: [['\\(', '\\)']],
    displayMath: [['$$', '$$']],
    processEscapes: true
  },
  svg: { fontCache: 'global' }
};
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script>

  <!-- Version indicator for cache verification -->
  <script>
    console.log('%cüîß Analytics App Version: 2024-11-14-013 (Extension Auto-Inject)', 'background: #4CAF50; color: white; padding: 5px; font-weight: bold;');
    console.log('‚úÖ Automatic version conflict detection and recovery enabled');
    console.log('‚úÖ NEW: Browser Extension Auto-Inject - Real-time WhatsApp capture');
    console.log('‚úÖ WhatsApp Integration - Manual import and extension support');
    console.log('‚úÖ Auto-finalize MC/TF/fill-blank/multi-mc questions when answered');
  </script>

  <!-- PyScript core -->
  <link rel="stylesheet" href="https://pyscript.net/releases/2024.1.1/core.css" />
  <script type="module" src="https://pyscript.net/releases/2024.1.1/core.js"></script>

  <style>
/* =========================================
   GLOBAL RESET
   ========================================= */
/* =========================================
   STARTUP MODAL
   ========================================= */
.startup-modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.6);
    z-index: 10000;
    display: flex;
    justify-content: center;
    align-items: center;
    font-family: sans-serif;
}

.startup-modal {
    background: white;
    padding: 30px;
    border-radius: 12px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    max-width: 600px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
}

.startup-modal h2 {
    margin: 0 0 20px 0;
    color: #0f172a;
    font-size: 24px;
}

.startup-modal p {
    margin: 0 0 20px 0;
    color: #64748b;
    font-size: 14px;
}

.saved-sessions-list {
    margin: 20px 0;
    max-height: 400px;
    overflow-y: auto;
}

.session-item {
    padding: 16px;
    border: 2px solid #e2e8f0;
    border-radius: 8px;
    margin-bottom: 12px;
    cursor: pointer;
    transition: all 0.2s ease;
    background: #f8fafc;
}

.session-item:hover {
    border-color: #3b82f6;
    background: #eff6ff;
    transform: translateX(4px);
}

.session-item.selected {
    border-color: #3b82f6;
    background: #dbeafe;
}

.session-name {
    font-weight: 600;
    font-size: 16px;
    color: #0f172a;
    margin-bottom: 4px;
}

.session-info {
    font-size: 13px;
    color: #64748b;
}

.modal-actions {
    display: flex;
    gap: 12px;
    margin-top: 24px;
}

.modal-btn {
    flex: 1;
    padding: 12px 24px;
    border-radius: 8px;
    border: none;
    cursor: pointer;
    font-size: 15px;
    font-weight: 600;
    transition: all 0.2s ease;
}

.modal-btn-primary {
    background: #3b82f6;
    color: white;
}

.modal-btn-primary:hover {
    background: #2563eb;
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
}

.modal-btn-primary:disabled {
    background: #cbd5e1;
    cursor: not-allowed;
    transform: none;
}

.modal-btn-secondary {
    background: #f1f5f9;
    color: #475569;
}

.modal-btn-secondary:hover {
    background: #e2e8f0;
}

.empty-state {
    text-align: center;
    padding: 40px 20px;
    color: #94a3b8;
}

.empty-state-icon {
    font-size: 48px;
    margin-bottom: 16px;
}

.empty-state-text {
    font-size: 16px;
    margin-bottom: 8px;
    color: #64748b;
}

.empty-state-subtext {
    font-size: 13px;
    color: #94a3b8;
}

body {
    font-family: "Inter", "Segoe UI", Arial, sans-serif;
    background: #f3f4f6;
    color: #111827;
    margin: 0;
    padding: 0;
}

#analyticsResults {
    padding: 16px;
    max-width: 1200px;
    margin: auto;
}

/* =========================================
   PANEL STYLING
   ========================================= */
.panel {
    background: #ffffff;
    border-radius: 10px;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
    padding: 16px 20px;
    margin-bottom: 18px;
    transition: box-shadow 0.2s ease;
}

.panel:hover {
    box-shadow: 0 3px 10px rgba(0, 0, 0, 0.08);
}

/* =========================================
   STATISTIC CARDS
   ========================================= */
.stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 10px;
    margin-top: 8px;
}

.stats-card {
    text-align: center;
    border-radius: 10px;
    padding: 10px 6px;
}

.stats-number {
    font-size: 1.3em;
    font-weight: bold;
    color: #111827;
}

.stats-label {
    font-size: 0.8em;
    color: #6b7280;
}

/* =========================================
   SCORE BADGES
   ========================================= */
.score-badge {
    display: inline-block;
    padding: 4px 8px;
    border-radius: 8px;
    font-weight: 600;
    font-size: 12px;
    color: #fff;
}

.score-high { background-color: #16a34a; }           /* green */
.score-medium { background-color: #facc15; color:#111827; } /* yellow */
.score-low { background-color: #dc2626; }            /* red */

/* =========================================
   TABLE STYLING
   ========================================= */
table {
    width: 100%;
    border-collapse: collapse;
    font-size: 13px;
}

th, td {
    border-bottom: 1px solid #e5e7eb;
    padding: 8px;
    vertical-align: middle;
}

th {
    background: #f3f4f6;
    text-align: left;
    font-weight: 600;
}

tr.detail-row td {
    background: #f9fafb;
}

/* zebra stripes for readability */
tbody tr:nth-child(even):not(.detail-row) {
    background: #fcfcfc;
}

/* =========================================
   BUTTONS (Details Toggle)
   ========================================= */
button.detail-toggle {
    background: #e0f2fe;
    border: 1px solid #bae6fd;
    border-radius: 6px;
    color: #0369a1;
    cursor: pointer;
    font-size: 12px;
    padding: 4px 8px;
    transition: background 0.2s ease, color 0.2s ease;
}

button.detail-toggle:hover {
    background: #0369a1;
    color: #ffffff;
}

/* =========================================
   PROBLEM CARD STYLING
   ========================================= */
.problem-card {
    background: #ffffff;
    border: 1px solid #e5e7eb;
    border-radius: 8px;
    margin-bottom: 12px;
    overflow: hidden;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.04);
}

.problem-header {
    background: #f9fafb;
    cursor: pointer;
    font-weight: 600;
    padding: 10px 12px;
    border-bottom: 1px solid #e5e7eb;
    display: flex;
    justify-content: space-between;
    align-items: center;
    transition: background 0.2s ease;
}

.problem-header:hover {
    background: #f3f4f6;
}

.problem-body {
    padding: 10px 12px;
    background: #fcfcfc;
}

.badge {
    background: #e0f2fe;
    color: #0369a1;
    border-radius: 8px;
    padding: 2px 6px;
    font-size: 11px;
    font-weight: 500;
}

/* =========================================
   ATTEMPTS DISPLAY (Horizontal Layout)
   ========================================= */
.problem-body .attempts-container {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    align-items: flex-start;
    justify-content: flex-start;
}

.problem-body .attempt-box {
    border: 1px solid #e5e7eb;
    background: #ffffff;
    border-radius: 6px;
    padding: 8px 10px;
    min-width: 120px;
    text-align: center;
    transition: box-shadow 0.2s ease;
}

.problem-body .attempt-box:hover {
    box-shadow: 0 0 6px rgba(0, 0, 0, 0.08);
}

/* flag labels */
.attempt-flag {
    font-size: 12px;
    margin-bottom: 4px;
    font-weight: 500;
}

.flag-correct { color: #15803d; }         /* ‚úÖ Correct */
.flag-finalized { color: #166534; }       /* üîí Finalized */
.flag-false { color: #991b1b; }           /* ‚ùå False */
.flag-false-finalized { color: #b45309; } /* ‚ö†Ô∏è False Finalized */

/* =========================================
   MATHJAX OUTPUT AREA
   ========================================= */
.mathjax-latex {
    display: block;
    font-size: 14px;
    margin: 4px 0;
    color: #111827;
    line-height: 1.4;
}

.mathjax-latex mjx-container {
    overflow-x: auto;
    overflow-y: hidden;
}

/* =========================================
   RESPONSIVE TABLE
   ========================================= */
@media (max-width: 768px) {
    th, td {
        padding: 6px;
        font-size: 12px;
    }

    .problem-body .attempt-box {
        min-width: 90px;
        padding: 6px;
    }

    .stats-grid {
        grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
    }
}
</style>

</head>
<body>
  <div id="loadingOverlay">
    <div class="spinner"></div>
    <div class="loading-text">Initializing Analytics...</div>
    <div id="loadingStatus"><div>‚è≥ Starting up...</div></div>
  </div>

  <header>
    <h1>üìä Analytics Dashboard (IndexedDB)</h1>
  </header>

  <div class="panel">
    <label>Student Roster Setup</label>
    <div class="small" style="margin-bottom:8px;">
      Paste WhatsApp messages containing student info. Format: <code>+62...</code> followed by name and registration number.
    </div>
    <textarea id="pasteRosterData" style="width:100%; min-height:120px; padding:8px; border-radius:8px; border:1px solid #e6eef8; font-family:monospace; font-size:12px;" placeholder="Example:&#10;+628123456789: John Doe 12345&#10;[4/10 19.16] +62 858-9375-4880: Abima Ardiansah 41524110006"></textarea>
    <div style="margin-top:8px; display:flex; gap:8px; flex-wrap:wrap;">
      <button id="parseRosterReplaceBtn" class="btn danger">Parse & Replace</button>
      <button id="parseRosterMergeBtn" class="btn success">Parse & Merge</button>
      <button id="clearRosterBtn" class="btn ghost">Clear Roster</button>
      <button id="viewRosterBtn" class="btn ghost">View Roster</button>
      <button id="saveRosterBtn" class="btn" style="background:#10b981;">üíæ Save Roster</button>
      <button id="loadRosterBtn" class="btn" style="background:#3b82f6;">üìÇ Load Roster</button>
      <button id="deleteRosterBtn" class="btn" style="background:#ef4444;">üóëÔ∏è Delete Rosters</button>
    </div>
    <div id="rosterStatus" class="small" style="margin-top:8px; color:#059669;"></div>
  </div>

  <div class="panel">
    <label>Paste Student Progress Data</label>
    <div class="small" style="margin-bottom:8px;">
      Paste one or multiple base64-encoded progress exports. <strong>‚úàÔ∏è Telegram multi-part messages supported!</strong>
    </div>
    <textarea id="pasteProgressData" style="width:100%; min-height:200px; padding:8px; border-radius:8px; border:1px solid #e6eef8; font-family:monospace; font-size:12px;"></textarea>
    <div style="margin-top:8px; display:flex; gap:8px; flex-wrap:wrap;">
      <button id="analyzeBtn" class="btn">Analyze & Add Submissions</button>
      <button id="clearAnalyticsBtn" class="btn ghost">Clear All</button>
      <button id="loadSavedBtn" class="btn" style="background:#3b82f6;">üìÇ Load Saved</button>
      <button id="deleteSelectedBtn" class="btn" style="background:#ef4444;">üóëÔ∏è Delete Selected</button>
      <button id="exportAnalyticsBtn" class="btn" style="background:#8b5cf6;">Export Analytics</button>
      <button id="whatsappBtn" class="btn" style="background:#25D366;">üí¨ WhatsApp Integration</button>
    </div>
  </div>

  <div id="analyticsResults"></div>

  <py-config>
    packages = ["brotli"]
  </py-config>

  <script type="py">
from pyscript import document, window
from pyodide.ffi import create_proxy
import re, json, base64, brotli, html, hashlib
from collections import defaultdict

# ================================================================
# INDEXEDDB MANAGER
# ================================================================
from js import Function, window

class IndexedDBManager:
    """Hybrid IndexedDB manager with automatic localStorage fallback and progress pop-up ‚Äî fully Pyodide-safe"""

    def __init__(self):
        self.db_name = "AnalyticsDB"
        self.db_version = 1
        self.initialized = False
        self.fallback_mode = False  # Enabled automatically if IndexedDB fails

        # --- Progress Pop-up Elements ---
        self.progress_popup = None
        self.progress_status = None
        self.progress_container_id = "pyodide-progress-container"

    # ============================================================
    # PROGRESS POP-UP HELPERS
    # ============================================================
    def _create_progress_elements(self):
        """Create the progress pop-up elements and add them to the DOM."""
        from js import document

        container = document.createElement("div")
        container.id = self.progress_container_id

        popup = document.createElement("div")
        popup.id = "progress-popup"
        popup.style.display = "none"

        content = document.createElement("div")
        content.className = "progress-content"

        spinner = document.createElement("div")
        spinner.className = "spinner"

        status = document.createElement("p")
        status.id = "progress-status"
        status.textContent = "Processing..."

        content.appendChild(spinner)
        content.appendChild(status)
        popup.appendChild(content)
        container.appendChild(popup)

        style = document.createElement("style")
        style.textContent = """
        #pyodide-progress-container #progress-popup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: sans-serif;
        }

        #pyodide-progress-container .progress-content {
            background-color: white;
            padding: 20px 30px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            gap: 15px;
        }

        #pyodide-progress-container .spinner {
            width: 24px;
            height: 24px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #pyodide-progress-container #progress-status {
            margin: 0;
            font-size: 16px;
            color: #333;
        }
        """

        container.appendChild(style)
        document.body.appendChild(container)

        self.progress_popup = popup
        self.progress_status = status

    def _find_progress_elements(self):
        """Find or create the DOM elements for the progress pop-up."""
        from js import window
        if not self.progress_popup:
            self.progress_popup = window.document.querySelector("#progress-popup")
            self.progress_status = window.document.querySelector("#progress-status")

            if not self.progress_popup or not self.progress_status:
                window.console.log("Creating progress pop-up elements...")
                self._create_progress_elements()

    def _show_progress(self, message):
        """Display the progress pop-up with a custom message."""
        self._find_progress_elements()
        if self.progress_popup and self.progress_status:
            self.progress_status.textContent = message
            self.progress_popup.style.display = "flex"

    def _hide_progress(self):
        """Hide the progress pop-up."""
        if self.progress_popup:
            self.progress_popup.style.display = "none"

    # ============================================================
    # INITIALIZE
    # ============================================================
    async def initialize(self):
        from js import window, Function

        if self.initialized:
            return True

        self._show_progress("Initializing database...")

        try:
            if not hasattr(window, "indexedDB"):
                window.console.warn("‚ö†Ô∏è IndexedDB not supported, switching to localStorage")
                self.fallback_mode = True
                self.initialized = True
                return True

            create_bridge = Function(
                """
                return (function() {
                    const delayClose = db => setTimeout(() => db.close(), 0);
                    const bridge = {
                        openDB: function(name, version) {
                            return new Promise((resolve, reject) => {
                                // Check if IndexedDB is available and not blocked
                                if (!window.indexedDB) {
                                    reject(new Error('TRACKING_PREVENTION: IndexedDB is not available. This may be due to browser tracking prevention settings or private browsing mode.'));
                                    return;
                                }

                                // Don't use version parameter - always open latest version to avoid version conflicts
                                const request = indexedDB.open(name);

                                request.onupgradeneeded = e => {
                                    const db = e.target.result;
                                    if (!db.objectStoreNames.contains("analytics")) {
                                        db.createObjectStore("analytics", { keyPath: "id" });
                                    }
                                    if (!db.objectStoreNames.contains("hashes")) {
                                        db.createObjectStore("hashes", { keyPath: "id" });
                                    }
                                };

                                request.onsuccess = e => {
                                    const db = e.target.result;
                                    // Check if required stores exist
                                    const hasAnalytics = db.objectStoreNames.contains("analytics");
                                    const hasHashes = db.objectStoreNames.contains("hashes");

                                    if (!hasAnalytics || !hasHashes) {
                                        // Stores are missing - database is corrupted
                                        console.error(`‚ùå Missing required stores. Database appears corrupted.`);
                                        db.close();
                                        reject(new Error('DB_CORRUPTED: Required object stores are missing from database.'));
                                    } else {
                                        resolve(db);
                                    }
                                };

                                request.onerror = e => {
                                    const error = e.target.error;
                                    console.error('IndexedDB open error:', error);

                                    // Detect tracking prevention or blocked IndexedDB
                                    if (error && (error.name === 'UnknownError' || error.name === 'InvalidStateError')) {
                                        reject(new Error('TRACKING_PREVENTION: IndexedDB appears to be blocked by browser tracking prevention or privacy settings.'));
                                    } else {
                                        reject(error);
                                    }
                                };
                            });
                        },

                        async save(dbName, version, store, key, jsonString) {
                            const db = await bridge.openDB(dbName, version);
                            return new Promise((resolve, reject) => {
                                try {
                                    // Check if store exists before creating transaction
                                    if (!db.objectStoreNames.contains(store)) {
                                        delayClose(db);
                                        // Offer to delete corrupted database
                                        const errorMsg = `Object store '${store}' not found. Database appears corrupted.`;
                                        console.error(`‚ùå ${errorMsg}`);

                                        // Automatically delete and retry if corrupted
                                        if (confirm(`‚ö†Ô∏è Database is corrupted. Delete and recreate?\n\nThis will clear all saved analytics sessions.`)) {
                                            indexedDB.deleteDatabase(dbName);
                                            console.log(`üóëÔ∏è Deleted corrupted database: ${dbName}`);
                                            reject(new Error('Database deleted. Please reload the page.'));
                                        } else {
                                            reject(new Error(errorMsg));
                                        }
                                        return;
                                    }
                                    const tx = db.transaction(store, "readwrite");
                                    const st = tx.objectStore(store);
                                    const keyStr = String(key);
                                    const dataStr = String(jsonString);
                                    const record = { id: keyStr, data: dataStr };
                                    const req = st.put(record); // ‚úÖ no key argument (keyPath used)
                                    req.onsuccess = () => { delayClose(db); resolve(true); };
                                    req.onerror = e => { delayClose(db); reject(e.target.error); };
                                } catch (err) {
                                    delayClose(db);
                                    reject(err);
                                }
                            });
                        },

                        async load(dbName, version, store, key) {
                            const db = await bridge.openDB(dbName, version);
                            return new Promise((resolve, reject) => {
                                try {
                                    // Check if store exists before creating transaction
                                    if (!db.objectStoreNames.contains(store)) {
                                        delayClose(db);
                                        resolve(null);  // Return null if store doesn't exist
                                        return;
                                    }
                                    const tx = db.transaction(store, "readonly");
                                    const st = tx.objectStore(store);
                                    const req = st.get(String(key));
                                    req.onsuccess = () => {
                                        const val = req.result ? String(req.result.data) : null;
                                        delayClose(db);
                                        resolve(val);
                                    };
                                    req.onerror = e => { delayClose(db); reject(e.target.error); };
                                } catch (err) {
                                    delayClose(db);
                                    reject(err);
                                }
                            });
                        },

                        async delete(dbName, version, store, key) {
                            const db = await bridge.openDB(dbName, version);
                            return new Promise((resolve, reject) => {
                                try {
                                    // Check if store exists before creating transaction
                                    if (!db.objectStoreNames.contains(store)) {
                                        delayClose(db);
                                        resolve(true);  // Return success if store doesn't exist (nothing to delete)
                                        return;
                                    }
                                    const tx = db.transaction(store, "readwrite");
                                    const st = tx.objectStore(store);
                                    const req = st.delete(String(key));
                                    req.onsuccess = () => { delayClose(db); resolve(true); };
                                    req.onerror = e => { delayClose(db); reject(e.target.error); };
                                } catch (err) {
                                    delayClose(db);
                                    reject(err);
                                }
                            });
                        }
                    };
                    return bridge;
                })();
                """
            )

            window.PyIndexedDBBridge = create_bridge()

            # Test if IndexedDB actually works (not blocked by tracking prevention)
            try:
                test_db = await window.PyIndexedDBBridge.openDB(self.db_name, self.db_version)
                test_db.close()
                window.console.log("‚úÖ IndexedDB initialized and tested successfully")
            except Exception as test_error:
                error_msg = str(test_error)
                if "TRACKING_PREVENTION" in error_msg:
                    window.console.error("üö´ IndexedDB is blocked by tracking prevention!")
                    window.console.error("üí° Solutions:")
                    window.console.error("   1. Disable tracking prevention for this site")
                    window.console.error("   2. Allow storage access in browser settings")
                    window.console.error("   3. Use a different browser")
                    window.console.error("   4. Exit private/incognito mode")
                    window.console.warn("‚ö†Ô∏è Falling back to localStorage")
                    self.fallback_mode = True
                elif "DB_CORRUPTED" in error_msg:
                    window.console.error("üí• Database is corrupted!")
                    if window.confirm("‚ö†Ô∏è Database is corrupted. Delete and recreate?\n\nThis will clear all saved analytics sessions."):
                        from js import indexedDB
                        indexedDB.deleteDatabase(self.db_name)
                        window.console.log(f"üóëÔ∏è Deleted corrupted database: {self.db_name}")
                        window.alert("Database deleted. Please reload the page to continue.")
                    self.fallback_mode = True
                elif "VersionError" in error_msg:
                    window.console.error("üîÑ Database version conflict detected - auto-deleting old database...")
                    from js import indexedDB
                    indexedDB.deleteDatabase(self.db_name)
                    window.console.log(f"üóëÔ∏è Deleted database with version conflict: {self.db_name}")
                    if window.confirm("‚ö†Ô∏è Database version conflict resolved.\n\nThe old database has been deleted.\n\nReload the page now?"):
                        window.location.reload()
                    else:
                        window.console.warn("‚ö†Ô∏è Falling back to localStorage")
                        self.fallback_mode = True
                else:
                    window.console.error(f"‚ùå IndexedDB test failed: {test_error}")
                    window.console.warn("‚ö†Ô∏è Falling back to localStorage")
                    self.fallback_mode = True

            self.initialized = True

        except Exception as e:
            window.console.warn(f"‚ö†Ô∏è IndexedDB initialization failed ({e}), using localStorage fallback")
            self.fallback_mode = True
            self.initialized = True
        finally:
            self._hide_progress()

        return True

    # ============================================================
    # SAVE
    # ============================================================
    async def save_data(self, store_name, key, data):
        from js import window, JSON
        from pyodide.ffi import to_js
        import json

        if not self.initialized:
            await self.initialize()

        self._show_progress("Saving data...")

        try:
            if not isinstance(data, (dict, list, str, int, float, bool, type(None))):
                data = str(data)

            json_text = json.dumps(data)
            if self.fallback_mode:
                window.localStorage.setItem(f"{store_name}_{key}", json_text)
                window.console.log("üíæ Saved to localStorage (fallback mode)")
                self._hide_progress()
                return True

            js_db_name = to_js(self.db_name)
            js_version = to_js(self.db_version)
            js_store = to_js(store_name)
            js_key = to_js(key)
            js_json = to_js(json_text)

            result = await window.PyIndexedDBBridge.save(js_db_name, js_version, js_store, js_key, js_json)
            window.console.log("‚úÖ Saved to IndexedDB successfully")

            return result

        except Exception as e:
            error_msg = str(e)
            window.console.error(f"‚ùå Error saving data: {e}")

            # Detect specific error types
            if "TRACKING_PREVENTION" in error_msg:
                window.console.error("üö´ IndexedDB is blocked by tracking prevention!")
                window.console.error("üí° Solutions:")
                window.console.error("   1. Disable tracking prevention for this site")
                window.console.error("   2. Allow storage access in browser settings")
                window.console.error("   3. Use a different browser")
                window.console.error("   4. Exit private/incognito mode")
            elif "DB_CORRUPTED" in error_msg:
                window.console.error("üí• Database is corrupted!")
                if window.confirm("‚ö†Ô∏è Database is corrupted. Delete and recreate?\n\nThis will clear all saved analytics sessions."):
                    from js import indexedDB
                    indexedDB.deleteDatabase(self.db_name)
                    window.console.log(f"üóëÔ∏è Deleted corrupted database: {self.db_name}")
                    window.alert("Database deleted. Please reload the page to continue.")
                    return False
            elif "VersionError" in error_msg:
                window.console.error("üîÑ Database version conflict - auto-deleting old database...")
                from js import indexedDB
                indexedDB.deleteDatabase(self.db_name)
                window.console.log(f"üóëÔ∏è Deleted database with version conflict: {self.db_name}")
                if window.confirm("‚ö†Ô∏è Database version conflict resolved.\n\nThe old database has been deleted.\n\nReload the page now?"):
                    window.location.reload()
                return False

            # Try localStorage fallback
            try:
                window.localStorage.setItem(f"{store_name}_{key}", json.dumps(data))
                window.console.warn("‚ö†Ô∏è Saved to localStorage (fallback after IndexedDB error)")
                return True
            except Exception as e2:
                window.console.error(f"‚ùå Fallback save failed: {e2}")
                return False
        finally:
            self._hide_progress()

    # ============================================================
    # LOAD
    # ============================================================
    async def load_data(self, store_name, key):
        from js import window
        from pyodide.ffi import to_js
        import json

        if not self.initialized:
            await self.initialize()

        self._show_progress("Loading data...")

        try:
            if self.fallback_mode:
                raw = window.localStorage.getItem(f"{store_name}_{key}")
                return json.loads(raw) if raw else None

            js_db_name = to_js(self.db_name)
            js_version = to_js(self.db_version)
            js_store = to_js(store_name)
            js_key = to_js(key)

            result = await window.PyIndexedDBBridge.load(js_db_name, js_version, js_store, js_key)
            if result is None:
                return None

            result = result.to_py() if hasattr(result, "to_py") else str(result)
            return json.loads(result)

        except Exception as e:
            window.console.error(f"‚ùå Error loading data: {e}")
            try:
                raw = window.localStorage.getItem(f"{store_name}_{key}")
                return json.loads(raw) if raw else None
            except Exception as e2:
                window.console.error(f"‚ùå Fallback load failed: {e2}")
                return None
        finally:
            self._hide_progress()

    # ============================================================
    # DELETE
    # ============================================================
    async def delete_data(self, store_name, key):
        from js import window
        from pyodide.ffi import to_js

        if not self.initialized:
            await self.initialize()

        self._show_progress("Deleting data...")

        try:
            if self.fallback_mode:
                window.localStorage.removeItem(f"{store_name}_{key}")
                return True

            js_db_name = to_js(self.db_name)
            js_version = to_js(self.db_version)
            js_store = to_js(store_name)
            js_key = to_js(key)

            result = await window.PyIndexedDBBridge.delete(js_db_name, js_version, js_store, js_key)
            return result

        except Exception as e:
            window.console.error(f"‚ùå Error deleting data: {e}")
            try:
                window.localStorage.removeItem(f"{store_name}_{key}")
                window.console.warn("‚ö†Ô∏è Deleted from localStorage (fallback after error)")
                return True
            except:
                return False
        finally:
            self._hide_progress()

class RosterManager:
    """Manages student roster operations"""
    
    def __init__(self):
        self.app = None
        self.student_roster = {}
    
    def initialize(self):
        """Initialize roster management"""
        self.bind_events()
    
    def bind_events(self):
        """Bind roster-related events"""
        bindings = [
            ("#parseRosterReplaceBtn", self.parse_and_replace),
            ("#parseRosterMergeBtn", self.parse_and_merge),
            ("#clearRosterBtn", self.clear_roster),
            ("#viewRosterBtn", self.view_roster),
            ("#saveRosterBtn", self.save_roster),
            ("#loadRosterBtn", self.load_roster),
            ("#deleteRosterBtn", self.delete_rosters),
        ]
        
        for selector, handler in bindings:
            element = document.querySelector(selector)
            if element:
                element.addEventListener("click", create_proxy(handler))
            else:
                window.console.warn(f"‚ö†Ô∏è Missing element: {selector}")
    
    def normalize_phone(self, p):
        """Normalize Indonesian phone numbers"""
        if not p:
            return ""
        p = re.sub(r"[^\d+]", "", p)
        if p.startswith("0"):
            p = "+62" + p[1:]
        elif p.startswith("62") and not p.startswith("+"):
            p = "+" + p
        elif not p.startswith("+") and len(p) > 8:
            p = "+" + p
        return p
    
    def parse_entry(self, entry):
        """Parse a single roster entry"""
        entry = entry.replace("\n", " ")
        m = re.search(r"(\+?\d[\d\s\-]+)\s*:\s*([A-Za-z\s.'()\-]+)\s*(\d{8,15})", entry)
        return m.groups() if m else None
    
    def combine_multiline_entries(self, text):
        """Combine multi-line roster entries"""
        lines = text.splitlines()
        combined, buf = [], ""
        for line in lines:
            line = line.strip()
            if not line:
                continue
            if re.match(r"^\[\d{1,2}", line):
                if buf:
                    combined.append(buf.strip())
                buf = line
            else:
                buf += " " + line
        if buf:
            combined.append(buf.strip())
        return combined
    
    def parse_and_replace(self, e=None):
        """Parse and replace roster"""
        text = document.querySelector("#pasteRosterData").value.strip()
        if not text:
            window.alert("Paste roster data first.")
            return
        
        combined = self.combine_multiline_entries(text)
        parsed = {}
        
        for entry in combined:
            parts = self.parse_entry(entry)
            if not parts:
                continue
            phone, name, reg = parts
            phone = self.normalize_phone(phone)
            parsed[phone] = {
                "phone": phone,
                "name": name.title().strip(),
                "registration_number": reg.strip()
            }
        
        if not parsed:
            window.alert("‚ùå No valid entries found.")
            return
        
        self.student_roster = parsed
        self.app.student_roster = parsed  # Update global reference
        
        document.querySelector("#rosterStatus").innerHTML = (
            f"‚úÖ Replace complete ‚Äî Total: {len(parsed)}"
        )
        window.alert(f"‚úÖ Roster replaced!\nTotal: {len(parsed)}")
        
        # CRITICAL: Refresh analytics display with new roster data
        if self.app.analytics_data:
            self.app.progress_analyzer.refresh_analytics_with_roster()
    
    def parse_and_merge(self, e=None):
        """Parse and merge roster"""
        text = document.querySelector("#pasteRosterData").value.strip()
        if not text:
            window.alert("Paste roster data first.")
            return
        
        combined = self.combine_multiline_entries(text)
        added, updated = 0, 0
        
        for entry in combined:
            parts = self.parse_entry(entry)
            if not parts:
                continue
            phone, name, reg = parts
            phone = self.normalize_phone(phone)
            
            if phone not in self.student_roster:
                self.student_roster[phone] = {
                    "phone": phone,
                    "name": name.title().strip(),
                    "registration_number": reg.strip()
                }
                added += 1
            else:
                prev = self.student_roster[phone]
                if name != prev["name"] or reg != prev["registration_number"]:
                    self.student_roster[phone].update({
                        "name": name.title().strip(),
                        "registration_number": reg.strip()
                    })
                    updated += 1
        
        self.app.student_roster = self.student_roster  # Update global reference
        
        document.querySelector("#rosterStatus").innerHTML = (
            f"‚úÖ Merge complete ‚Äî Total: {len(self.student_roster)} ‚Ä¢ Added: {added} ‚Ä¢ Updated: {updated}"
        )
        window.alert(f"‚úÖ Roster merged!\nTotal: {len(self.student_roster)}\nAdded: {added}\nUpdated: {updated}")
        
        # CRITICAL: Refresh analytics display with new roster data
        if self.app.analytics_data:
            self.app.progress_analyzer.refresh_analytics_with_roster()
    
    def clear_roster(self, e=None):
        """Clear the roster"""
        self.student_roster = {}
        self.app.student_roster = {}  # Update global reference
        document.querySelector("#pasteRosterData").value = ""
        document.querySelector("#rosterStatus").innerHTML = ""
        window.alert("Roster cleared.")
        
        # Refresh analytics display
        if self.app.analytics_data:
            self.app.display_manager.display_analytics(self.app.analytics_data, [])
    
    def view_roster(self, e=None):
        """Display roster in a modal"""
        if not self.student_roster:
            window.alert("No roster loaded.")
            return
        
        # Sort by registration number, then name
        def sort_key(item):
            reg = item[1].get("registration_number", "")
            try:
                return int(re.sub(r"\D", "", reg) or 0)
            except:
                return 0
        
        sorted_roster = sorted(
            self.student_roster.items(),
            key=lambda x: (sort_key(x), x[1]["name"].lower())
        )
        
        html_content = """
            <table style='width:100%;font-size:13px;border-collapse:collapse;'>
            <thead><tr style='background:#f3f4f6;'>
            <th style='padding:6px;'>#</th>
            <th style='padding:6px;text-align:left;'>Reg No</th>
            <th style='padding:6px;text-align:left;'>Name</th>
            <th style='padding:6px;text-align:left;'>Phone</th>
            </tr></thead><tbody>
        """
        
        for i, (phone, info) in enumerate(sorted_roster, 1):
            html_content += f"""
                <tr>
                    <td style='padding:6px;color:#6b7280;'>{i}</td>
                    <td style='padding:6px;font-weight:600;'>{self._escape(info['registration_number'])}</td>
                    <td style='padding:6px;'>{self._escape(info['name'])}</td>
                    <td style='padding:6px;font-size:12px;'>üì± {self._escape(phone)}</td>
                </tr>
            """
        
        html_content += "</tbody></table>"
        
        self.app.create_modal("Student Roster", html_content)

    def save_roster(self, e=None):
        """Save current roster to IndexedDB"""
        import asyncio
        if not self.student_roster:
            window.alert("No roster to save. Please parse a roster first.")
            return
        asyncio.ensure_future(self._save_roster_async())

    async def _save_roster_async(self):
        """Async method to save roster"""
        from js import window

        # Prompt for roster name
        roster_name = window.prompt("Enter a name for this roster:\n(e.g., 'Linear Algebra 08.00')")

        if not roster_name or not roster_name.strip():
            return

        roster_name = roster_name.strip()

        try:
            # Save roster to IndexedDB
            await self.app.persistence_manager.db_manager.save_data(
                "rosters",
                roster_name,
                self.student_roster
            )
            window.alert(f"‚úÖ Roster '{roster_name}' saved successfully!")
            window.console.log(f"üíæ Saved roster: {roster_name}")
        except Exception as e:
            window.console.error(f"‚ùå Failed to save roster: {e}")
            window.alert(f"Failed to save roster: {e}")

    def load_roster(self, e=None):
        """Load a saved roster from IndexedDB"""
        import asyncio
        asyncio.ensure_future(self._load_roster_async())

    async def _load_roster_async(self):
        """Async method to load roster"""
        from js import window

        try:
            # Get list of saved rosters
            self.app.persistence_manager.db_manager._show_progress("üìã Loading saved rosters...")
            saved_keys = await self.app.persistence_manager.list_saved_keys("rosters")
            self.app.persistence_manager.db_manager._hide_progress()

            if not saved_keys:
                window.alert("No saved rosters found.")
                return

            # Show roster selection modal
            selected_roster = await self._show_roster_selection_modal(saved_keys)

            if selected_roster:
                # Load the selected roster
                self.app.persistence_manager.db_manager._show_progress(f"üìÇ Loading roster: {selected_roster}...")
                roster_data = await self.app.persistence_manager.db_manager.load_data("rosters", selected_roster)
                self.app.persistence_manager.db_manager._hide_progress()

                if roster_data:
                    self.student_roster = roster_data
                    self.app.student_roster = roster_data
                    self.update_roster_status(f"‚úÖ Loaded roster '{selected_roster}' ({len(roster_data)} students)")
                    window.console.log(f"üìÇ Loaded roster: {selected_roster} ({len(roster_data)} students)")
                else:
                    window.alert(f"Failed to load roster '{selected_roster}'")
        except Exception as e:
            self.app.persistence_manager.db_manager._hide_progress()
            window.console.error(f"‚ùå Failed to load roster: {e}")
            window.alert(f"Failed to load roster: {e}")

    async def _show_roster_selection_modal(self, roster_keys):
        """Show modal to select a roster to load"""
        from js import document, window
        from pyodide.ffi import create_proxy
        import asyncio

        # Create future for user choice
        future = asyncio.Future()

        # Create modal overlay
        overlay = document.createElement("div")
        overlay.className = "startup-modal-overlay"

        # Create modal content
        modal = document.createElement("div")
        modal.className = "startup-modal"

        # Build roster list
        rosters_html = '<div class="saved-sessions-list" style="max-height: 400px; overflow-y: auto;">'
        for key in roster_keys:
            rosters_html += f'''
                <div class="session-item roster-item-selectable" data-key="{self._escape(key)}"
                     style="cursor: pointer; transition: background 0.2s;">
                    <div class="session-name">üìö {self._escape(key)}</div>
                    <div class="session-info">Saved student roster</div>
                </div>
            '''
        rosters_html += '</div>'

        modal.innerHTML = f'''
            <h2 style="margin-top: 0;">üìÇ Load Saved Roster</h2>
            <p style="color: #6b7280;">Select a roster to load:</p>
            {rosters_html}
            <div class="modal-actions" style="margin-top: 20px;">
                <button class="modal-btn modal-btn-secondary" id="cancel-load-roster-btn">
                    Cancel
                </button>
            </div>
        '''

        overlay.appendChild(modal)
        document.body.appendChild(overlay)

        # Get elements
        roster_items = modal.querySelectorAll(".roster-item-selectable")
        cancel_btn = modal.querySelector("#cancel-load-roster-btn")

        # Close modal
        def close_modal(result=None):
            if not future.done():
                future.set_result(result)
            overlay.remove()
            item_proxy.destroy()
            cancel_proxy.destroy()

        # Handle roster selection
        def select_roster(event):
            item = event.currentTarget
            roster_key = item.getAttribute("data-key")
            close_modal(roster_key)

        # Bind events
        item_proxy = create_proxy(select_roster)
        for item in roster_items:
            item.addEventListener("click", item_proxy)

        cancel_proxy = create_proxy(lambda e: close_modal(None))
        cancel_btn.addEventListener("click", cancel_proxy)

        # Close on overlay click
        overlay.addEventListener("click", create_proxy(lambda e: close_modal(None) if e.target == overlay else None))

        # Wait for user choice
        return await future

    def delete_rosters(self, e=None):
        """Delete selected rosters from IndexedDB"""
        import asyncio
        asyncio.ensure_future(self._delete_rosters_async())

    async def _delete_rosters_async(self):
        """Async method to delete rosters"""
        from js import document, window
        from pyodide.ffi import create_proxy

        try:
            # Get list of saved rosters
            self.app.persistence_manager.db_manager._show_progress("üìã Loading saved rosters...")
            saved_keys = await self.app.persistence_manager.list_saved_keys("rosters")
            self.app.persistence_manager.db_manager._hide_progress()

            if not saved_keys:
                window.alert("No saved rosters to delete.")
                return

            window.console.log(f"üìã Found {len(saved_keys)} saved rosters")

            # Create modal overlay
            overlay = document.createElement("div")
            overlay.id = "delete-roster-modal-overlay"
            overlay.className = "startup-modal-overlay"

            # Create modal content
            modal = document.createElement("div")
            modal.className = "startup-modal"

            # Build roster list with checkboxes
            rosters_html = '<div class="saved-sessions-list" style="max-height: 400px; overflow-y: auto;">'
            for key in saved_keys:
                rosters_html += f'''
                    <div class="session-item" style="padding: 12px; border: 1px solid #e5e7eb; border-radius: 8px; margin-bottom: 8px;">
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="checkbox" class="roster-checkbox" value="{self._escape(key)}"
                                   style="margin-right: 12px; width: 18px; height: 18px; cursor: pointer;">
                            <div>
                                <div class="session-name" style="font-weight: 600; color: #111827;">üìö {self._escape(key)}</div>
                                <div class="session-info" style="font-size: 12px; color: #6b7280;">Saved student roster</div>
                            </div>
                        </label>
                    </div>
                '''
            rosters_html += '</div>'

            modal.innerHTML = f'''
                <h2 style="margin-top: 0;">üóëÔ∏è Delete Saved Rosters</h2>
                <p style="color: #6b7280;">Select one or more rosters to delete permanently.</p>
                <div style="margin: 16px 0;">
                    <label style="display: flex; align-items: center; cursor: pointer; font-size: 14px; color: #111827;">
                        <input type="checkbox" id="select-all-rosters-checkbox"
                               style="margin-right: 8px; width: 16px; height: 16px; cursor: pointer;">
                        <strong>Select All</strong>
                    </label>
                </div>
                {rosters_html}
                <div class="modal-actions" style="margin-top: 20px; display: flex; gap: 12px;">
                    <button class="modal-btn modal-btn-secondary" id="cancel-delete-roster-btn">
                        Cancel
                    </button>
                    <button class="modal-btn" id="confirm-delete-roster-btn"
                            style="background: #ef4444; color: white;" disabled>
                        üóëÔ∏è Delete Selected
                    </button>
                </div>
            '''

            overlay.appendChild(modal)
            document.body.appendChild(overlay)

            # Get elements
            checkboxes = modal.querySelectorAll(".roster-checkbox")
            select_all = modal.querySelector("#select-all-rosters-checkbox")
            confirm_btn = modal.querySelector("#confirm-delete-roster-btn")
            cancel_btn = modal.querySelector("#cancel-delete-roster-btn")

            # Update button state based on selection
            def update_button_state():
                selected_count = len([cb for cb in checkboxes if cb.checked])
                confirm_btn.disabled = selected_count == 0
                if selected_count > 0:
                    confirm_btn.textContent = f"üóëÔ∏è Delete {selected_count} Roster{'s' if selected_count > 1 else ''}"
                else:
                    confirm_btn.textContent = "üóëÔ∏è Delete Selected"

            # Handle checkbox changes
            def on_checkbox_change(e):
                update_button_state()
                # Update select all checkbox
                all_checked = all(cb.checked for cb in checkboxes)
                some_checked = any(cb.checked for cb in checkboxes)
                select_all.checked = all_checked
                select_all.indeterminate = some_checked and not all_checked

            # Handle select all
            def on_select_all(e):
                for cb in checkboxes:
                    cb.checked = select_all.checked
                update_button_state()

            # Bind checkbox events
            checkbox_proxy = create_proxy(on_checkbox_change)
            for cb in checkboxes:
                cb.addEventListener("change", checkbox_proxy)

            select_all_proxy = create_proxy(on_select_all)
            select_all.addEventListener("change", select_all_proxy)

            # Handle cancel
            def close_modal(e=None):
                overlay.remove()
                checkbox_proxy.destroy()
                select_all_proxy.destroy()
                cancel_proxy.destroy()
                confirm_proxy.destroy()

            # Handle confirm delete
            async def confirm_delete(e=None):
                selected_keys = [cb.value for cb in checkboxes if cb.checked]

                if not selected_keys:
                    return

                # Confirm deletion
                count = len(selected_keys)
                if not window.confirm(f"‚ö†Ô∏è Are you sure you want to delete {count} roster{'s' if count > 1 else ''}?\n\nThis action cannot be undone."):
                    return

                # Show loading indicator
                self.app.persistence_manager.db_manager._show_progress(f"üóëÔ∏è Deleting {count} roster{'s' if count > 1 else ''}...")

                # Delete each selected roster
                deleted_count = 0
                for i, key in enumerate(selected_keys, 1):
                    try:
                        self.app.persistence_manager.db_manager._show_progress(f"üóëÔ∏è Deleting roster {i}/{count}...")
                        await self.app.persistence_manager.db_manager.delete_data("rosters", key)
                        window.console.log(f"üóëÔ∏è Deleted roster: {key}")
                        deleted_count += 1
                    except Exception as e:
                        window.console.error(f"‚ùå Failed to delete {key}: {e}")

                # Hide loading indicator
                self.app.persistence_manager.db_manager._hide_progress()

                # Show result
                if deleted_count > 0:
                    window.alert(f"‚úÖ Successfully deleted {deleted_count} roster{'s' if deleted_count > 1 else ''}.")

                close_modal()

            cancel_proxy = create_proxy(close_modal)
            confirm_proxy = create_proxy(confirm_delete)

            cancel_btn.addEventListener("click", cancel_proxy)
            confirm_btn.addEventListener("click", confirm_proxy)

            # Close on overlay click
            overlay.addEventListener("click", create_proxy(lambda e: close_modal() if e.target == overlay else None))

        except Exception as e:
            self.app.persistence_manager.db_manager._hide_progress()
            window.console.error(f"‚ùå Failed to show delete rosters modal: {e}")
            window.alert(f"Failed to load rosters: {e}")

    def _escape(self, text):
        """Escape HTML text"""
        import html
        return html.escape(str(text or ""))
                       
class ProgressAnalyzer:
    def hash_problem_data(self, submission):
        """Create hash for individual problem submission content"""
        import json, hashlib

        try:
            steps = submission.get("steps_progress", []) or []
            problem_data = {
                "problem_number": submission.get("problem", {}).get("number"),
                "problem_id": submission.get("problem", {}).get("id"),
                "steps": []
            }

            for step in steps:
                if isinstance(step, dict):
                    step_info = {
                        "step_number": step.get("step_number"),
                        "finalized": step.get("finalized", False),
                        "attempts": []
                    }
                    for att in step.get("attempts", []) or []:
                        if isinstance(att, dict):
                            step_info["attempts"].append({
                                "answer": att.get("answer_latex", ""),
                                "correct": att.get("correct", False)
                            })
                    problem_data["steps"].append(step_info)

            json_str = json.dumps(problem_data, sort_keys=True, separators=(',', ':'))
            return hashlib.sha256(json_str.encode()).hexdigest()
        except Exception as e:
            window.console.error(f"Error hashing problem data: {e}")
            return None

    # ============================================================
    # PARSE SUBMISSIONS
    # ============================================================
    def parse_submissions(self, text):
        """Parse submissions with detailed debugging"""
        import re, json
        from js import window

        window.console.log("\n" + "=" * 80)
        window.console.log("üîç PARSE_SUBMISSIONS CALLED")
        window.console.log("=" * 80)

        subs, invalid = [], []
        if not text or not text.strip():
            return {"submissions": [], "invalid": [{"error": "Empty input"}], "total": 0}

        window.console.log(f"üìù Input text length: {len(text)} characters")

        # 1Ô∏è‚É£ Find all header/footer export blocks
        export_blocks = list(re.finditer(
            r"===\s*STUDENT\s+PROGRESS\s+EXPORT\s*===\s*(.*?)\s*===\s*END\s+EXPORT\s*===",
            text, re.DOTALL | re.IGNORECASE
        ))

        window.console.log(f"üîç Found {len(export_blocks)} export blocks")

        # 2Ô∏è‚É£ Process each header/footer export block
        for block_idx, block in enumerate(export_blocks):
            window.console.log(f"\n--- Processing block {block_idx + 1}/{len(export_blocks)} ---")

            b64 = re.sub(r"[\s\r\n]+", "", block.group(1))
            window.console.log(f"üì¶ Base64 length: {len(b64)}")

            start_idx = block.start()
            phone = self.extract_phone_from_context(text, start_idx)
            window.console.log(f"üì± Extracted phone: {phone}")

            data, fmt = self.decode_base64_data(b64)
            window.console.log(f"üìä Decode result: {fmt}")

            if data:
                window.console.log(f"‚úÖ Successfully decoded data")
                window.console.log(f"üìã Data type: {type(data)}")

                if isinstance(data, dict):
                    window.console.log(f"üîë Data keys: {list(data.keys())}")

                    # ‚úÖ Detect format version
                    if "problem_states" in data:
                        window.console.log("üÜï Detected NEW export format (v2.0)")
                        try:
                            new_subs = self.process_export_data(data, "new_format", phone)
                            window.console.log(f"‚úÖ Created {len(new_subs)} submissions from NEW format")
                            subs.extend(new_subs)
                        except Exception as e:
                            window.console.error(f"‚ùå Error processing NEW format: {e}")
                            import traceback
                            window.console.error(traceback.format_exc())
                            invalid.append({
                                "error": f"NEW format processing error: {e}",
                                "student_phone": phone,
                                "source": "header_block"
                            })

                    elif "problems" in data:
                        window.console.log("üì¶ Detected OLD export format (v1.0)")
                        try:
                            old_subs = self.process_export_data_old(data, fmt, phone)
                            window.console.log(f"‚úÖ Created {len(old_subs)} submissions from OLD format")
                            subs.extend(old_subs)
                        except Exception as e:
                            window.console.error(f"‚ùå Error processing OLD format: {e}")
                            invalid.append({
                                "error": f"OLD format processing error: {e}",
                                "student_phone": phone,
                                "source": "header_block"
                            })
                    else:
                        window.console.error("‚ùå Unknown export format - no 'problem_states' or 'problems' key")
                        invalid.append({
                            "error": f"Unknown export format. Keys: {list(data.keys())}",
                            "student_phone": phone,
                            "source": "header_block"
                        })
                else:
                    window.console.error(f"‚ùå Data is not a dictionary: {type(data)}")
                    invalid.append({
                        "error": f"Invalid data type: {type(data)}",
                        "student_phone": phone,
                        "source": "header_block"
                    })
            else:
                window.console.error(f"‚ùå Failed to decode data: {fmt}")
                snippet = text[max(0, start_idx - 200):start_idx + 200]
                invalid.append({
                    "error": fmt,
                    "student_phone": phone,
                    "source": "header_block",
                    "raw_excerpt": snippet.strip()
                })

        # 3Ô∏è‚É£ Handle stray base64 chunks
        stray_matches = list(re.finditer(r"\b[A-Za-z0-9+/=]{80,}\b", text))
        window.console.log(f"\nüîç Found {len(stray_matches)} potential stray base64 chunks")

        for match in stray_matches:
            # Skip base64 inside already processed blocks
            if any(b.start() <= match.start() <= b.end() for b in export_blocks):
                continue

            window.console.log(f"üì¶ Processing stray chunk at position {match.start()}")
            clean = re.sub(r"[\s\r\n]+", "", match.group(0))
            phone = self.extract_phone_from_context(text, match.start())
            data, fmt = self.decode_base64_data(clean)

            if data:
                if "problem_states" in data:
                    window.console.log("üÜï Stray chunk is NEW format")
                    subs.extend(self.process_export_data(data, "new_format", phone))
                elif "problems" in data:
                    window.console.log("üì¶ Stray chunk is OLD format")
                    subs.extend(self.process_export_data_old(data, fmt, phone))

        total = len(subs) + len(invalid)
        window.console.log(f"\n" + "=" * 80)
        window.console.log(f"üéâ PARSING COMPLETE")
        window.console.log(f"‚úÖ Valid submissions: {len(subs)}")
        window.console.log(f"‚ùå Invalid entries: {len(invalid)}")
        window.console.log(f"üìä Total: {total}")
        window.console.log("=" * 80 + "\n")

        return {"submissions": subs, "invalid": invalid, "total": total}

    def __init__(self):
        self.app = None
        self.analytics_data = []
        self.debug_mode = False
        self.ignored_duplicates = []  # stores same-student duplicate exports (ignored)

    # ============================================================
    # INITIALIZATION / EVENTS
    # ============================================================
    def initialize(self):
        self.bind_events()

    def bind_events(self):
        from pyodide.ffi import create_proxy
        from js import document
        bindings = [
            ("#analyzeBtn", self.analyze_submissions),
            ("#clearAnalyticsBtn", self.clear_analytics),
            ("#loadSavedBtn", self.load_saved_analytics),
            ("#deleteSelectedBtn", self.delete_selected_sessions),
            ("#exportAnalyticsBtn", self.export_analytics),
            ("#whatsappBtn", self.show_whatsapp_integration),
        ]
        for selector, handler in bindings:
            element = document.querySelector(selector)
            if element:
                element.addEventListener("click", create_proxy(handler))

    # ============================================================
    # LATEX / MATRIX HANDLER
    # ============================================================
    def detect_and_convert_matrix(self, latex_str):
        import re
        if not latex_str or not isinstance(latex_str, str):
            return ""

        latex_str = latex_str.strip()

        # Auto-wrap if it's plain numbers separated by spaces or commas
        if re.match(r"^\s*[\d\s,;.-]+\s*$", latex_str):
            # Convert comma/semicolon-separated into rows
            parts = re.split(r"[;,]", latex_str.strip())
            if len(parts) > 1:
                try:
                    rows = [" ".join(p.strip().split()) for p in parts if p.strip()]
                    return "\\begin{bmatrix}" + r"\\ ".join(rows) + "\\end{bmatrix}"
                except:
                    return latex_str

        # Normalize matrix forms
        latex_str = latex_str.replace("\\begin{matrix}", "\\begin{bmatrix}")
        latex_str = latex_str.replace("\\end{matrix}", "\\end{bmatrix}")

        # Fix unbalanced delimiters (extra safety)
        if "\\begin{bmatrix}" in latex_str and "\\end{bmatrix}" not in latex_str:
            latex_str += "\\end{bmatrix}"
        if "\\end{bmatrix}" in latex_str and "\\begin{bmatrix}" not in latex_str:
            latex_str = "\\begin{bmatrix}" + latex_str

        return latex_str

    # ============================================================
    # PHONE NORMALIZATION & CONTEXT EXTRACTION
    # ============================================================
    def normalize_phone(self, p):
        import re
        if not p:
            return ""
        p = re.sub(r"[^\d+]", "", str(p))
        if p.startswith("0"):
            p = "+62" + p[1:]
        elif p.startswith("62") and not p.startswith("+"):
            p = "+" + p
        elif not p.startswith("+") and len(p) > 8:
            p = "+" + p
        return p

    def extract_phone_from_context(self, text, base64_start_pos):
        import re
        # guard
        if text is None:
            return None

        context_start = max(0, base64_start_pos - 1000)
        context = text[context_start:base64_start_pos] if base64_start_pos < len(text) else text

        lines = context.split("\n")
        lines.reverse()

        for line in lines:
            line = line.strip()
            if not line:
                continue

            if "[" in line and "]" in line and ":" in line:
                try:
                    bracket_end = line.find("]")
                    colon_pos = line.find(":", bracket_end)
                    if bracket_end != -1 and colon_pos != -1 and colon_pos > bracket_end:
                        phone_part = line[bracket_end + 1 : colon_pos].strip()
                        if phone_part and ("+62" in phone_part or phone_part.startswith("0") or phone_part.startswith("62")):
                            normalized = self.normalize_phone(phone_part)
                            if normalized:
                                return normalized
                except:
                    pass

            phone_match = re.search(r"(\+62[\s\-\d()]+):", line)
            if phone_match:
                normalized = self.normalize_phone(phone_match.group(1).strip())
                if normalized:
                    return normalized

            zero_match = re.search(r"(0[\s\-\d()]+):", line)
            if zero_match:
                normalized = self.normalize_phone(zero_match.group(1).strip())
                if normalized:
                    return normalized

        return None

    # ============================================================
    # ROSTER LOOKUP
    # ============================================================
    def find_student_in_roster(self, phone):
        if not phone or not getattr(self.app, "student_roster", None):
            return None

        normalized_input = self.normalize_phone(phone)
        if not normalized_input:
            return None

        # Direct match
        roster = self.app.student_roster
        if normalized_input in roster:
            return roster[normalized_input]

        # Try normalizing roster keys
        for roster_phone, info in roster.items():
            if self.normalize_phone(roster_phone) == normalized_input:
                return info

        # Suffix match fallback (last 9-10 digits)
        if len(normalized_input) >= 9:
            input_suffix = normalized_input[-10:]
            for roster_phone, info in roster.items():
                normalized_roster = self.normalize_phone(roster_phone)
                if len(normalized_roster) >= 9 and normalized_roster[-10:] == input_suffix:
                    return info

        return None

    # ============================================================
    # BASE64 / BROTLI / JSON DECODING
    # ============================================================
    def decode_base64_data(self, b64_data):
        import base64, brotli, json
        try:
            decoded = base64.b64decode(b64_data)
        except Exception as e:
            return (None, f"base64 decode error: {e}")

        try:
            out = brotli.decompress(decoded).decode("utf-8")
            return (json.loads(out), "brotli")
        except:
            try:
                out = decoded.decode("utf-8")
                return (json.loads(out), "json")
            except Exception as e:
                return (None, f"json decode error: {e}")

    # ============================================================
    # TELEGRAM PARTS RECONSTRUCTION
    # ============================================================
    def reconstruct_telegram_parts(self, text):
        import re
        if "=== STUDENT PROGRESS EXPORT (Part" not in text:
            return (None, 0)

        pattern = r"===\s*STUDENT PROGRESS EXPORT\s*\(Part\s*(\d+)\s*/\s*(\d+)\)\s*===\s*(.*?)\s*===\s*END PART\s*\1\s*==="
        matches = list(re.finditer(pattern, text, re.DOTALL | re.IGNORECASE))
        if not matches:
            return (None, 0)

        parts = {}
        total_parts = 0
        for m in matches:
            pnum = int(m.group(1))
            total = int(m.group(2))
            content = re.sub(r"[\s\r\n]+", "", m.group(3).strip())
            parts[pnum] = content
            total_parts = max(total_parts, total)

        reconstructed = "".join(parts.get(i, "") for i in range(1, total_parts + 1))
        return (reconstructed if reconstructed else None, len(parts))

    # ============================================================
    # PROCESS EXPORT DATA
    # ============================================================
    def process_export_data(self, data, format_type, phone_from_message=None, telegram_parts=0):
        """Process the NEW export format from Problem Solver app with extensive debugging"""
        import json, hashlib
        from js import window

        window.console.log("=" * 60)
        window.console.log("üîç PROCESS_EXPORT_DATA CALLED")
        window.console.log("=" * 60)

        # Log the raw data structure
        window.console.log(f"üì¶ Data type: {type(data)}")
        window.console.log(f"üì¶ Data keys: {list(data.keys()) if isinstance(data, dict) else 'NOT A DICT'}")

        # Check for key fields
        has_problem_states = "problem_states" in data if isinstance(data, dict) else False
        has_problem_set = "problem_set" in data if isinstance(data, dict) else False
        has_problems = "problems" in data if isinstance(data, dict) else False

        window.console.log(f"‚úì Has problem_states: {has_problem_states}")
        window.console.log(f"‚úì Has problem_set: {has_problem_set}")
        window.console.log(f"‚úì Has problems (old format): {has_problems}")

        # If it's the NEW format
        if has_problem_states and has_problem_set:
            window.console.log("üÜï Processing NEW format (v2.0)")

            subs = []
            export_timestamp = str(window.Date.new().getTime())

            # Generate export ID
            export_id_source = f"{data.get('problem_set_id', '')}_{data.get('export_date', '')}_{export_timestamp}"
            export_id = hashlib.md5(export_id_source.encode()).hexdigest()
            window.console.log(f"üÜî Export ID: {export_id}")

            # Extract metadata
            problem_set_id = data.get("problem_set_id", "unknown")
            export_date = data.get("export_date", window.Date.new().toISOString())
            problem_set = data.get("problem_set", [])
            problem_states = data.get("problem_states", {})

            window.console.log(f"üìã Problem set ID: {problem_set_id}")
            window.console.log(f"üìÖ Export date: {export_date}")
            window.console.log(f"üìö Problem set length: {len(problem_set)}")
            window.console.log(f"üìä Problem states keys: {list(problem_states.keys())}")

            # ‚≠ê Calculate total steps across ALL problems in the problem set
            total_available_steps = 0
            for prob_def in problem_set:
                prob_steps = prob_def.get("steps", [])
                total_available_steps += len(prob_steps)

            window.console.log(f"üìä Total available steps in problem set: {total_available_steps}")
            window.console.log(f"üìä Total problems in problem set: {len(problem_set)}")

            # Determine phone number
            phone = phone_from_message if phone_from_message else "anonymous"
            window.console.log(f"üì± Phone: {phone}")

            # Process each problem
            for prob_idx_str, step_states in problem_states.items():
                window.console.log(f"\n--- Processing problem index: {prob_idx_str} ---")

                prob_idx = int(prob_idx_str)
                window.console.log(f"üìç Problem index (int): {prob_idx}")
                window.console.log(f"üìç Number of steps: {len(step_states)}")

                # Get problem definition
                if prob_idx >= len(problem_set):
                    window.console.warn(f"‚ö†Ô∏è Problem index {prob_idx} out of range (problem_set length: {len(problem_set)})")
                    continue

                problem_def = problem_set[prob_idx]
                window.console.log(f"üìñ Problem definition keys: {list(problem_def.keys())}")

                problem_title = problem_def.get("title", f"Problem {prob_idx + 1}")
                window.console.log(f"üìù Problem title: {problem_title}")

                # Calculate summary statistics
                total_steps = len(step_states)

                # ‚úÖ Support both 'finalized' and 'finished' field names
                # ‚úÖ For non-math types, consider finalized if they have an answer
                def is_step_finalized(s):
                    # Check standard finalized/finished fields
                    finalized = s.get("finalized", s.get("finished", False))

                    # Special handling for non-math-expression types
                    step_type = s.get("step_type", "")
                    if step_type in ["multiple-choice-single", "multiple-choice-multiple", "true-false", "fill-blank", "multi-mc"]:
                        # For these types, consider finalized if answered or correct
                        user_answers = s.get("user_answers", [])
                        is_correct = s.get("correct", False)
                        # For multi-mc, user_answers is a dict; for others it's a list
                        has_answer = user_answers and (len(user_answers) > 0 if isinstance(user_answers, (list, dict)) else False)

                        if is_correct or has_answer:
                            return True

                    return finalized

                finalized_steps = sum(1 for s in step_states if is_step_finalized(s))
                correct_steps = sum(1 for s in step_states if s.get("correct", False))
                # ‚úÖ Support both attempt_history (array) and attempts (count)
                def get_attempt_count(s):
                    attempt_history = s.get("attempt_history", [])
                    if attempt_history:
                        return len(attempt_history)
                    return s.get("attempts", 0)
                total_attempts = sum(get_attempt_count(s) for s in step_states)
                total_finalize_attempts = sum(s.get("finalize_attempts", 0) for s in step_states)

                window.console.log(f"üìä Statistics:")
                window.console.log(f"  - Total steps: {total_steps}")
                window.console.log(f"  - Finalized: {finalized_steps}")
                window.console.log(f"  - Correct: {correct_steps}")
                window.console.log(f"  - Total attempts: {total_attempts}")
                window.console.log(f"  - Total finalize attempts: {total_finalize_attempts}")

                # Build steps progress array
                steps_progress = []
                for step_idx, step_state in enumerate(step_states):
                    window.console.log(f"  üìå Step {step_idx + 1}:")
                    window.console.log(f"    - Keys: {list(step_state.keys())}")

                    # ‚úÖ Support both 'finalized' and 'finished' field names
                    is_finalized = step_state.get("finalized", step_state.get("finished", False))

                    # ‚úÖ SPECIAL HANDLING: For non-math-expression types, auto-finalize if answered
                    # Non-math types (MC, T/F, fill-blank, multi-mc) are "done" once they submit an answer
                    # Unlike math-expression which requires explicit finalization
                    step_type = step_state.get("step_type", "")
                    if step_type in ["multiple-choice-single", "multiple-choice-multiple", "true-false", "fill-blank", "multi-mc"]:
                        # For these types, auto-finalize if:
                        # 1. Already marked as finished/finalized, OR
                        # 2. They answered correctly, OR
                        # 3. They have at least one answer (attempted the question)
                        user_answers = step_state.get("user_answers", [])
                        is_correct = step_state.get("correct", False)
                        # For multi-mc, user_answers is a dict; for others it's a list
                        has_answer = user_answers and (len(user_answers) > 0 if isinstance(user_answers, (list, dict)) else False)

                        if is_correct or has_answer:
                            is_finalized = True
                            # ‚úÖ UPDATE THE STORED DATA: Explicitly set finalized=True
                            step_state["finalized"] = True
                            window.console.log(f"    - Non-math type '{step_type}' with answer ‚Üí setting finalized=True")

                    window.console.log(f"    - Finalized/Finished: {is_finalized}")
                    window.console.log(f"    - Correct: {step_state.get('correct', False)}")

                    # ‚úÖ Support both attempt_history (array) and attempts (count)
                    attempt_history = step_state.get("attempt_history", [])
                    attempt_count = len(attempt_history) if attempt_history else step_state.get("attempts", 0)
                    window.console.log(f"    - Attempts: {attempt_count}")

                    step_progress = {
                        "step_number": step_idx + 1,
                        "finalized": is_finalized,
                        "correct": step_state.get("correct", False),
                        "structure_correct": step_state.get("structure_correct", False),
                        "attempts": []
                    }

                    # ‚úÖ Add attempt history from either format
                    if attempt_history:
                        # New format with detailed attempt_history
                        for att_idx, attempt in enumerate(attempt_history):
                            window.console.log(f"      ‚úèÔ∏è Attempt {att_idx + 1}: {attempt.get('correct', False)}")
                            step_progress["attempts"].append({
                                "answer_latex": attempt.get("answer_latex", ""),
                                "expression": step_state.get("step", {}).get("expression", ""),
                                "correct": attempt.get("correct", False),
                                "time_taken_seconds": attempt.get("time_taken_seconds", 0)
                            })
                    elif "user_answers" in step_state:
                        # Desktop format with user_answers array or dict
                        user_answers = step_state.get("user_answers", [])

                        # ‚úÖ SPECIAL HANDLING: For multi-mc, user_answers is a dict
                        if step_type == "multi-mc" and user_answers:
                            if isinstance(user_answers, dict):
                                # Dictionary of {label: value} for multi-mc
                                window.console.log(f"      üìã Multi-MC: treating {len(user_answers)} dropdown selections as 1 attempt")
                                step_progress["attempts"].append({
                                    "answer_latex": str(user_answers),  # Store all selections together
                                    "expression": "",
                                    "correct": step_state.get("correct", False),
                                    "time_taken_seconds": 0
                                })
                            else:
                                window.console.log(f"      ‚ö†Ô∏è Multi-MC has unexpected format: {type(user_answers)}")
                        # ‚úÖ SPECIAL HANDLING: For MC-multiple, treat entire array as ONE attempt
                        elif step_type == "multiple-choice-multiple" and user_answers:
                            # All selected options in one submission = 1 attempt
                            window.console.log(f"      üìã MC-multiple: treating {len(user_answers)} selections as 1 attempt")
                            step_progress["attempts"].append({
                                "answer_latex": str(user_answers),  # Store all selections together
                                "expression": "",
                                "correct": step_state.get("correct", False),
                                "time_taken_seconds": 0
                            })
                        else:
                            # For other types, each user_answer is a separate attempt
                            if isinstance(user_answers, list):
                                window.console.log(f"      üìù Desktop format: {len(user_answers)} user answers")
                                for att_idx, answer in enumerate(user_answers):
                                    # For desktop format, we only know the final answer is correct if step is correct and it's the last answer
                                    is_correct = step_state.get("correct", False) and att_idx == len(user_answers) - 1
                                    step_progress["attempts"].append({
                                        "answer_latex": answer if isinstance(answer, str) else str(answer),
                                        "expression": "",
                                        "correct": is_correct,
                                        "time_taken_seconds": 0
                                    })
                            else:
                                window.console.log(f"      ‚ö†Ô∏è Unexpected user_answers format: {type(user_answers)}")

                    steps_progress.append(step_progress)

                # Build submission object
                sub = {
                    "export_id": export_id,
                    "export_metadata": {
                        "problem_set_id": problem_set_id,
                        "export_date": export_date,
                        "format_version": "2.0",
                        "student_phone": phone,
                        "student_name": "Unknown",
                        # ‚≠ê NEW: Store problem set metadata for accurate scoring
                        "total_problems_in_set": len(problem_set),
                        "total_steps_in_set": total_available_steps
                    },
                    "student_phone": phone,
                    "student_name": "Unknown",
                    "problem": {
                        "number": prob_idx + 1,
                        "title": problem_title,
                        "id": problem_set_id + "_" + str(prob_idx)
                    },
                    "summary": {
                        "total_steps": total_steps,
                        "finalized_steps": finalized_steps,
                        "correct_steps": correct_steps,
                        "total_attempts": total_attempts,
                        "total_finalize_attempts": total_finalize_attempts,
                        "completion_rate": round((finalized_steps / total_steps * 100) if total_steps > 0 else 0, 2)
                    },
                    "steps_progress": steps_progress,
                    "total_time_seconds": 0,
                    "analysis_timestamp": window.Date.new().toISOString()
                }

                window.console.log(f"‚úÖ Created submission for problem {prob_idx + 1}")
                subs.append(sub)

            window.console.log(f"\nüéâ Total submissions created: {len(subs)}")
            window.console.log("=" * 60)
            return subs

        # If it's the OLD format
        elif has_problems:
            window.console.log("üì¶ Processing OLD format (v1.0)")
            return self.process_export_data_old(data, format_type, phone_from_message)

        # Unknown format
        else:
            window.console.error("‚ùå Unknown export format!")
            window.console.error(f"Data structure: {json.dumps(data, indent=2)[:500]}")
            return []
                       # ============================================================
    # MERGE ROSTER DATA
    # ============================================================
    def merge_roster_data(self, submissions):
        if not submissions:
            return submissions

        for sub in submissions:
            phone = sub.get("student_phone", "")
            roster_info = self.find_student_in_roster(phone)

            if roster_info:
                sub["student_name"] = roster_info.get("name", sub.get("student_name", "Unknown"))
                sub["registration_number"] = roster_info.get("registration_number", "")
                if "export_metadata" not in sub:
                    sub["export_metadata"] = {}
                sub["export_metadata"]["student_name"] = sub["student_name"]
                sub["export_metadata"]["registration_number"] = sub["registration_number"]

        return submissions

    # ============================================================
    # SCORE HELPERS
    # ============================================================
    def calculate_student_score(self, student_subs):
        """
        Calculate student score based on ALL available steps in the problem set,
        not just the steps in problems they attempted.
        """
        # Get total finalized steps from attempted problems
        finalized = sum(s.get("summary", {}).get("finalized_steps", 0) for s in student_subs)

        # Try to get total steps from problem set metadata (if available)
        total_steps_in_set = None
        for s in student_subs:
            export_meta = s.get("export_metadata", {})
            if "total_steps_in_set" in export_meta:
                total_steps_in_set = export_meta["total_steps_in_set"]
                break

        # If problem set metadata is available, use it (NEW behavior)
        if total_steps_in_set is not None and total_steps_in_set > 0:
            try:
                return round((finalized / total_steps_in_set) * 100, 2)
            except:
                return 0.0

        # Fallback: use only attempted steps (OLD behavior for backward compatibility)
        total_attempted_steps = sum(s.get("summary", {}).get("total_steps", 0) for s in student_subs)
        if total_attempted_steps == 0:
            return 0.0

        try:
            return round((finalized / total_attempted_steps) * 100, 2)
        except:
            return 0.0

    def get_score_class(self, score):
        if score >= 80:
            return "score-high"
        elif score >= 50:
            return "score-medium"
        else:
            return "score-low"

    # ============================================================
    # HASH EXPORT DATA
    # ============================================================
    def hash_export_data(self, export_id, submissions):
        import json, hashlib
        export_subs = [s for s in submissions if s.get("export_id") == export_id]
        if not export_subs:
            return None

        export_subs.sort(key=lambda x: x.get("problem", {}).get("number", 0))
        export_data = []

        for sub in export_subs:
            steps = sub.get("steps_progress", []) or []
            problem_data = {
                "problem_number": sub.get("problem", {}).get("number"),
                "steps": []
            }

            for step in steps:
                if isinstance(step, dict):
                    step_info = {
                        "step_number": step.get("step_number"),
                        "finalized": step.get("finalized", False),
                        "attempts": []
                    }
                    for att in step.get("attempts", []) or []:
                        if isinstance(att, dict):
                            step_info["attempts"].append({
                                "answer": att.get("answer_latex", ""),
                                "correct": att.get("correct", False)
                            })
                    problem_data["steps"].append(step_info)

            export_data.append(problem_data)

        json_str = json.dumps(export_data, sort_keys=True, separators=(',', ':'))
        return hashlib.sha256(json_str.encode()).hexdigest()

    # ============================================================
    # CHEATING DETECTION (ignores same-student duplicates)
    # ============================================================
    def is_unworked_submission(self, sub):
        """Check if a submission represents an unworked problem"""
        summary = sub.get("summary", {})
        steps_progress = sub.get("steps_progress", [])

        # Check summary statistics
        finalized_steps = summary.get("finalized_steps", 0)
        total_attempts = summary.get("total_attempts", 0)
        correct_steps = summary.get("correct_steps", 0)

        # If there are finalized steps, attempts, or correct steps, it's worked
        if finalized_steps > 0 or total_attempts > 0 or correct_steps > 0:
            return False

        # Check step-level details
        for step in steps_progress:
            if isinstance(step, dict):
                step_finalized = step.get("finalized", False)
                step_attempts = step.get("attempts", [])
                step_correct = step.get("correct", False)

                # If any step has attempts, is finalized, or is correct, it's worked
                if step_finalized or step_correct or (step_attempts and len(step_attempts) > 0):
                    return False

        # If we get here, no work was done
        return True

    def detect_cheating(self, submissions):
        from collections import defaultdict
        # reset ignored list
        ignored_duplicates = []

        if len(submissions) < 2:
            self.ignored_duplicates = []
            return []

        # Group submissions by (student, problem_number) first - ignore content hash for now
        student_problem_groups = defaultdict(list)

        for sub in submissions:
            # Create student identifier
            student_key = (
                sub.get("registration_number")
                or self.normalize_phone(sub.get("student_phone", ""))
                or sub.get("student_name", "").strip().lower()
            )

            problem_number = sub.get("problem", {}).get("number", 0)
            group_key = (student_key, problem_number)
            student_problem_groups[group_key].append(sub)

        # Process each student-problem group to keep only the most complete submission
        kept_submissions = []

        for group_key, group_submissions in student_problem_groups.items():
            student_key, problem_number = group_key

            if len(group_submissions) == 1:
                # Only one submission for this student-problem, keep it
                kept_submissions.extend(group_submissions)
            else:
                # Multiple submissions for same student-problem, keep the most complete
                def get_completion_score(sub):
                    """Calculate how complete a submission is"""
                    summary = sub.get("summary", {})
                    finalized_steps = summary.get("finalized_steps", 0)
                    total_attempts = summary.get("total_attempts", 0)
                    correct_steps = summary.get("correct_steps", 0)
                    total_steps = summary.get("total_steps", 1)  # avoid division by zero

                    # Score based on: finalized steps (most important), then attempts, then timestamp
                    completion_rate = finalized_steps / total_steps if total_steps > 0 else 0
                    return (
                        completion_rate,  # Primary: completion rate
                        finalized_steps,  # Secondary: absolute finalized steps
                        total_attempts,   # Tertiary: total attempts made
                        correct_steps,    # Fourth: correct steps
                        sub.get("analysis_timestamp", "")  # Tiebreaker: later timestamp
                    )

                # Sort by completion score (descending) to get most complete first
                group_submissions.sort(key=get_completion_score, reverse=True)

                # Keep the most complete submission
                best_submission = group_submissions[0]
                kept_submissions.append(best_submission)

                # Mark the rest as duplicates
                for duplicate_sub in group_submissions[1:]:
                    best_summary = best_submission.get("summary", {})
                    dup_summary = duplicate_sub.get("summary", {})

                    reason = f"Less complete submission of Problem {problem_number} (kept: {best_summary.get('finalized_steps', 0)}/{best_summary.get('total_steps', 0)} finalized, discarded: {dup_summary.get('finalized_steps', 0)}/{dup_summary.get('total_steps', 0)} finalized)"

                    ignored_duplicates.append({
                        "student_phone": duplicate_sub.get("student_phone", ""),
                        "student_name": duplicate_sub.get("student_name", "Unknown"),
                        "registration_number": duplicate_sub.get("registration_number", ""),
                        "export_id": duplicate_sub.get("export_id", ""),
                        "problem_number": duplicate_sub.get("problem", {}).get("number", 0),
                        "problem_title": duplicate_sub.get("problem", {}).get("title", ""),
                        "export_timestamp": duplicate_sub.get("analysis_timestamp", ""),
                        "reason": reason
                    })

        # Now create problem-level content hashes for the kept submissions only
        problem_hashes = {}
        for sub in kept_submissions:
            problem_hash = self.hash_problem_data(sub)
            if problem_hash:
                problem_hashes[f"{sub.get('export_id', '')}_{sub.get('problem', {}).get('number', 0)}"] = problem_hash

        # Now detect cheating (different students with identical content) using kept submissions
        # Group by (problem_number, content_hash) to find different students with same content
        content_groups = defaultdict(list)

        # Group kept submissions by content hash
        for sub in kept_submissions:
            problem_number = sub.get("problem", {}).get("number", 0)
            submission_key = f"{sub.get('export_id', '')}_{problem_number}"
            problem_hash = problem_hashes.get(submission_key)

            if problem_hash:
                content_key = (problem_number, problem_hash)
                content_groups[content_key].append(sub)

        # Build cheating groups (after all submissions are processed)
        cheating_groups = []
        group_number = 1

        for content_key, group_submissions in content_groups.items():
            problem_number, problem_hash = content_key

            if len(group_submissions) <= 1:
                continue

            # Check if all submissions in this group are unworked
            all_unworked = all(self.is_unworked_submission(sub) for sub in group_submissions)
            if all_unworked:
                # Skip this group - multiple students with same unworked problem is not cheating
                continue

            # Group by student to ensure we're looking at different students
            students_map = {}
            for sub in group_submissions:
                student_key = (
                    sub.get("registration_number")
                    or self.normalize_phone(sub.get("student_phone", ""))
                    or sub.get("student_name", "").strip().lower()
                )
                if student_key not in students_map:
                    students_map[student_key] = sub

            # If multiple different students have identical content, it's cheating
            if len(students_map) > 1:
                unique_students = list(students_map.values())

                cheating_groups.append({
                    "group_number": group_number,
                    "problems": [f"Problem {problem_number}: {unique_students[0].get('problem', {}).get('title', 'Unknown')}"],
                    "problem_count": 1,
                    "hash": problem_hash[:16] + "...",
                    "students": [{
                        "name": sub.get("student_name", "Unknown"),
                        "reg_no": sub.get("registration_number", ""),
                        "phone": sub.get("student_phone", ""),
                        "export_timestamp": sub.get("analysis_timestamp", ""),
                        "export_id": sub.get("export_id", "")
                    } for sub in unique_students],
                    "count": len(unique_students)
                })
                group_number += 1

        # Persist the ignored duplicates list for DisplayManager to use
        self.ignored_duplicates = ignored_duplicates
        return cheating_groups

    # ============================================================
    # UI ACTIONS: analyze / clear / export
    # ============================================================
    def analyze_submissions(self, e=None):
        from js import document, window
        import asyncio

        text = document.querySelector("#pasteProgressData").value
        parsed = self.parse_submissions(text)
        submissions = parsed["submissions"]
        invalid = parsed["invalid"]

        if not submissions and not invalid:
            window.alert("No valid submissions found.")
            return

        # Check for submissions without phone numbers
        missing_phone = [s for s in submissions if not s.get("student_phone")]
        if missing_phone:
            warning_msg = f"‚ö†Ô∏è WARNING: {len(missing_phone)} submission(s) missing phone numbers!\n\n"
            warning_msg += "Submissions without phone numbers cannot be matched with roster data.\n\n"
            warning_msg += "Missing phone for:\n"
            for i, sub in enumerate(missing_phone[:5], 1):  # Show first 5
                name = sub.get("student_name", "Unknown")
                reg = sub.get("registration_number", "Unknown")
                warning_msg += f"  {i}. {name} ({reg})\n"
            if len(missing_phone) > 5:
                warning_msg += f"  ... and {len(missing_phone) - 5} more\n"
            warning_msg += "\nContinue anyway?"

            if not window.confirm(warning_msg):
                return

        submissions = self.merge_roster_data(submissions)

        self.analytics_data.extend(submissions)
        self.app.analytics_data = self.analytics_data
        document.querySelector("#pasteProgressData").value = ""

        # Update UI
        self.app.display_manager.display_analytics(self.analytics_data, invalid)

        # Persist asynchronously
        asyncio.ensure_future(self.app.persistence_manager.save_analytics_data())

        # Show summary with phone warning if needed
        summary_msg = f"‚úÖ Added {len(submissions)} submissions.\nInvalid: {len(invalid)}"
        if missing_phone:
            summary_msg += f"\n\n‚ö†Ô∏è {len(missing_phone)} submission(s) missing phone numbers"
        window.alert(summary_msg)

    def clear_analytics(self, e=None):
        from js import document
        import asyncio

        self.analytics_data = []
        self.app.analytics_data = []
        document.querySelector("#analyticsResults").innerHTML = ""

        asyncio.ensure_future(self.app.persistence_manager.clear_stored_analytics())

        from js import window
        window.alert("Analytics cleared.")

    def load_saved_analytics(self, e=None):
        """Trigger the load saved analytics modal"""
        import asyncio
        asyncio.ensure_future(self.app.persistence_manager.restore_saved_analytics())

    def delete_selected_sessions(self, e=None):
        """Show modal to select and delete saved sessions"""
        import asyncio
        asyncio.ensure_future(self.app.persistence_manager.show_delete_sessions_modal())

    def export_analytics(self, e=None):
        from js import window
        import json

        if not self.analytics_data:
            window.alert("No analytics data to export.")
            return

        cheating_groups = self.detect_cheating(self.analytics_data)
        ignored = getattr(self, "ignored_duplicates", [])

        report = {
            "metadata": {
                "generated": window.Date.new().toISOString(),
                "total": len(self.analytics_data),
                "cheating_groups": len(cheating_groups),
                "ignored_duplicates": len(ignored)
            },
            "data": self.analytics_data,
            "ignored": ignored,
            "cheating_report": cheating_groups
        }

        js_text = json.dumps(report, indent=2)
        blob = window.Blob.new([js_text], {"type": "application/json"})
        url = window.URL.createObjectURL(blob)

        a = window.document.createElement("a")
        a.href = url
        a.download = f"analytics_{window.Date.new().toISOString().replace(':','-')}.json"
        window.document.body.appendChild(a)
        a.click()
        a.remove()
        window.URL.revokeObjectURL(url)

        msg = f"‚úÖ Exported {len(self.analytics_data)} submissions."
        if cheating_groups:
            msg += f"\n\nüö® Found {len(cheating_groups)} cheating groups."
        if ignored:
            msg += f"\nüïì Ignored {len(ignored)} duplicate submissions."
        window.alert(msg)

    # ============================================================
    # WHATSAPP INTEGRATION
    # ============================================================
    def show_whatsapp_integration(self, e=None):
        """Show WhatsApp integration modal with options to connect and import chats"""
        from js import window, document
        from pyodide.ffi import create_proxy

        # Create modal overlay
        overlay = document.createElement("div")
        overlay.className = "modal"
        overlay.style.cssText = "display:flex;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5);z-index:10000;justify-content:center;align-items:center;"

        # Create modal content
        modal = document.createElement("div")
        modal.className = "modal-content"
        modal.style.cssText = "background:white;border-radius:12px;padding:24px;max-width:700px;width:90%;max-height:80vh;overflow-y:auto;"

        modal.innerHTML = """
            <div style="margin-bottom:20px;">
                <h2 style="margin:0 0 16px 0;color:#0f172a;font-size:24px;">üí¨ WhatsApp Integration</h2>
                <p style="color:#64748b;margin:0 0 20px 0;">
                    Two ways to capture student progress reports from WhatsApp.
                </p>
            </div>

            <div style="background:linear-gradient(135deg, #10b981 0%, #059669 100%);color:white;border-radius:12px;padding:20px;margin-bottom:20px;box-shadow:0 4px 12px rgba(16,185,129,0.3);">
                <div style="display:flex;align-items:center;gap:12px;margin-bottom:12px;">
                    <div style="font-size:32px;">üöÄ</div>
                    <div>
                        <h3 style="margin:0;font-size:18px;font-weight:700;">NEW: Browser Extension (RECOMMENDED!)</h3>
                        <p style="margin:4px 0 0 0;opacity:0.95;font-size:13px;">Automatic real-time capture with ONE CLICK</p>
                    </div>
                </div>
                <div style="background:rgba(255,255,255,0.15);border-radius:8px;padding:14px;margin:12px 0;">
                    <p style="margin:0 0 10px 0;font-weight:600;font-size:14px;">How it works:</p>
                    <ol style="margin:0 0 0 20px;padding:0;font-size:13px;line-height:1.8;">
                        <li>Install the Chrome extension (see instructions below)</li>
                        <li>Open WhatsApp Web - extension monitors automatically</li>
                        <li>Students send progress reports - captured in real-time</li>
                        <li>Click "Auto-Inject" in extension - data appears here instantly!</li>
                    </ol>
                </div>
                <button id="showExtensionGuideBtn" class="btn" style="background:white;color:#059669;padding:10px 20px;border-radius:6px;border:none;cursor:pointer;font-size:14px;font-weight:600;width:100%;">
                    üìñ View Extension Installation Guide
                </button>
            </div>

            <div style="background:#eff6ff;border-radius:12px;padding:20px;margin-bottom:20px;border:2px solid #3b82f6;">
                <div style="display:flex;align-items:center;gap:12px;margin-bottom:12px;">
                    <div style="font-size:32px;">üìä</div>
                    <div>
                        <h3 style="margin:0;font-size:18px;font-weight:700;color:#1e40af;">Real-Time Progress Update</h3>
                        <p style="margin:4px 0 0 0;color:#1e3a8a;font-size:13px;">Live dashboard of student submissions</p>
                    </div>
                </div>
                <p style="margin:0 0 12px 0;color:#1e3a8a;font-size:13px;line-height:1.6;">
                    Monitor student progress in real-time as submissions arrive. Perfect for tracking class progress during assignments.
                </p>
                <button id="activateRealTimeBtn" class="btn" style="background:#3b82f6;color:white;padding:10px 20px;border-radius:6px;border:none;cursor:pointer;font-size:14px;font-weight:600;width:100%;">
                    üìä Activate Real-Time Dashboard
                </button>
            </div>

            <div style="background:#fef3c7;border-radius:12px;padding:20px;margin-bottom:20px;border:2px solid #f59e0b;">
                <div style="display:flex;align-items:center;gap:12px;margin-bottom:12px;">
                    <div style="font-size:32px;">üèÜ</div>
                    <div>
                        <h3 style="margin:0;font-size:18px;font-weight:700;color:#92400e;">Timed-Quiz Leaderboard</h3>
                        <p style="margin:4px 0 0 0;color:#78350f;font-size:13px;">Competitive quiz with live rankings</p>
                    </div>
                </div>
                <p style="margin:0 0 12px 0;color:#78350f;font-size:13px;line-height:1.6;">
                    Run timed quizzes with live leaderboard. Students compete and rankings update based on correct answers and speed.
                </p>
                <button id="activateTimedQuizBtn" class="btn" style="background:#f59e0b;color:white;padding:10px 20px;border-radius:6px;border:none;cursor:pointer;font-size:14px;font-weight:600;width:100%;">
                    üèÜ Launch Timed-Quiz Mode
                </button>
            </div>

            <div style="background:#f1f5f9;border-radius:8px;padding:16px;margin-bottom:20px;">
                <div style="display:flex;align-items:center;gap:12px;margin-bottom:12px;">
                    <div style="font-size:24px;">üì§</div>
                    <div>
                        <h3 style="margin:0;font-size:16px;font-weight:700;color:#475569;">Manual Upload (Backup Method)</h3>
                        <p style="margin:4px 0 0 0;color:#64748b;font-size:12px;">For when you can't use the extension</p>
                    </div>
                </div>

                <details style="margin-top:12px;">
                    <summary style="cursor:pointer;padding:10px;background:#e2e8f0;border-radius:6px;font-weight:600;color:#334155;font-size:14px;">
                        Click to show manual upload instructions
                    </summary>
                    <div style="padding:16px 0;">
                        <div style="background:#e0f2fe;border-left:4px solid #0ea5e9;padding:12px;border-radius:6px;margin-bottom:16px;">
                            <h4 style="margin:0 0 8px 0;color:#0369a1;font-size:14px;">Steps:</h4>
                            <ol style="margin:0 0 0 20px;color:#075985;font-size:13px;line-height:1.6;">
                                <li>Open WhatsApp Web and login</li>
                                <li>Export chat: 3 dots (‚ãÆ) ‚Üí More ‚Üí Export chat ‚Üí Without Media</li>
                                <li>Upload the .txt file below</li>
                            </ol>
                        </div>

                        <button id="openWhatsAppBtn" class="btn" style="background:#25D366;color:white;padding:10px 20px;border-radius:6px;border:none;cursor:pointer;font-size:14px;font-weight:600;margin-bottom:12px;width:100%;">
                            üåê Open WhatsApp Web
                        </button>

                        <input type="file" id="whatsappFileInput" accept=".txt" style="margin-bottom:10px;padding:8px;border:1px solid #cbd5e1;border-radius:6px;width:100%;font-size:13px;"/>
                        <button id="importWhatsAppBtn" class="btn" style="background:#3b82f6;color:white;padding:10px 20px;border-radius:6px;border:none;cursor:pointer;font-size:14px;font-weight:600;width:100%;">
                            üì• Import Chat Export
                        </button>
                    </div>
                </details>
            </div>

            <div style="text-align:right;">
                <button id="closeWhatsAppModalBtn" class="btn ghost" style="padding:10px 20px;border-radius:6px;border:1px solid #e2e8f0;background:white;cursor:pointer;font-size:14px;">
                    Close
                </button>
            </div>
        """

        overlay.appendChild(modal)
        document.body.appendChild(overlay)

        # Event handlers
        def show_extension_guide(evt):
            guide_html = """
                <div style='max-width:600px;'>
                    <h3 style='margin-top:0;color:#059669;'>üöÄ Browser Extension Installation</h3>

                    <div style='background:#f0fdf4;border:2px solid #10b981;border-radius:8px;padding:16px;margin-bottom:16px;'>
                        <h4 style='margin:0 0 12px 0;color:#065f46;'>Quick Setup (5 minutes)</h4>
                        <ol style='margin:0;padding-left:20px;color:#064e3b;line-height:1.8;'>
                            <li>Go to <strong>chrome://extensions</strong> in your browser</li>
                            <li>Enable <strong>"Developer mode"</strong> (top-right toggle)</li>
                            <li>Click <strong>"Load unpacked"</strong></li>
                            <li>Select the <code>whatsapp-analytics-extension</code> folder</li>
                            <li>Click <strong>"Details"</strong> ‚Üí Enable <strong>"Allow access to file URLs"</strong></li>
                            <li>Set this page's URL in extension settings</li>
                        </ol>
                    </div>

                    <div style='background:#eff6ff;border-left:4px solid #3b82f6;border-radius:6px;padding:16px;margin-bottom:16px;'>
                        <h4 style='margin:0 0 8px 0;color:#1e40af;'>‚ú® How to Use:</h4>
                        <ol style='margin:0;padding-left:20px;color:#1e3a8a;line-height:1.8;'>
                            <li>Open WhatsApp Web - extension monitors automatically</li>
                            <li>Students send progress reports - captured in real-time</li>
                            <li>Click extension icon ‚Üí <strong>"üöÄ Auto-Inject to Analytics"</strong></li>
                            <li>Data appears in this page instantly!</li>
                        </ol>
                    </div>

                    <div style='background:#fef3c7;border-left:4px solid #f59e0b;border-radius:6px;padding:14px;'>
                        <p style='margin:0;color:#92400e;font-size:13px;'>
                            <strong>üìÅ Extension Location:</strong><br>
                            The extension folder is in your project directory:<br>
                            <code style='background:#fbbf24;color:#78350f;padding:2px 6px;border-radius:4px;'>whatsapp-analytics-extension/</code>
                        </p>
                    </div>
                </div>
            """
            window.alert("Browser Extension Installation Guide\n\n" +
                        "1. Open chrome://extensions in Chrome\n" +
                        "2. Enable 'Developer mode' (top-right)\n" +
                        "3. Click 'Load unpacked'\n" +
                        "4. Select the 'whatsapp-analytics-extension' folder\n" +
                        "5. Click 'Details' and enable 'Allow access to file URLs'\n" +
                        "6. Configure Analytics App URL in extension settings\n\n" +
                        "Then:\n" +
                        "- Open WhatsApp Web\n" +
                        "- Extension captures reports automatically\n" +
                        "- Click 'Auto-Inject' to send data here!\n\n" +
                        "See README.md in whatsapp-analytics-extension folder for details.")

        def open_whatsapp(evt):
            window.open("https://web.whatsapp.com", "_blank")

        def close_modal(evt=None):
            overlay.remove()

        def import_chat(evt):
            file_input = document.querySelector("#whatsappFileInput")
            if not file_input or not file_input.files or file_input.files.length == 0:
                window.alert("‚ö†Ô∏è Please select a WhatsApp chat export file first.")
                return

            # Read the file
            file = file_input.files[0]
            reader = window.FileReader.new()

            def on_load(e):
                chat_content = e.target.result
                # Parse and import the chat
                self.import_whatsapp_chat(chat_content, file.name)
                close_modal()

            reader.onload = create_proxy(on_load)
            reader.readAsText(file)

        def activate_real_time(evt):
            close_modal()
            self.show_real_time_dashboard()

        def activate_timed_quiz(evt):
            close_modal()
            self.show_timed_quiz_mode()

        # Bind events
        extension_guide_btn = document.querySelector("#showExtensionGuideBtn")
        realtime_btn = document.querySelector("#activateRealTimeBtn")
        timedquiz_btn = document.querySelector("#activateTimedQuizBtn")
        open_btn = document.querySelector("#openWhatsAppBtn")
        close_btn = document.querySelector("#closeWhatsAppModalBtn")
        import_btn = document.querySelector("#importWhatsAppBtn")

        if extension_guide_btn:
            extension_guide_btn.addEventListener("click", create_proxy(show_extension_guide))
        if realtime_btn:
            realtime_btn.addEventListener("click", create_proxy(activate_real_time))
        if timedquiz_btn:
            timedquiz_btn.addEventListener("click", create_proxy(activate_timed_quiz))
        if open_btn:
            open_btn.addEventListener("click", create_proxy(open_whatsapp))
        if close_btn:
            close_btn.addEventListener("click", create_proxy(close_modal))
        if import_btn:
            import_btn.addEventListener("click", create_proxy(import_chat))

        # Close on overlay click
        overlay.addEventListener("click", create_proxy(lambda e: close_modal() if e.target == overlay else None))

    def import_whatsapp_chat(self, chat_content, filename):
        """Parse WhatsApp chat export and extract progress reports"""
        from js import window
        import re

        if not chat_content:
            window.alert("‚ö†Ô∏è Chat file is empty.")
            return

        # Initialize WhatsApp service if not exists
        if not hasattr(self, 'whatsapp_service'):
            self.whatsapp_service = WhatsAppService()

        # Parse the chat and extract progress reports
        try:
            reports = self.whatsapp_service.parse_chat_export(chat_content)

            if not reports:
                window.alert("‚ö†Ô∏è No progress reports found in the chat.\n\nMake sure the chat contains base64-encoded progress exports sent by students.")
                return

            # Process each report as if it was pasted
            total_processed = 0
            total_submissions = 0

            for report in reports:
                # Extract the base64 data
                base64_data = report.get('data', '')
                phone = report.get('phone', '')
                timestamp = report.get('timestamp', '')

                if base64_data:
                    # Process this export data by simulating paste
                    # We'll add it to the textarea and analyze it
                    try:
                        # Decode and process the export
                        decoded, format_type = self.decode_base64_data(base64_data)
                        if decoded:
                            # Add phone context to the data
                            if phone and 'metadata' in decoded:
                                decoded['metadata']['whatsapp_phone'] = phone
                                decoded['metadata']['whatsapp_timestamp'] = timestamp

                            # Process the submissions
                            submissions = decoded.get('submissions', [])
                            total_submissions += len(submissions)
                            total_processed += 1
                    except Exception as ex:
                        window.console.log(f"Error processing report: {str(ex)}")
                        continue

            # Now analyze all the accumulated data
            textarea = document.querySelector("#pasteProgressData")
            if textarea:
                # Combine all base64 data
                combined_data = "\n\n".join([r.get('data', '') for r in reports if r.get('data')])
                textarea.value = combined_data

                # Trigger analysis
                self.analyze_submissions()

            msg = f"‚úÖ WhatsApp Import Complete!\n\n"
            msg += f"üìä Found {len(reports)} progress report(s)\n"
            msg += f"üìù Total submissions: {total_submissions}\n"
            msg += f"üì± Source: {filename}"

            window.alert(msg)

        except Exception as ex:
            window.alert(f"‚ùå Error importing WhatsApp chat:\n\n{str(ex)}\n\nPlease make sure you exported the chat in text format (.txt)")
            window.console.error(f"WhatsApp import error: {str(ex)}")

    # ============================================================
    # UTILITY: refresh with roster then persist
    # ============================================================
    def refresh_analytics_with_roster(self):
        if self.analytics_data and getattr(self.app, "student_roster", None):
            self.analytics_data = self.merge_roster_data(list(self.analytics_data))
            self.app.analytics_data = self.analytics_data
            self.app.display_manager.display_analytics(self.analytics_data, [])

            import asyncio
            asyncio.ensure_future(self.app.persistence_manager.save_analytics_data())

    # ============================================================
    # REAL-TIME PROGRESS DASHBOARD
    # ============================================================
    def show_real_time_dashboard(self):
        """Display live-updating dashboard of student submission progress"""
        from js import document, window

        # Create dashboard overlay
        overlay = document.createElement("div")
        overlay.id = "realTimeDashboard"
        overlay.style.cssText = """
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 10000;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        """

        # Create dashboard content
        dashboard = document.createElement("div")
        dashboard.style.cssText = """
            background: white;
            border-radius: 16px;
            width: 95%;
            max-width: 1400px;
            height: 90%;
            display: flex;
            flex-direction: column;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        """

        # Header
        header = document.createElement("div")
        header.style.cssText = """
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            color: white;
            padding: 24px 32px;
            border-radius: 16px 16px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        """

        header.innerHTML = """
            <div>
                <h2 style='margin:0;font-size:24px;font-weight:700;'>üìä Real-Time Progress Dashboard</h2>
                <p style='margin:4px 0 0 0;opacity:0.9;font-size:14px;'>Live tracking of student submissions</p>
            </div>
            <button id='closeDashboard' class='btn' style='background:rgba(255,255,255,0.2);color:white;border:1px solid white;padding:10px 20px;border-radius:8px;cursor:pointer;font-weight:600;'>
                ‚úï Close
            </button>
        """

        # Stats bar
        stats_bar = document.createElement("div")
        stats_bar.id = "dashboardStatsBar"
        stats_bar.style.cssText = """
            padding: 20px 32px;
            background: #f8fafc;
            border-bottom: 1px solid #e2e8f0;
        """

        # Table container
        table_container = document.createElement("div")
        table_container.style.cssText = """
            flex: 1;
            overflow-y: auto;
            padding: 32px;
        """

        table_container.innerHTML = """
            <table id='realTimeTable' style='width:100%;border-collapse:collapse;font-size:14px;'>
                <thead style='position:sticky;top:0;background:#f1f5f9;z-index:100;'>
                    <tr>
                        <th style='padding:12px;text-align:left;border-bottom:2px solid #cbd5e1;'>#</th>
                        <th style='padding:12px;text-align:left;border-bottom:2px solid #cbd5e1;'>Student Name</th>
                        <th style='padding:12px;text-align:left;border-bottom:2px solid #cbd5e1;'>Reg No</th>
                        <th style='padding:12px;text-align:center;border-bottom:2px solid #cbd5e1;'>Problems Completed</th>
                        <th style='padding:12px;text-align:center;border-bottom:2px solid #cbd5e1;'>Total Score</th>
                        <th style='padding:12px;text-align:center;border-bottom:2px solid #cbd5e1;'>Last Update</th>
                        <th style='padding:12px;text-align:center;border-bottom:2px solid #cbd5e1;'>Status</th>
                    </tr>
                </thead>
                <tbody id='realTimeTableBody'>
                    <tr>
                        <td colspan='7' style='padding:40px;text-align:center;color:#64748b;'>
                            <div style='font-size:48px;margin-bottom:12px;'>üìä</div>
                            <div style='font-size:16px;'>Waiting for submissions...</div>
                            <div style='font-size:13px;margin-top:8px;'>Data will appear here as students submit their progress</div>
                        </td>
                    </tr>
                </tbody>
            </table>
        """

        # Assemble dashboard
        dashboard.appendChild(header)
        dashboard.appendChild(stats_bar)
        dashboard.appendChild(table_container)
        overlay.appendChild(dashboard)
        document.body.appendChild(overlay)

        # Close button handler
        def close_dashboard(evt):
            overlay.remove()
            # Remove listener
            if hasattr(self, "_realtime_listener"):
                window.removeEventListener("newSubmissionReceived", self._realtime_listener)
                del self._realtime_listener

        close_btn = document.getElementById("closeDashboard")
        if close_btn:
            from pyodide.ffi import create_proxy
            close_btn.addEventListener("click", create_proxy(close_dashboard))

        # Update dashboard with current data
        self.update_real_time_dashboard()

        # Listen for new submissions
        def handle_new_submission(evt):
            window.console.log("üìä Real-time dashboard: New submission received")
            self.update_real_time_dashboard()

        from pyodide.ffi import create_proxy
        self._realtime_listener = create_proxy(handle_new_submission)
        window.addEventListener("newSubmissionReceived", self._realtime_listener)

        window.console.log("‚úÖ Real-time dashboard activated")

    def update_real_time_dashboard(self):
        """Update the real-time dashboard with current data"""
        from js import document, window
        import datetime

        tbody = document.getElementById("realTimeTableBody")
        stats_bar = document.getElementById("dashboardStatsBar")

        if not tbody or not stats_bar:
            return

        # Get current analytics data
        groups = {}
        if self.analytics_data:
            for entry in self.analytics_data:
                phone = entry.get("phone_number", "")
                if phone not in groups:
                    groups[phone] = {
                        "name": entry.get("name", "Unknown"),
                        "reg_no": entry.get("reg_no", "-"),
                        "phone": phone,
                        "problems": [],
                        "total_score": 0,
                        "last_update": None
                    }

                # Add problem data
                problem_num = entry.get("problem", {}).get("number", "?")
                score = entry.get("score", 0)
                timestamp = entry.get("timestamp", "")

                groups[phone]["problems"].append({
                    "number": problem_num,
                    "score": score,
                    "timestamp": timestamp
                })
                groups[phone]["total_score"] += score

                # Track latest timestamp
                if timestamp:
                    if groups[phone]["last_update"] is None or timestamp > groups[phone]["last_update"]:
                        groups[phone]["last_update"] = timestamp

        # Get roster data
        roster = self.app.student_roster if hasattr(self.app, "student_roster") else {}

        # Combine all students (submitted + not submitted)
        all_students = {}

        # Add submitted students
        for phone, data in groups.items():
            all_students[phone] = data

        # Add non-submitted students from roster
        for phone, student in roster.items():
            if phone not in all_students:
                all_students[phone] = {
                    "name": student.get("name", "Unknown"),
                    "reg_no": student.get("reg_no", "-"),
                    "phone": phone,
                    "problems": [],
                    "total_score": 0,
                    "last_update": None
                }

        # Sort by total score (descending)
        sorted_students = sorted(all_students.values(), key=lambda x: x["total_score"], reverse=True)

        # Update stats
        total_students = len(all_students)
        submitted_count = len([s for s in all_students.values() if len(s["problems"]) > 0])
        total_submissions = sum(len(s["problems"]) for s in all_students.values())

        stats_bar.innerHTML = f"""
            <div style='display:flex;gap:24px;flex-wrap:wrap;'>
                <div style='display:flex;align-items:center;gap:8px;'>
                    <div style='width:40px;height:40px;border-radius:8px;background:#dbeafe;display:flex;align-items:center;justify-content:center;font-size:20px;'>üë•</div>
                    <div>
                        <div style='font-size:24px;font-weight:700;color:#1e40af;'>{total_students}</div>
                        <div style='font-size:12px;color:#64748b;'>Total Students</div>
                    </div>
                </div>
                <div style='display:flex;align-items:center;gap:8px;'>
                    <div style='width:40px;height:40px;border-radius:8px;background:#dcfce7;display:flex;align-items:center;justify-content:center;font-size:20px;'>‚úÖ</div>
                    <div>
                        <div style='font-size:24px;font-weight:700;color:#16a34a;'>{submitted_count}</div>
                        <div style='font-size:12px;color:#64748b;'>Submitted</div>
                    </div>
                </div>
                <div style='display:flex;align-items:center;gap:8px;'>
                    <div style='width:40px;height:40px;border-radius:8px;background:#fef3c7;display:flex;align-items:center;justify-content:center;font-size:20px;'>üìù</div>
                    <div>
                        <div style='font-size:24px;font-weight:700;color:#ca8a04;'>{total_submissions}</div>
                        <div style='font-size:12px;color:#64748b;'>Total Submissions</div>
                    </div>
                </div>
                <div style='display:flex;align-items:center;gap:8px;margin-left:auto;'>
                    <div style='width:12px;height:12px;border-radius:50%;background:#10b981;animation:pulse 2s infinite;'></div>
                    <div style='font-size:13px;color:#059669;font-weight:600;'>LIVE</div>
                </div>
            </div>
        """

        # Update table
        rows_html = ""
        for idx, student in enumerate(sorted_students, 1):
            problems_count = len(student["problems"])
            total_score = student["total_score"]

            # Format last update time
            last_update_str = "-"
            if student["last_update"]:
                try:
                    last_update_str = student["last_update"][:19].replace("T", " ")
                except:
                    last_update_str = str(student["last_update"])

            # Status
            if problems_count == 0:
                status = "<span style='color:#ef4444;font-weight:600;'>‚è≥ Not Started</span>"
                row_bg = "#fef2f2"
            elif problems_count > 0:
                status = "<span style='color:#10b981;font-weight:600;'>‚úÖ Active</span>"
                row_bg = "#f0fdf4"

            rows_html += f"""
                <tr style='background:{row_bg};border-bottom:1px solid #e2e8f0;'>
                    <td style='padding:12px;font-weight:600;color:#64748b;'>{idx}</td>
                    <td style='padding:12px;font-weight:600;'>{student["name"]}</td>
                    <td style='padding:12px;color:#64748b;'>{student["reg_no"]}</td>
                    <td style='padding:12px;text-align:center;font-weight:700;color:#3b82f6;'>{problems_count}</td>
                    <td style='padding:12px;text-align:center;font-weight:700;color:#16a34a;font-size:16px;'>{total_score}</td>
                    <td style='padding:12px;text-align:center;color:#64748b;font-size:12px;'>{last_update_str}</td>
                    <td style='padding:12px;text-align:center;'>{status}</td>
                </tr>
            """

        tbody.innerHTML = rows_html if rows_html else """
            <tr>
                <td colspan='7' style='padding:40px;text-align:center;color:#64748b;'>
                    <div style='font-size:48px;margin-bottom:12px;'>üì≠</div>
                    <div style='font-size:16px;'>No data available</div>
                </td>
            </tr>
        """

        # Add pulse animation
        style = document.getElementById("realtimePulseStyle")
        if not style:
            style = document.createElement("style")
            style.id = "realtimePulseStyle"
            style.textContent = """
                @keyframes pulse {
                    0%, 100% { opacity: 1; }
                    50% { opacity: 0.5; }
                }
            """
            document.head.appendChild(style)

    # ============================================================
    # TIMED-QUIZ LEADERBOARD MODE
    # ============================================================
    def show_timed_quiz_mode(self):
        """Display timed-quiz mode with leaderboard and time-based problem sets"""
        from js import document, window

        # Create overlay
        overlay = document.createElement("div")
        overlay.id = "timedQuizOverlay"
        overlay.style.cssText = """
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 10000;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        """

        # Create leaderboard
        leaderboard = document.createElement("div")
        leaderboard.style.cssText = """
            background: white;
            border-radius: 16px;
            width: 95%;
            max-width: 1200px;
            height: 90%;
            display: flex;
            flex-direction: column;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
        """

        # Header
        header = document.createElement("div")
        header.style.cssText = """
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
            padding: 24px 32px;
            border-radius: 16px 16px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        """

        header.innerHTML = """
            <div>
                <h2 style='margin:0;font-size:28px;font-weight:700;'>üèÜ Live Leaderboard</h2>
                <p style='margin:4px 0 0 0;opacity:0.9;font-size:14px;'>Timed-Quiz Mode - Rankings update in real-time</p>
            </div>
            <button id='closeLeaderboard' class='btn' style='background:rgba(255,255,255,0.2);color:white;border:1px solid white;padding:10px 20px;border-radius:8px;cursor:pointer;font-weight:600;'>
                ‚úï Close
            </button>
        """

        # Timer display
        timer_bar = document.createElement("div")
        timer_bar.id = "timerBar"
        timer_bar.style.cssText = """
            padding: 16px 32px;
            background: #fffbeb;
            border-bottom: 2px solid #fbbf24;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 16px;
        """
        timer_bar.innerHTML = """
            <div style='font-size:16px;font-weight:600;color:#92400e;'>‚è∞ Quiz Time:</div>
            <div id='quizTimer' style='font-size:24px;font-weight:700;color:#b45309;font-family:monospace;'>00:00:00</div>
        """

        # Leaderboard table container
        table_container = document.createElement("div")
        table_container.style.cssText = """
            flex: 1;
            overflow-y: auto;
            padding: 32px;
        """

        table_container.innerHTML = """
            <table id='leaderboardTable' style='width:100%;border-collapse:collapse;font-size:14px;'>
                <thead style='position:sticky;top:0;background:#fef3c7;z-index:100;'>
                    <tr>
                        <th style='padding:16px;text-align:center;border-bottom:3px solid #f59e0b;font-size:16px;'>Rank</th>
                        <th style='padding:16px;text-align:left;border-bottom:3px solid #f59e0b;font-size:16px;'>Student</th>
                        <th style='padding:16px;text-align:center;border-bottom:3px solid #f59e0b;font-size:16px;'>Score</th>
                        <th style='padding:16px;text-align:center;border-bottom:3px solid #f59e0b;font-size:16px;'>Correct Answers</th>
                        <th style='padding:16px;text-align:center;border-bottom:3px solid #f59e0b;font-size:16px;'>Last Submission</th>
                        <th style='padding:16px;text-align:center;border-bottom:3px solid #f59e0b;font-size:16px;'>Status</th>
                    </tr>
                </thead>
                <tbody id='leaderboardTableBody'>
                    <tr>
                        <td colspan='6' style='padding:60px;text-align:center;color:#64748b;'>
                            <div style='font-size:64px;margin-bottom:16px;'>üèÜ</div>
                            <div style='font-size:18px;font-weight:600;'>Leaderboard Loading...</div>
                            <div style='font-size:14px;margin-top:8px;'>Rankings will appear as students submit answers</div>
                        </td>
                    </tr>
                </tbody>
            </table>
        """

        # Assemble
        leaderboard.appendChild(header)
        leaderboard.appendChild(timer_bar)
        leaderboard.appendChild(table_container)
        overlay.appendChild(leaderboard)
        document.body.appendChild(overlay)

        # Close button handler
        def close_leaderboard(evt):
            overlay.remove()
            # Stop timer
            if hasattr(self, "_quiz_timer_interval"):
                window.clearInterval(self._quiz_timer_interval)
                del self._quiz_timer_interval
            # Remove listener
            if hasattr(self, "_quiz_listener"):
                window.removeEventListener("newSubmissionReceived", self._quiz_listener)
                del self._quiz_listener

        close_btn = document.getElementById("closeLeaderboard")
        if close_btn:
            from pyodide.ffi import create_proxy
            close_btn.addEventListener("click", create_proxy(close_leaderboard))

        # Start timer
        self.quiz_start_time = window.Date.now()

        def update_timer():
            from js import document, window
            timer_elem = document.getElementById("quizTimer")
            if timer_elem:
                elapsed = int((window.Date.now() - self.quiz_start_time) / 1000)
                hours = elapsed // 3600
                minutes = (elapsed % 3600) // 60
                seconds = elapsed % 60
                timer_elem.textContent = f"{hours:02d}:{minutes:02d}:{seconds:02d}"

        from pyodide.ffi import create_proxy
        self._quiz_timer_interval = window.setInterval(create_proxy(update_timer), 1000)

        # Update leaderboard with current data
        self.update_leaderboard()

        # Listen for new submissions
        def handle_quiz_submission(evt):
            window.console.log("üèÜ Leaderboard: New submission received")
            self.update_leaderboard()

        self._quiz_listener = create_proxy(handle_quiz_submission)
        window.addEventListener("newSubmissionReceived", self._quiz_listener)

        # Create floating WhatsApp button
        self.create_floating_whatsapp_button()

        window.console.log("‚úÖ Timed-quiz leaderboard activated")

    def update_leaderboard(self):
        """Update leaderboard with current rankings"""
        from js import document, window

        tbody = document.getElementById("leaderboardTableBody")
        if not tbody:
            return

        # Calculate student rankings
        rankings = {}

        if self.analytics_data:
            for entry in self.analytics_data:
                phone = entry.get("phone_number", "")
                if phone not in rankings:
                    rankings[phone] = {
                        "name": entry.get("name", "Unknown"),
                        "reg_no": entry.get("reg_no", "-"),
                        "phone": phone,
                        "score": 0,
                        "correct_count": 0,
                        "total_submissions": 0,
                        "last_timestamp": None
                    }

                # Count correct answers
                score = entry.get("score", 0)
                rankings[phone]["score"] += score

                steps = entry.get("steps_progress", []) or []
                for step in steps:
                    if isinstance(step, dict):
                        attempts = step.get("attempts", []) or []
                        for att in attempts:
                            if isinstance(att, dict):
                                rankings[phone]["total_submissions"] += 1
                                if att.get("correct", False):
                                    rankings[phone]["correct_count"] += 1

                # Track last submission time
                timestamp = entry.get("timestamp", "")
                if timestamp:
                    if rankings[phone]["last_timestamp"] is None or timestamp > rankings[phone]["last_timestamp"]:
                        rankings[phone]["last_timestamp"] = timestamp

        # Get roster
        roster = self.app.student_roster if hasattr(self.app, "student_roster") else {}

        # Add non-submitted students
        for phone, student in roster.items():
            if phone not in rankings:
                rankings[phone] = {
                    "name": student.get("name", "Unknown"),
                    "reg_no": student.get("reg_no", "-"),
                    "phone": phone,
                    "score": 0,
                    "correct_count": 0,
                    "total_submissions": 0,
                    "last_timestamp": None
                }

        # Sort by score (descending), then by correct count, then by timestamp (earlier = better)
        sorted_rankings = sorted(
            rankings.values(),
            key=lambda x: (x["score"], x["correct_count"], -(window.Date.parse(x["last_timestamp"]) if x["last_timestamp"] else 9999999999999)),
            reverse=True
        )

        # Generate leaderboard HTML
        rows_html = ""
        for rank, student in enumerate(sorted_rankings, 1):
            # Medal for top 3
            if rank == 1:
                rank_display = "ü•á"
                row_bg = "#fef9c3"
                rank_color = "#854d0e"
            elif rank == 2:
                rank_display = "ü•à"
                row_bg = "#f1f5f9"
                rank_color = "#475569"
            elif rank == 3:
                rank_display = "ü•â"
                row_bg = "#fef2f2"
                rank_color = "#991b1b"
            else:
                rank_display = str(rank)
                row_bg = "white"
                rank_color = "#64748b"

            # Status
            if student["total_submissions"] == 0:
                status = "<span style='color:#ef4444;'>‚ùå No Submissions</span>"
            else:
                accuracy = (student["correct_count"] / student["total_submissions"] * 100) if student["total_submissions"] > 0 else 0
                status = f"<span style='color:#10b981;'>‚úÖ {accuracy:.0f}% Accuracy</span>"

            # Last submission time
            last_sub_str = "-"
            if student["last_timestamp"]:
                try:
                    last_sub_str = student["last_timestamp"][:19].replace("T", " ")
                except:
                    last_sub_str = str(student["last_timestamp"])

            rows_html += f"""
                <tr style='background:{row_bg};border-bottom:1px solid #e2e8f0;transition:all 0.3s;'>
                    <td style='padding:16px;text-align:center;font-size:24px;font-weight:700;color:{rank_color};'>{rank_display}</td>
                    <td style='padding:16px;'>
                        <div style='font-weight:700;font-size:15px;'>{student["name"]}</div>
                        <div style='font-size:12px;color:#64748b;margin-top:2px;'>{student["reg_no"]}</div>
                    </td>
                    <td style='padding:16px;text-align:center;font-size:20px;font-weight:700;color:#16a34a;'>{student["score"]}</td>
                    <td style='padding:16px;text-align:center;font-weight:600;color:#3b82f6;'>{student["correct_count"]}</td>
                    <td style='padding:16px;text-align:center;font-size:12px;color:#64748b;'>{last_sub_str}</td>
                    <td style='padding:16px;text-align:center;'>{status}</td>
                </tr>
            """

        tbody.innerHTML = rows_html if rows_html else """
            <tr>
                <td colspan='6' style='padding:60px;text-align:center;color:#64748b;'>
                    <div style='font-size:64px;margin-bottom:16px;'>üì≠</div>
                    <div style='font-size:18px;'>No submissions yet</div>
                </td>
            </tr>
        """

    def create_floating_whatsapp_button(self):
        """Create floating share button for quick submission via WhatsApp or Telegram"""
        from js import document, window

        # Check if button already exists
        if document.getElementById("floatingShareBtn"):
            return

        # Create floating + button
        btn = document.createElement("button")
        btn.id = "floatingShareBtn"
        btn.innerHTML = """
            <div style='font-size:36px;font-weight:300;'>+</div>
        """
        btn.style.cssText = """
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            color: white;
            border: none;
            cursor: pointer;
            box-shadow: 0 4px 20px rgba(59,130,246,0.4);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        """

        # Create popup menu (initially hidden)
        menu = document.createElement("div")
        menu.id = "sharePopupMenu"
        menu.style.cssText = """
            position: fixed;
            bottom: 100px;
            right: 30px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            z-index: 9998;
            display: none;
            flex-direction: column;
            padding: 12px;
            gap: 8px;
            min-width: 200px;
        """

        # WhatsApp option (using SVG from Wikipedia)
        whatsapp_option = document.createElement("button")
        whatsapp_option.innerHTML = """
            <svg style='width:24px;height:24px;' viewBox="0 0 24 24" fill="#25D366">
                <path d="M17.472 14.382c-.297-.149-1.758-.867-2.03-.967-.273-.099-.471-.148-.67.15-.197.297-.767.966-.94 1.164-.173.199-.347.223-.644.075-.297-.15-1.255-.463-2.39-1.475-.883-.788-1.48-1.761-1.653-2.059-.173-.297-.018-.458.13-.606.134-.133.298-.347.446-.52.149-.174.198-.298.298-.497.099-.198.05-.371-.025-.52-.075-.149-.669-1.612-.916-2.207-.242-.579-.487-.5-.669-.51-.173-.008-.371-.01-.57-.01-.198 0-.52.074-.792.372-.272.297-1.04 1.016-1.04 2.479 0 1.462 1.065 2.875 1.213 3.074.149.198 2.096 3.2 5.077 4.487.709.306 1.262.489 1.694.625.712.227 1.36.195 1.871.118.571-.085 1.758-.719 2.006-1.413.248-.694.248-1.289.173-1.413-.074-.124-.272-.198-.57-.347m-5.421 7.403h-.004a9.87 9.87 0 01-5.031-1.378l-.361-.214-3.741.982.998-3.648-.235-.374a9.86 9.86 0 01-1.51-5.26c.001-5.45 4.436-9.884 9.888-9.884 2.64 0 5.122 1.03 6.988 2.898a9.825 9.825 0 012.893 6.994c-.003 5.45-4.437 9.884-9.885 9.884m8.413-18.297A11.815 11.815 0 0012.05 0C5.495 0 .16 5.335.157 11.892c0 2.096.547 4.142 1.588 5.945L.057 24l6.305-1.654a11.882 11.882 0 005.683 1.448h.005c6.554 0 11.89-5.335 11.893-11.893a11.821 11.821 0 00-3.48-8.413Z"/>
            </svg>
            <span style='margin-left:12px;font-weight:600;color:#25D366;'>WhatsApp</span>
        """
        whatsapp_option.style.cssText = """
            display: flex;
            align-items: center;
            padding: 12px 16px;
            border: none;
            background: #f0fdf4;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
        """

        # Telegram option (using SVG from Wikipedia)
        telegram_option = document.createElement("button")
        telegram_option.innerHTML = """
            <svg style='width:24px;height:24px;' viewBox="0 0 24 24" fill="#0088cc">
                <path d="M11.944 0A12 12 0 0 0 0 12a12 12 0 0 0 12 12 12 12 0 0 0 12-12A12 12 0 0 0 12 0a12 12 0 0 0-.056 0zm4.962 7.224c.1-.002.321.023.465.14a.506.506 0 0 1 .171.325c.016.093.036.306.02.472-.18 1.898-.962 6.502-1.36 8.627-.168.9-.499 1.201-.82 1.23-.696.065-1.225-.46-1.9-.902-1.056-.693-1.653-1.124-2.678-1.8-1.185-.78-.417-1.21.258-1.91.177-.184 3.247-2.977 3.307-3.23.007-.032.014-.15-.056-.212s-.174-.041-.249-.024c-.106.024-1.793 1.14-5.061 3.345-.48.33-.913.49-1.302.48-.428-.008-1.252-.241-1.865-.44-.752-.245-1.349-.374-1.297-.789.027-.216.325-.437.893-.663 3.498-1.524 5.83-2.529 6.998-3.014 3.332-1.386 4.025-1.627 4.476-1.635z"/>
            </svg>
            <span style='margin-left:12px;font-weight:600;color:#0088cc;'>Telegram</span>
        """
        telegram_option.style.cssText = """
            display: flex;
            align-items: center;
            padding: 12px 16px;
            border: none;
            background: #eff6ff;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
        """

        menu.appendChild(whatsapp_option)
        menu.appendChild(telegram_option)

        # Hover effects for options
        def whatsapp_hover(evt):
            whatsapp_option.style.background = "#dcfce7"
            whatsapp_option.style.transform = "scale(1.02)"

        def whatsapp_leave(evt):
            whatsapp_option.style.background = "#f0fdf4"
            whatsapp_option.style.transform = "scale(1)"

        def telegram_hover(evt):
            telegram_option.style.background = "#dbeafe"
            telegram_option.style.transform = "scale(1.02)"

        def telegram_leave(evt):
            telegram_option.style.background = "#eff6ff"
            telegram_option.style.transform = "scale(1)"

        # Hover effect for main button
        def btn_hover(evt):
            btn.style.transform = "scale(1.1) rotate(90deg)"
            btn.style.boxShadow = "0 6px 30px rgba(59,130,246,0.6)"

        def btn_leave(evt):
            btn.style.transform = "scale(1)"
            btn.style.boxShadow = "0 4px 20px rgba(59,130,246,0.4)"

        # Toggle menu on button click
        def toggle_menu(evt):
            if menu.style.display == "none" or menu.style.display == "":
                menu.style.display = "flex"
                btn.innerHTML = "<div style='font-size:36px;font-weight:300;transform:rotate(45deg);'>+</div>"
            else:
                menu.style.display = "none"
                btn.innerHTML = "<div style='font-size:36px;font-weight:300;'>+</div>"

        # Get or prompt for user info
        def get_user_info():
            teacher_name = getattr(self, 'teacher_name', None)
            student_name = getattr(self, 'student_name', None)

            if not teacher_name or not student_name:
                teacher_name = window.prompt(
                    "Enter teacher's name:",
                    getattr(self, 'teacher_name', "")
                )
                if not teacher_name:
                    return None, None

                student_name = window.prompt(
                    "Enter your name (student):",
                    getattr(self, 'student_name', "")
                )
                if not student_name:
                    return None, None

                # Save for session
                self.teacher_name = teacher_name
                self.student_name = student_name
                window.console.log(f"‚úÖ Names saved - Teacher: {teacher_name}, Student: {student_name}")

            return teacher_name, student_name

        # Get progress data as base64
        def get_progress_data():
            # Get current progress from textarea or analytics data
            from js import document
            textarea = document.getElementById("pasteProgressData")
            if textarea and textarea.value:
                return textarea.value.strip()
            return ""

        # Segment message for platform limits
        def segment_message(message, max_length):
            """Split message into chunks respecting max length"""
            if len(message) <= max_length:
                return [message]

            segments = []
            current = ""
            lines = message.split('\n')

            for line in lines:
                if len(current) + len(line) + 1 <= max_length:
                    current += line + '\n'
                else:
                    if current:
                        segments.append(current.strip())
                    # If single line is too long, split it
                    if len(line) > max_length:
                        for i in range(0, len(line), max_length):
                            segments.append(line[i:i+max_length])
                        current = ""
                    else:
                        current = line + '\n'

            if current:
                segments.append(current.strip())

            return segments

        # WhatsApp handler
        def send_via_whatsapp(evt):
            menu.style.display = "none"
            btn.innerHTML = "<div style='font-size:36px;font-weight:300;'>+</div>"

            teacher_name, student_name = get_user_info()
            if not teacher_name or not student_name:
                return

            # Get teacher WhatsApp number
            teacher_number = getattr(self, 'teacher_whatsapp_number', None)
            if not teacher_number:
                teacher_number = window.prompt(
                    "Enter teacher's WhatsApp number (include country code):",
                    "+62"
                )
                if teacher_number:
                    teacher_number = teacher_number.replace("+", "").replace("-", "").replace(" ", "")
                    self.teacher_whatsapp_number = teacher_number
                else:
                    return

            # Get progress data
            progress_data = get_progress_data()

            # Create message
            header = f"üéì Progress Report\n\nTo: {teacher_name}\nFrom: {student_name}\n\n"
            footer = "\n\n---\nSent via Analytics App"

            # WhatsApp limit is ~4096 chars, but we use 3500 to be safe
            MAX_LENGTH = 3500

            if progress_data:
                full_message = header + progress_data + footer
                segments = segment_message(full_message, MAX_LENGTH)

                # Send first segment
                first_msg = segments[0]
                if len(segments) > 1:
                    first_msg += f"\n\n[Part 1/{len(segments)}]"

                url = f"https://wa.me/{teacher_number}?text={window.encodeURIComponent(first_msg)}"
                window.open(url, "_blank")

                # Notify about additional segments
                if len(segments) > 1:
                    window.alert(f"‚úÖ Message is long! It has been split into {len(segments)} parts.\n\nPart 1 is opening now. Please copy and send the remaining parts:\n\n" +
                               "\n\n---NEXT PART---\n\n".join(segments[1:]))
            else:
                message = header + "[No progress data available yet]" + footer
                url = f"https://wa.me/{teacher_number}?text={window.encodeURIComponent(message)}"
                window.open(url, "_blank")

            window.console.log(f"üì± WhatsApp opened for {teacher_name}")

        # Telegram handler
        def send_via_telegram(evt):
            menu.style.display = "none"
            btn.innerHTML = "<div style='font-size:36px;font-weight:300;'>+</div>"

            teacher_name, student_name = get_user_info()
            if not teacher_name or not student_name:
                return

            # Get student phone number for Telegram (required since Telegram doesn't show sender's number)
            student_phone = getattr(self, 'student_phone_number', None)
            if not student_phone:
                student_phone = window.prompt(
                    "Enter your phone number (with country code, e.g., +6281234567890):",
                    "+62"
                )
                if student_phone:
                    self.student_phone_number = student_phone
                else:
                    return

            # Get teacher Telegram username
            teacher_username = getattr(self, 'teacher_telegram_username', None)
            if not teacher_username:
                teacher_username = window.prompt(
                    "Enter teacher's Telegram username (without @):",
                    ""
                )
                if teacher_username:
                    teacher_username = teacher_username.replace("@", "")
                    self.teacher_telegram_username = teacher_username
                else:
                    return

            # Get progress data
            progress_data = get_progress_data()

            # Create message with student phone number
            header = f"üéì Progress Report\n\nTo: {teacher_name}\nFrom: {student_name}\nPhone: {student_phone}\n\n"
            footer = "\n\n---\nSent via Analytics App"

            # Telegram limit is 4096 characters
            MAX_LENGTH = 4000

            if progress_data:
                full_message = header + progress_data + footer
                segments = segment_message(full_message, MAX_LENGTH)

                # Send first segment
                first_msg = segments[0]
                if len(segments) > 1:
                    first_msg += f"\n\n[Part 1/{len(segments)}]"

                url = f"https://t.me/{teacher_username}?text={window.encodeURIComponent(first_msg)}"
                window.open(url, "_blank")

                # Notify about additional segments
                if len(segments) > 1:
                    window.alert(f"‚úÖ Message is long! It has been split into {len(segments)} parts.\n\nPart 1 is opening now. Please copy and send the remaining parts:\n\n" +
                               "\n\n---NEXT PART---\n\n".join(segments[1:]))
            else:
                message = header + "[No progress data available yet]" + footer
                url = f"https://t.me/{teacher_username}?text={window.encodeURIComponent(message)}"
                window.open(url, "_blank")

            window.console.log(f"‚úàÔ∏è Telegram opened for {teacher_name} (from {student_phone})")

        # Bind events
        from pyodide.ffi import create_proxy
        btn.addEventListener("mouseenter", create_proxy(btn_hover))
        btn.addEventListener("mouseleave", create_proxy(btn_leave))
        btn.addEventListener("click", create_proxy(toggle_menu))

        whatsapp_option.addEventListener("mouseenter", create_proxy(whatsapp_hover))
        whatsapp_option.addEventListener("mouseleave", create_proxy(whatsapp_leave))
        whatsapp_option.addEventListener("click", create_proxy(send_via_whatsapp))

        telegram_option.addEventListener("mouseenter", create_proxy(telegram_hover))
        telegram_option.addEventListener("mouseleave", create_proxy(telegram_leave))
        telegram_option.addEventListener("click", create_proxy(send_via_telegram))

        # Add to page
        document.body.appendChild(btn)
        document.body.appendChild(menu)

        window.console.log("‚úÖ Floating share button created with WhatsApp and Telegram support")

class DisplayManager:
    def display_cheating_panel(self, cheating_groups, results):
        """Display cheating detection results"""
        if not cheating_groups:
            return

        panel = document.createElement("div")
        panel.className = "panel"
        panel.style.background = "#fef2f2"
        panel.style.border = "2px solid #dc2626"

        panel.innerHTML = f"""
            <h3 style='margin-top:0;color:#dc2626;'>üö® Cheating Detection Results</h3>
            <div style='margin-bottom:16px;color:#991b1b;font-weight:600;'>
                Found {len(cheating_groups)} group(s) with identical submissions from different students:
            </div>
        """

        for group in cheating_groups:
            group_div = document.createElement("div")
            group_div.style.cssText = "background:#fff;border:1px solid #dc2626;border-radius:8px;padding:12px;margin-bottom:12px;"

            students_html = ""
            for student in group["students"]:
                students_html += f"""
                    <div style='padding:6px;border-bottom:1px solid #e5e7eb;'>
                        <strong>{html.escape(student['name'])}</strong> - {html.escape(student['reg_no'])} - {html.escape(student['phone'])}
                        <div style='font-size:12px;color:#6b7280;'>Export ID: {student['export_id'][:16]}...</div>
                    </div>
                """

            problems_list = "<br>".join(f"‚Ä¢ {html.escape(p)}" for p in group["problems"])

            group_div.innerHTML = f"""
                <div style='font-weight:700;color:#dc2626;margin-bottom:8px;'>
                    Group #{group['group_number']} - {group['count']} students with identical content
                </div>
                <div style='margin-bottom:8px;'>
                    <strong>Problems:</strong><br>{problems_list}
                </div>
                <div style='margin-bottom:8px;'>
                    <strong>Content Hash:</strong> <code>{group['hash']}</code>
                </div>
                <div style='background:#f9fafb;border-radius:6px;padding:8px;'>
                    <strong>Students involved:</strong>
                    {students_html}
                </div>
            """

            panel.appendChild(group_div)

        results.appendChild(panel)

    def __init__(self):
        self.app = None
        self.debug_mode = False
        self.cheating_groups = []
        self.current_sort = {"column": "name", "direction": "asc"}
        self.status_sort = {"column": "reg", "direction": "asc"}

    # =====================================================
    # INITIALIZE
    # =====================================================
    def initialize(self):
        pass

    # =====================================================
    # MAIN DISPLAY ENTRY
    # =====================================================
    def display_analytics(self, submissions, invalid):
        results = document.querySelector("#analyticsResults")
        if not results:
            return
        results.innerHTML = ""

        # Run duplicate detection first to get ignored list
        self.cheating_groups = self.app.progress_analyzer.detect_cheating(submissions)
        self.ignored_list = getattr(self.app.progress_analyzer, "ignored_duplicates", [])

        # Filter out ignored duplicates from submissions (now works at problem level)
        ignored_submission_keys = set()
        for ignored in self.ignored_list:
            key = f"{ignored.get('export_id', '')}_{ignored.get('problem_number', 0)}"
            ignored_submission_keys.add(key)

        # Filter submissions to exclude ignored duplicates
        filtered_submissions = []
        for sub in submissions:
            key = f"{sub.get('export_id', '')}_{sub.get('problem', {}).get('number', 0)}"
            if key not in ignored_submission_keys:
                filtered_submissions.append(sub)

        window.console.log(f"Original submissions: {len(submissions)}, After filtering problem-level duplicates: {len(filtered_submissions)}")

        # Use filtered submissions for all processing
        groups = self.group_by_student(filtered_submissions)
        self.invalid_list = invalid or []

        cheating_phones = set()
        phone_to_cheat_group = {}
        for group in self.cheating_groups:
            for student in group["students"]:
                cheating_phones.add(student["phone"])
                phone_to_cheat_group[student["phone"]] = group["group_number"]

        # Use filtered_submissions for summary and tables
        summary_panel = self.create_summary_panel(groups, filtered_submissions)
        results.appendChild(summary_panel)

        if self.cheating_groups:
            self.display_cheating_panel(self.cheating_groups, results)

        table_panel = self.create_student_table(groups, filtered_submissions, cheating_phones)
        results.appendChild(table_panel)

        status_panel = self.create_status_table(groups, cheating_phones, phone_to_cheat_group)
        results.appendChild(status_panel)

        if invalid:
            invalid_panel = self.create_invalid_panel(invalid)
            results.appendChild(invalid_panel)

        self.attach_table_event_handlers()

        try:
            if hasattr(window, "MathJax"):
                window.MathJax.typesetPromise()
        except:
            pass

    # =====================================================
    # SUMMARY PANEL
    # =====================================================
    def create_summary_panel(self, groups, submissions):
        panel = document.createElement("div")
        panel.className = "panel"

        total_students = len(self.app.student_roster) if self.app.student_roster else 0
        submitted = len(groups)
        matched = sum(1 for phone in groups.keys() if phone in self.app.student_roster)
        cheating = sum(g["count"] for g in self.cheating_groups if g["count"] > 1)
        invalid = len(self.invalid_list) if hasattr(self, "invalid_list") else 0
        ignored = len(self.ignored_list) if hasattr(self, "ignored_list") else 0

        panel.innerHTML = f"""
            <h3 style='margin-top:0;'>üìä Summary</h3>
            <div class='stats-grid'>
                <div class='stats-card' style='background:#e0f2fe;'>
                    <div class='stats-number'>{total_students}</div>
                    <div class='stats-label'>Total Students</div>
                </div>
                <div class='stats-card' style='background:#fef3c7;'>
                    <div class='stats-number'>{submitted}</div>
                    <div class='stats-label'>Unique Submissions</div>
                </div>
                <div class='stats-card' style='background:#dcfce7;'>
                    <div class='stats-number'>{matched}</div>
                    <div class='stats-label'>Matched</div>
                </div>
                <div class='stats-card' style='background:#fee2e2;'>
                    <div class='stats-number'>{cheating}</div>
                    <div class='stats-label'>Cheating</div>
                </div>
                <div class='stats-card' style='background:#fef2f2;'>
                    <div class='stats-number'>{invalid}</div>
                    <div class='stats-label'>Invalid</div>
                </div>
                <div class='stats-card' style='background:#f3f4f6;'>
                    <div class='stats-number'>{ignored}</div>
                    <div class='stats-label'>Duplicates Filtered</div>
                </div>
            </div>
        """
        return panel

    # =====================================================
    # STUDENT TABLE
    # =====================================================
    def create_student_table(self, groups, submissions, cheating_phones):
        panel = document.createElement("div")
        panel.className = "panel"

        # Get sort indicators
        def get_sort_indicator(col):
            if self.current_sort["column"] == col:
                return "‚ñº" if self.current_sort["direction"] == "desc" else "‚ñ≤"
            return ""

        panel.innerHTML = f"""
            <div style='display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;'>
                <h3 style='margin:0;'>üè´ Student Progress</h3>
                <button id='collapseAllBtn' class='btn' style='background:#64748b; font-size:13px; padding:6px 12px;'>üîΩ Collapse All</button>
            </div>
            <div style='overflow-x:auto;'>
            <table id='scoreTable' style='width:100%;border-collapse:collapse;font-size:13px;'>
                <thead>
                    <tr style='background:#f3f4f6;'>
                        <th>#</th>
                        <th class='sortable-header' data-column='name' style='cursor:pointer;user-select:none;' title='Click to sort'>Name {get_sort_indicator('name')}</th>
                        <th class='sortable-header' data-column='reg' style='cursor:pointer;user-select:none;' title='Click to sort'>Reg No {get_sort_indicator('reg')}</th>
                        <th class='sortable-header' data-column='score' style='cursor:pointer;user-select:none;' title='Click to sort'>Score {get_sort_indicator('score')}</th>
                        <th>Phone</th>
                        <th>Details</th>
                    </tr>
                </thead>
                <tbody id='scoreTableBody'></tbody>
            </table>
            </div>
        """
        tbody = panel.querySelector("#scoreTableBody")
        student_data = []

        for phone, subs in groups.items():
            name = subs[0].get("student_name", "Unknown")
            reg = subs[0].get("registration_number", "")
            if name == "Unknown" and phone in self.app.student_roster:
                name = self.app.student_roster[phone].get("name", "Unknown")
                reg = self.app.student_roster[phone].get("registration_number", "")
            is_cheating = phone in cheating_phones
            score = -1 if is_cheating else self.app.progress_analyzer.calculate_student_score(subs)
            student_data.append({
                "phone": phone, "name": name, "reg": reg,
                "score": score, "is_cheating": is_cheating, "subs": subs
            })

        # Store data for re-sorting
        self.student_table_data = student_data

        sorted_data = self.sort_student_data(student_data)

        for idx, student in enumerate(sorted_data, 1):
            score_display = "‚Äî" if student["is_cheating"] else f"{student['score']}%"
            cls = "score-low" if student["is_cheating"] else self.app.progress_analyzer.get_score_class(student["score"])
            tr = document.createElement("tr")
            tr.innerHTML = f"""
                <td>{idx}</td>
                <td>{html.escape(student['name'])}</td>
                <td>{html.escape(str(student['reg']))}</td>
                <td style='text-align:center;'><span class='score-badge {cls}'>{score_display}</span></td>
                <td>{html.escape(student['phone'])}</td>
                <td><button class='detail-toggle' data-phone='{html.escape(student['phone'])}'>üîΩ Details</button></td>
            """
            tbody.appendChild(tr)
            tbody.appendChild(self.create_detail_row(student["subs"]))
        return panel

    # =====================================================
    # DETAIL ROW
    # =====================================================
    def create_detail_row(self, submissions):
        tr = document.createElement("tr")
        tr.className = "detail-row"
        tr.style.display = "none"
        td = document.createElement("td")
        td.colSpan = 6

        html_content = "<div style='padding:12px;background:#f8fafc;'>"
        for s in submissions:
            problem = s.get("problem", {})
            title = problem.get("title", "")
            steps = s.get("steps_progress", [])
            summary = s.get("summary", {})
            total = summary.get("total_steps", len(steps))
            finalized = summary.get("finalized_steps", 0)
            html_content += f"""
            <div class='problem-card'>
                <div class='problem-header'>
                    <strong>Problem {problem.get('number', '?')}: {html.escape(title)}</strong>
                    <span class='badge'>Steps: {finalized}/{total}</span>
                </div>
                <div class='problem-body' style='display:none;'>
                    {self.create_steps_table_html(steps)}
                </div>
            </div>
            """
        html_content += "</div>"
        td.innerHTML = html_content
        tr.appendChild(td)
        try:
            if hasattr(window, "MathJax"):
                window.MathJax.typesetPromise([td])
        except:
            pass
        return tr

    # =====================================================
    # STEP TABLE (Flags)
    # =====================================================
    def create_steps_table_html(self, steps):
        """Enhanced step display with finalize attempts"""
        html_content = """
        <table style='width:100%;border-collapse:collapse;font-size:13px;'>
            <thead>
                <tr style='background:#fafafa;'>
                    <th style='padding:6px;text-align:left;'>Step</th>
                    <th style='padding:6px;text-align:center;'>Status</th>
                    <th style='padding:6px;text-align:left;'>Attempts</th>
                </tr>
            </thead>
            <tbody>
        """

        for step in steps:
            step_no = step.get("step_number", "?")
            finalized = step.get("finalized", False)
            correct = step.get("correct", False)
            structure_correct = step.get("structure_correct", False)

            # Status badge
            if finalized and structure_correct:
                status = "<span style='color:#059669;font-weight:600;'>‚úÖ Finalized</span>"
            elif correct:
                status = "<span style='color:#d97706;font-weight:600;'>‚ö†Ô∏è Correct but not finalized</span>"
            else:
                status = "<span style='color:#dc2626;font-weight:600;'>‚ùå Incomplete</span>"

            # Attempts display
            attempts_html = "<div style='display:flex;flex-wrap:wrap;gap:8px;align-items:center;'>"
            for att in step.get("attempts", []):
                raw = att.get("answer_latex") or att.get("expression") or ""
                latex_fixed = self.app.progress_analyzer.detect_and_convert_matrix(raw)
                is_correct = att.get("correct", False)

                if is_correct and finalized:
                    flag_text, flag_color = "üîí Finalized", "#166534"
                elif is_correct and not finalized:
                    flag_text, flag_color = "‚úÖ Correct", "#15803d"
                elif not is_correct and finalized:
                    flag_text, flag_color = "‚ö†Ô∏è False Finalized", "#b45309"
                else:
                    flag_text, flag_color = "‚ùå False", "#991b1b"

                attempts_html += f"""
                    <div style='border:1px solid #e5e7eb;padding:6px 10px;border-radius:6px;background:#fff;
                                 min-width:110px;text-align:center;'>
                        <div style='font-size:12px;color:{flag_color};margin-bottom:4px;'>{flag_text}</div>
                        <div class='mathjax-latex'>\({latex_fixed}\)</div>
                    </div>
                """
            attempts_html += "</div>"

            if not step.get("attempts"):
                attempts_html = "<em style='color:#9ca3af;'>No attempts</em>"

            html_content += f"""
                <tr>
                    <td style='padding:8px;vertical-align:top;font-weight:600;'>{step_no}</td>
                    <td style='padding:8px;vertical-align:top;text-align:center;'>{status}</td>
                    <td style='padding:8px;vertical-align:top;'>{attempts_html}</td>
                </tr>
            """

        html_content += "</tbody></table>"
        return html_content
    # =====================================================
    # STATUS TABLE (üÜï includes Ignored column)
    # =====================================================
    def create_status_table(self, groups, cheating_phones, phone_to_cheat_group):
        panel = document.createElement("div")
        panel.className = "panel"

        # Get sort indicators for status table
        def get_status_sort_indicator(col):
            if self.status_sort["column"] == col:
                return "‚ñº" if self.status_sort["direction"] == "desc" else "‚ñ≤"
            return ""

        panel.innerHTML = f"""
            <h3 style='margin-top:0;'>üìã Submission Status (Extended)</h3>
            <div style='overflow-x:auto;'>
            <table id='statusTable' style='width:100%;border-collapse:collapse;font-size:13px;'>
                <thead>
                    <tr style='background:#f3f4f6;'>
                        <th>#</th>
                        <th class='sortable-status-header' data-column='name' style='cursor:pointer;user-select:none;' title='Click to sort'>Name {get_status_sort_indicator('name')}</th>
                        <th class='sortable-status-header' data-column='reg' style='cursor:pointer;user-select:none;' title='Click to sort'>Reg No {get_status_sort_indicator('reg')}</th>
                        <th>Phone</th>
                        <th class='sortable-status-header' data-column='status' style='cursor:pointer;user-select:none;' title='Click to sort'>Status {get_status_sort_indicator('status')}</th>
                        <th>‚úÖ Success</th>
                        <th>üïì Ignored</th>
                        <th class='sortable-status-header' data-column='invalid' style='cursor:pointer;user-select:none;' title='Click to sort'>‚ö†Ô∏è Invalid {get_status_sort_indicator('invalid')}</th>
                        <th>üö® Cheating</th>
                    </tr>
                </thead>
                <tbody id='statusTableBody'></tbody>
            </table>
            </div>
        """

        tbody = panel.querySelector("#statusTableBody")
        all_phones = set()
        if self.app.student_roster:
            all_phones.update(self.app.student_roster.keys())
        all_phones.update(groups.keys())
        for inv in self.invalid_list:
            all_phones.add(inv.get("student_phone", "unknown"))
        for group in self.cheating_groups:
            for student in group["students"]:
                all_phones.add(student["phone"])

        invalid_counts = defaultdict(int)
        for inv in self.invalid_list:
            invalid_counts[inv.get("student_phone", "unknown")] += 1

        plagiat_counts = defaultdict(int)
        for group in self.cheating_groups:
            for student in group["students"]:
                plagiat_counts[student["phone"]] += 1

        ignored_counts = defaultdict(int)
        for dup in self.ignored_list:
            ignored_counts[dup.get("student_phone", "unknown")] += 1

        student_status_data = []
        for phone in all_phones:
            roster_info = self.app.student_roster.get(phone, {}) if self.app.student_roster else {}
            name = roster_info.get("name", "Unknown")
            reg = roster_info.get("registration_number", "")

            success_exports = {sub.get("export_id") for sub in groups.get(phone, []) if sub.get("export_id")}
            success_count = len(success_exports)
            ignored_count = ignored_counts.get(phone, 0)
            invalid_count = invalid_counts.get(phone, 0)
            plagiat_count = plagiat_counts.get(phone, 0)

            if plagiat_count > 0:
                status, status_class, status_priority = f"Cheat #{phone_to_cheat_group.get(phone, '?')}", "score-low", 1
            elif success_count > 0:
                status, status_class, status_priority = "Submitted", "score-high", 3
            elif invalid_count > 0:
                status, status_class, status_priority = "Submitted", "score-medium", 4
            else:
                status, status_class, status_priority = "Not Submitted", "score-low", 5

            student_status_data.append({
                "phone": phone,
                "name": name,
                "reg": reg,
                "status": status,
                "status_class": status_class,
                "status_priority": status_priority,
                "success_count": success_count,
                "ignored_count": ignored_count,
                "invalid_count": invalid_count,
                "plagiat_count": plagiat_count
            })

        # Store data for re-sorting
        self.status_table_data = student_status_data

        sorted_status_data = self.sort_status_data(student_status_data)
        for idx, s in enumerate(sorted_status_data, 1):
            tr = document.createElement("tr")
            tr.innerHTML = f"""
                <td>{idx}</td>
                <td>{html.escape(s['name'])}</td>
                <td>{html.escape(str(s['reg']))}</td>
                <td>{html.escape(s['phone'])}</td>
                <td style='text-align:center;'><span class='score-badge {s['status_class']}'>{s['status']}</span></td>
                <td style='text-align:center;'>{s['success_count']}</td>
                <td style='text-align:center;'>{s['ignored_count']}</td>
                <td style='text-align:center;'>{s['invalid_count']}</td>
                <td style='text-align:center;'>{s['plagiat_count']}</td>
            """
            tbody.appendChild(tr)
        return panel

    # =====================================================
    # INVALID PANEL
    # =====================================================
    def create_invalid_panel(self, invalid):
        panel = document.createElement("div")
        panel.className = "panel"
        panel.innerHTML = "<h3 style='margin-top:0;'>‚ö†Ô∏è Invalid Entries (Details)</h3>"
        for item in invalid:
            phone = item.get("student_phone", "Unknown")
            name = self.app.student_roster.get(phone, {}).get("name", "Unknown") if self.app.student_roster else "Unknown"
            err = item.get("error", "Unknown error")
            div = document.createElement("div")
            div.className = "small"
            div.style.color = "#b45309"
            div.textContent = f"üì± {phone} ‚Äî {name}: {err}"
            panel.appendChild(div)
        return panel

    # =====================================================
    # RE-RENDER TABLES (for sorting)
    # =====================================================
    def rerender_student_table(self):
        """Re-render student table body with current sort"""
        tbody = document.querySelector("#scoreTableBody")
        if not tbody or not hasattr(self, "student_table_data"):
            return

        # Clear existing rows
        tbody.innerHTML = ""

        # Sort data
        sorted_data = self.sort_student_data(self.student_table_data)

        # Render rows
        for idx, student in enumerate(sorted_data, 1):
            score_display = "‚Äî" if student["is_cheating"] else f"{student['score']}%"
            cls = "score-low" if student["is_cheating"] else self.app.progress_analyzer.get_score_class(student["score"])
            tr = document.createElement("tr")
            tr.innerHTML = f"""
                <td>{idx}</td>
                <td>{html.escape(student['name'])}</td>
                <td>{html.escape(str(student['reg']))}</td>
                <td style='text-align:center;'><span class='score-badge {cls}'>{score_display}</span></td>
                <td>{html.escape(student['phone'])}</td>
                <td><button class='detail-toggle' data-phone='{html.escape(student['phone'])}'>üîΩ Details</button></td>
            """
            tbody.appendChild(tr)
            tbody.appendChild(self.create_detail_row(student["subs"]))

        # Update header indicators
        thead = document.querySelector("#scoreTable thead")
        if thead:
            for th in thead.querySelectorAll(".sortable-header"):
                col = th.getAttribute("data-column")
                indicator = ""
                if self.current_sort["column"] == col:
                    indicator = " ‚ñº" if self.current_sort["direction"] == "desc" else " ‚ñ≤"
                # Update text (remove old indicator and add new one)
                text = th.textContent.replace(" ‚ñº", "").replace(" ‚ñ≤", "")
                th.textContent = text + indicator

    def rerender_status_table(self):
        """Re-render status table body with current sort"""
        tbody = document.querySelector("#statusTableBody")
        if not tbody or not hasattr(self, "status_table_data"):
            return

        # Clear existing rows
        tbody.innerHTML = ""

        # Sort data
        sorted_status_data = self.sort_status_data(self.status_table_data)

        # Render rows
        for idx, s in enumerate(sorted_status_data, 1):
            tr = document.createElement("tr")
            tr.innerHTML = f"""
                <td>{idx}</td>
                <td>{html.escape(s['name'])}</td>
                <td>{html.escape(str(s['reg']))}</td>
                <td>{html.escape(s['phone'])}</td>
                <td style='text-align:center;'><span class='score-badge {s['status_class']}'>{s['status']}</span></td>
                <td style='text-align:center;'>{s['success_count']}</td>
                <td style='text-align:center;'>{s['ignored_count']}</td>
                <td style='text-align:center;'>{s['invalid_count']}</td>
                <td style='text-align:center;'>{s['plagiat_count']}</td>
            """
            tbody.appendChild(tr)

        # Update header indicators
        thead = document.querySelector("#statusTable thead")
        if thead:
            for th in thead.querySelectorAll(".sortable-status-header"):
                col = th.getAttribute("data-column")
                indicator = ""
                if self.status_sort["column"] == col:
                    indicator = " ‚ñº" if self.status_sort["direction"] == "desc" else " ‚ñ≤"
                # Update text (remove old indicator and add new one)
                text = th.textContent.replace(" ‚ñº", "").replace(" ‚ñ≤", "")
                th.textContent = text + indicator

    # =====================================================
    # EVENT HANDLERS
    # =====================================================
    def attach_table_event_handlers(self):
        from pyodide.ffi import create_proxy
        tbody = document.querySelector("#scoreTableBody")
        if not tbody:
            return

        def on_click(ev):
            target = ev.target
            if target.tagName == "BUTTON" and target.classList.contains("detail-toggle"):
                tr = target.closest("tr")
                detail_row = tr.nextElementSibling
                if detail_row and "detail-row" in detail_row.className:
                    if detail_row.style.display == "none":
                        detail_row.style.display = "table-row"
                        target.textContent = "üîº Hide"
                        try:
                            if hasattr(window, "MathJax"):
                                window.MathJax.typesetPromise([detail_row])
                        except:
                            pass
                    else:
                        detail_row.style.display = "none"
                        target.textContent = "üîΩ Details"
            if target.classList.contains("problem-header"):
                body = target.nextElementSibling
                if body:
                    if body.style.display in ("none", ""):
                        body.style.display = "block"
                        def delayed():
                            try:
                                if hasattr(window, "MathJax"):
                                    window.MathJax.typesetPromise([body])
                            except:
                                pass
                        window.setTimeout(create_proxy(delayed), 50)
                    else:
                        body.style.display = "none"

        tbody.addEventListener("click", create_proxy(on_click))

        # Add click handlers for sortable headers (Student Progress table)
        score_thead = document.querySelector("#scoreTable thead")
        if score_thead:
            def on_header_click(ev):
                target = ev.target
                if target.classList.contains("sortable-header"):
                    col = target.getAttribute("data-column")
                    # Toggle sort direction if clicking same column, otherwise default to asc
                    if self.current_sort["column"] == col:
                        self.current_sort["direction"] = "desc" if self.current_sort["direction"] == "asc" else "asc"
                    else:
                        self.current_sort["column"] = col
                        self.current_sort["direction"] = "asc"
                    # Re-render table
                    self.rerender_student_table()

            score_thead.addEventListener("click", create_proxy(on_header_click))

        # Add click handlers for sortable headers (Status table)
        status_thead = document.querySelector("#statusTable thead")
        if status_thead:
            def on_status_header_click(ev):
                target = ev.target
                if target.classList.contains("sortable-status-header"):
                    col = target.getAttribute("data-column")
                    # Toggle sort direction if clicking same column, otherwise default to asc
                    if self.status_sort["column"] == col:
                        self.status_sort["direction"] = "desc" if self.status_sort["direction"] == "asc" else "asc"
                    else:
                        self.status_sort["column"] = col
                        self.status_sort["direction"] = "asc"
                    # Re-render table
                    self.rerender_status_table()

            status_thead.addEventListener("click", create_proxy(on_status_header_click))

        # Add click handler for Collapse All button
        collapse_btn = document.querySelector("#collapseAllBtn")
        if collapse_btn:
            def on_collapse_all(ev):
                # Find all detail rows and collapse them
                detail_rows = document.querySelectorAll(".detail-row")
                all_collapsed = True
                for row in detail_rows:
                    if row.style.display != "none":
                        all_collapsed = False
                        break

                # If all are collapsed, expand all. Otherwise, collapse all
                if all_collapsed:
                    # Expand all
                    for row in detail_rows:
                        row.style.display = "table-row"
                    # Update all toggle buttons
                    toggle_btns = document.querySelectorAll(".detail-toggle")
                    for btn in toggle_btns:
                        btn.textContent = "üîº Hide"
                    collapse_btn.textContent = "üîΩ Collapse All"
                    # Typeset math for all expanded rows
                    try:
                        if hasattr(window, "MathJax"):
                            window.MathJax.typesetPromise(list(detail_rows))
                    except:
                        pass
                else:
                    # Collapse all
                    for row in detail_rows:
                        row.style.display = "none"
                    # Update all toggle buttons
                    toggle_btns = document.querySelectorAll(".detail-toggle")
                    for btn in toggle_btns:
                        btn.textContent = "üîΩ Details"
                    collapse_btn.textContent = "üîº Expand All"

            collapse_btn.addEventListener("click", create_proxy(on_collapse_all))

    # =====================================================
    # SORT HELPERS
    # =====================================================
    def group_by_student(self, submissions):
        from collections import defaultdict
        groups = defaultdict(list)
        for s in submissions:
            groups[s.get("student_phone", "unknown")].append(s)
        return groups

    def sort_student_data(self, data):
        import re
        col, direction = self.current_sort["column"], self.current_sort["direction"]
        def key(s):
            if col == "name": return s["name"].lower()
            elif col == "reg":
                try: return int(re.sub(r"\D","",s["reg"]) or 0)
                except: return 0
            elif col == "score": return s["score"]
            return s["name"].lower()
        data = sorted(data, key=key, reverse=(direction == "desc"))
        non_cheating = [d for d in data if not d["is_cheating"]]
        cheating = [d for d in data if d["is_cheating"]]
        return non_cheating + cheating

    def sort_status_data(self, data):
        import re
        col, direction = self.status_sort["column"], self.status_sort["direction"]
        def key(s):
            if col == "name":
                return s["name"].lower()
            elif col == "reg":
                try:
                    return int(re.sub(r"\D", "", s["reg"]) or 0)
                except:
                    return 0
            elif col == "status":
                # status_priority first (lower is higher priority), then name
                return (s.get("status_priority", 99), s.get("status", "").lower())
            elif col == "invalid":
                return s.get("invalid_count", 0)
            return s["name"].lower()
        return sorted(data, key=key, reverse=(direction == "desc"))


class PersistenceManager:
    """Manages analytics data persistence with IndexedDB + interactive save popup (overwrite-safe)."""
    # Add this helper method to PersistenceManager
    def _show_loading_in_modal(self, modal, message):
        """Show loading state in modal"""
        modal.innerHTML = f'''
            <div style="text-align: center; padding: 40px;">
                <div class="spinner" style="margin: 0 auto 20px auto;"></div>
                <div style="font-size: 16px; color: #64748b;">{message}</div>
            </div>
        '''
    # =========================================================
    # STARTUP MODAL
    # =========================================================
    async def show_startup_modal(self):
        """Show modal on startup to load saved analytics"""
        from js import document, window
        from pyodide.ffi import create_proxy
        import asyncio

        window.console.log("üöÄ Showing startup modal...")

        # Remove any existing modal
        old_modal = document.querySelector("#startup-modal-overlay")
        if old_modal:
            old_modal.remove()

        # Get list of saved sessions
        self.db_manager._show_progress("üìã Loading saved sessions...")
        saved_keys = await self.list_saved_keys("analytics")
        self.db_manager._hide_progress()
        window.console.log(f"üìã Found {len(saved_keys)} saved sessions")

        # Create modal overlay
        overlay = document.createElement("div")
        overlay.id = "startup-modal-overlay"
        overlay.className = "startup-modal-overlay"

        # Create modal content
        modal = document.createElement("div")
        modal.className = "startup-modal"

        # Build modal HTML based on whether there are saved sessions
        if saved_keys:
            # ‚úÖ HAS SAVED SESSIONS
            sessions_html = '<div class="saved-sessions-list">'
            for key in saved_keys:
                sessions_html += f'''
                    <div class="session-item" data-key="{self._escape(key)}">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <div class="session-name">üìä {self._escape(key)}</div>
                                <div class="session-info">Saved analytics session</div>
                            </div>
                            <button class="delete-session-btn" data-key="{self._escape(key)}" 
                                    style="background: transparent; border: none; color: #dc2626; 
                                           cursor: pointer; font-size: 20px; padding: 4px 8px;"
                                    title="Delete this session">
                                üóëÔ∏è
                            </button>
                        </div>
                    </div>
                '''
            sessions_html += '</div>'

            modal.innerHTML = f'''
                <h2>üìÇ Load Saved Analytics</h2>
                <p>Select a saved analytics session to continue, or start fresh.</p>
                {sessions_html}
                <div class="modal-actions">
                    <button class="modal-btn modal-btn-primary" id="load-selected-btn" disabled>
                        üìÇ Load Selected
                    </button>
                    <button class="modal-btn modal-btn-secondary" id="start-fresh-btn">
                        üÜï Start Fresh
                    </button>
                </div>
            '''
        else:
            # ‚ùå NO SAVED SESSIONS
            modal.innerHTML = '''
                <h2>üìÇ Welcome to Analytics</h2>
                <div class="empty-state">
                    <div class="empty-state-icon">üì≠</div>
                    <div class="empty-state-text">No saved sessions found</div>
                    <div class="empty-state-subtext">Start by analyzing student progress data</div>
                </div>
                <div class="modal-actions">
                    <button class="modal-btn modal-btn-primary" id="start-fresh-btn">
                        ‚ú® Get Started
                    </button>
                </div>
            '''

        overlay.appendChild(modal)
        document.body.appendChild(overlay)

        # Create future for async waiting
        future = asyncio.get_event_loop().create_future()

        # Track selected session
        selected_key = [None]  # Use list for mutable closure

        def close_modal(result=None):
            if not future.done():
                future.set_result(result)
            overlay.remove()

        # ‚úÖ HANDLE SAVED SESSIONS LOGIC
        if saved_keys:
            session_items = modal.querySelectorAll(".session-item")
            load_btn = modal.querySelector("#load-selected-btn")

            # Handle session item clicks
            def handle_session_click(event):
                # Remove previous selection
                for i in range(session_items.length):
                    session_items[i].classList.remove("selected")

                # Add selection to clicked item
                target = event.currentTarget
                target.classList.add("selected")
                selected_key[0] = target.getAttribute("data-key")

                # Enable load button
                if load_btn:
                    load_btn.disabled = False

            # Add click handlers to all session items
            for i in range(session_items.length):
                session_items[i].addEventListener("click", create_proxy(handle_session_click))

            # Handle load button click
            def handle_load(event):
                if selected_key[0]:
                    close_modal(selected_key[0])

            if load_btn:
                load_btn.addEventListener("click", create_proxy(handle_load))

            # After setting up session item clicks, add delete button handlers:
            delete_btns = modal.querySelectorAll(".delete-session-btn")

            async def handle_delete(event):
                event.stopPropagation()  # Don't trigger session selection
                btn = event.currentTarget
                key_to_delete = btn.getAttribute("data-key")

                if window.confirm(f"Delete session '{key_to_delete}'?"):
                    try:
                        await self.db_manager.delete_data("analytics", key_to_delete)
                        window.console.log(f"üóëÔ∏è Deleted session: {key_to_delete}")

                        # Remove from UI
                        session_item = btn.closest(".session-item")
                        if session_item:
                            session_item.remove()

                        # If no more sessions, update modal
                        remaining = modal.querySelectorAll(".session-item")
                        if remaining.length == 0:
                            close_modal(None)  # Close and start fresh

                    except Exception as e:
                        window.console.error(f"‚ùå Delete failed: {e}")
                        window.alert(f"Failed to delete: {e}")

            for i in range(delete_btns.length):
                delete_btns[i].addEventListener("click", create_proxy(handle_delete))
                       
        # ‚úÖ HANDLE START FRESH BUTTON (always present)
        start_fresh_btn = modal.querySelector("#start-fresh-btn")
        if start_fresh_btn:
            start_fresh_btn.addEventListener("click", create_proxy(lambda e: close_modal(None)))

        # Wait for user choice
        chosen_key = await future
        window.console.log(f"üë§ User chose: {chosen_key if chosen_key else 'start fresh'}")

        return chosen_key

    # =========================================================
    # LOAD SPECIFIC SESSION
    # =========================================================
    async def load_specific_session(self, key):
        """Load a specific analytics session by key"""
        from js import window
        import json

        try:
            self.db_manager._show_progress(f"üìÇ Loading session: {key}...")
            window.console.log(f"üìÇ Loading session: {key}")
            data = await self.load_analytics_data(key)

            if data and isinstance(data, list):
                window.console.log(f"‚úÖ Loaded {len(data)} entries from '{key}'")
                self.db_manager._hide_progress()
                return data
            else:
                window.console.warn(f"‚ö†Ô∏è No data found for key '{key}'")
                self.db_manager._hide_progress()
                return []

        except Exception as e:
            window.console.error(f"‚ùå Failed to load session '{key}': {e}")
            self.db_manager._hide_progress()
            return []

    def _escape(self, text):
        """Escape HTML text"""
        import html
        return html.escape(str(text or ""))

    def __init__(self):
        self.app = None
        self.db_manager = IndexedDBManager()

    # =========================================================
    # INITIALIZE
    # =========================================================
    async def initialize(self):
        await self.db_manager.initialize()
        await self.restore_saved_analytics()

    # =========================================================
    # POPUP: Ask user for save name or existing entry
    # =========================================================
    async def prompt_save_choice(self):
        """
        Show popup allowing user to:
        - enter new save name,
        - choose an existing one (with overwrite confirmation),
        - or cancel saving.
        Returns chosen key (str) or None.
        """
        from js import document, window
        from pyodide.ffi import create_proxy
        import asyncio

        # Remove any previous popup
        old_popup = document.querySelector("#save-popup-container")
        if old_popup:
            old_popup.remove()

        # Fetch existing saved entries
        try:
            existing_keys = await self.list_saved_keys("analytics")
        except Exception:
            existing_keys = []

        # --- UI Container ---
        container = document.createElement("div")
        container.id = "save-popup-container"
        container.style.cssText = """
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.5);
            display: flex; justify-content: center; align-items: center;
            z-index: 3000; font-family: sans-serif;
        """

        popup = document.createElement("div")
        popup.style.cssText = """
            background: white; padding: 20px 30px; border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            min-width: 350px; display: flex; flex-direction: column; gap: 10px;
        """

        title = document.createElement("h3")
        title.textContent = "üíæ Save Analytics Data"
        title.style.margin = "0 0 10px 0"

        label_new = document.createElement("label")
        label_new.textContent = "Enter new name:"

        input_name = document.createElement("input")
        input_name.type = "text"
        input_name.placeholder = "e.g., session_2025_10_13"
        input_name.style.padding = "6px"
        input_name.style.fontSize = "14px"

        label_existing = document.createElement("label")
        label_existing.textContent = "Or choose existing:"

        select_existing = document.createElement("select")
        select_existing.style.padding = "6px"
        select_existing.style.fontSize = "14px"
        option_blank = document.createElement("option")
        option_blank.value = ""
        option_blank.textContent = "(none)"
        select_existing.appendChild(option_blank)
        for key in existing_keys:
            opt = document.createElement("option")
            opt.value = key
            opt.textContent = key
            select_existing.appendChild(opt)

        # Buttons
        btn_row = document.createElement("div")
        btn_row.style.textAlign = "right"
        btn_row.style.marginTop = "10px"

        btn_save = document.createElement("button")
        btn_save.textContent = "Save"
        btn_save.style.marginRight = "10px"
        btn_save.style.padding = "6px 12px"

        btn_cancel = document.createElement("button")
        btn_cancel.textContent = "Cancel"
        btn_cancel.style.padding = "6px 12px"

        btn_row.appendChild(btn_save)
        btn_row.appendChild(btn_cancel)

        popup.appendChild(title)
        popup.appendChild(label_new)
        popup.appendChild(input_name)
        popup.appendChild(label_existing)
        popup.appendChild(select_existing)
        popup.appendChild(btn_row)
        container.appendChild(popup)
        document.body.appendChild(container)

        # --- Async waiting mechanism ---
        future = asyncio.get_event_loop().create_future()

        # Function to close popup safely
        def close_popup(result=None):
            if not future.done():
                future.set_result(result)
            try:
                save_proxy.destroy()
                cancel_proxy.destroy()
            except Exception:
                pass
            container.remove()

        # --- Event Handlers ---
        async def handle_save(event=None):
            name = input_name.value.strip() or select_existing.value.strip()
            if not name:
                window.alert("Please enter or choose a name.")
                return

            # Confirm overwrite if exists
            if name in existing_keys:
                confirm = window.confirm(f"Data named '{name}' already exists. Overwrite?")
                if not confirm:
                    return

            close_popup(name)

        def handle_cancel(event=None):
            close_popup(None)

        # Wrap in JS-safe proxies
        save_proxy = create_proxy(handle_save)
        cancel_proxy = create_proxy(handle_cancel)

        btn_save.addEventListener("click", save_proxy)
        btn_cancel.addEventListener("click", cancel_proxy)

        # Wait for user response
        return await future

    # =========================================================
    # LIST ALL SAVED KEYS
    # =========================================================
    async def list_saved_keys(self, store_name):
        """Return list of all saved keys from IndexedDB."""
        from js import Function, window
        from pyodide.ffi import to_js

        if not self.db_manager.initialized:
            await self.db_manager.initialize()

        try:
            list_keys_fn = Function(
                """
                return async function(dbName, store) {
                    const dbReq = indexedDB.open(dbName);
                    return new Promise((resolve, reject) => {
                        dbReq.onupgradeneeded = e => {
                            const db = e.target.result;
                            // Create object stores if they don't exist
                            if (!db.objectStoreNames.contains("analytics")) {
                                db.createObjectStore("analytics", { keyPath: "id" });
                            }
                            if (!db.objectStoreNames.contains("hashes")) {
                                db.createObjectStore("hashes", { keyPath: "id" });
                            }
                        };
                        dbReq.onsuccess = e => {
                            const db = e.target.result;
                            // Check if the requested store exists
                            if (!db.objectStoreNames.contains(store)) {
                                db.close();
                                resolve([]);  // Return empty array if store doesn't exist
                                return;
                            }
                            const tx = db.transaction(store, "readonly");
                            const st = tx.objectStore(store);
                            const keysReq = st.getAllKeys();
                            keysReq.onsuccess = () => {
                                const keys = keysReq.result.map(k => String(k));
                                db.close();
                                resolve(keys);
                            };
                            keysReq.onerror = e => { db.close(); reject(e.target.error); };
                        };
                        dbReq.onerror = e => {
                            const error = e.target.error;
                            // Detect version error and auto-delete corrupted database
                            if (error && error.name === 'VersionError') {
                                console.warn('‚ö†Ô∏è VersionError detected - database version conflict. Auto-deleting...');
                                indexedDB.deleteDatabase(dbName);
                                console.log('üóëÔ∏è Deleted database due to version conflict. Please reload the page.');
                                reject(new Error('VERSION_CONFLICT: Database deleted. Please reload the page.'));
                            } else {
                                reject(error);
                            }
                        };
                    });
                }
                """
            )

            js_fn = list_keys_fn()
            result = await js_fn(
                to_js(self.db_manager.db_name),
                to_js(store_name),
            )

            return [r.to_py() if hasattr(r, "to_py") else str(r) for r in result]

        except Exception as e:
            error_msg = str(e)
            if "VERSION_CONFLICT" in error_msg:
                window.console.error("üîÑ Database version conflict detected and resolved.")
                window.console.error("üí° Please reload the page to continue with a fresh database.")
                if window.confirm("‚ö†Ô∏è Database version conflict detected.\n\nThe old database has been deleted.\n\nReload the page now?"):
                    window.location.reload()
            else:
                window.console.warn(f"‚ö†Ô∏è list_saved_keys failed: {e}")
            return []

    # =========================================================
    # SANITIZE
    # =========================================================
    def sanitize_for_storage(self, data):
        import js, datetime
        from js import window

        def safe_convert(obj):
            if obj is None or isinstance(obj, (int, float, str, bool)):
                return obj
            if isinstance(obj, dict):
                return {str(k): safe_convert(v) for k, v in obj.items()}
            if isinstance(obj, (list, tuple, set)):
                return [safe_convert(v) for v in obj]
            if hasattr(obj, "to_py"):
                try:
                    return safe_convert(obj.to_py())
                except Exception:
                    return str(obj)
            if isinstance(obj, datetime.datetime):
                return obj.isoformat()
            try:
                if hasattr(js, "Date") and isinstance(obj, js.Date):
                    return js.Date(obj).toISOString()
            except Exception:
                pass
            return str(obj)

        try:
            return safe_convert(data)
        except Exception as e:
            window.console.warn(f"‚ö†Ô∏è sanitize_for_storage failed: {e}")
            return []                       
                       
    # =========================================================
    # SAVE ANALYTICS (Interactive)
    # =========================================================
    async def save_analytics_data(self):
        """Save analytics data with interactive prompt"""
        from js import window
        import json

        # Show the existing save prompt
        chosen_key = await self.prompt_save_choice()
        if not chosen_key:
            window.console.log("üí° Save cancelled by user")
            return

        try:
            safe_data = self.sanitize_for_storage(self.app.analytics_data)
            json_text = json.dumps(safe_data)
            js_text = window.String.new(json_text)

            await self.db_manager.save_data("analytics", chosen_key, js_text)
            window.console.log(f"üíæ Saved {len(safe_data)} entries under key '{chosen_key}'")

            # Show success message
            window.alert(f"‚úÖ Analytics saved successfully!\n\nSession name: {chosen_key}")

        except Exception as e:
            window.console.warn(f"‚ö†Ô∏è Could not save: {e}")
            window.alert(f"‚ùå Save failed: {e}")
    # =========================================================
    # LOAD ANALYTICS
    # =========================================================
    async def load_analytics_data(self, key="analytics_data"):
        from js import window
        import json
        try:
            data = await self.db_manager.load_data("analytics", key)
            if isinstance(data, str):
                data = json.loads(data)
            elif hasattr(data, "to_py"):
                data = json.loads(data.to_py())
            if data and isinstance(data, list):
                window.console.log(f"üì¶ Restored {len(data)} entries from '{key}'")
                return data
        except Exception as e:
            window.console.warn(f"‚ö†Ô∏è Could not load: {e}")
        return []

    # =========================================================
    # CLEAR DATA
    # =========================================================
    async def clear_stored_analytics(self, key="analytics_data"):
        from js import window
        try:
            await self.db_manager.delete_data("analytics", key)
            window.console.log(f"üßπ Cleared data '{key}' from IndexedDB")
        except Exception as e:
            window.console.warn(f"‚ö†Ô∏è Could not clear: {e}")

    # =========================================================
    # RESTORE ON STARTUP
    # =========================================================
    async def restore_saved_analytics(self):
        """Show startup modal and restore selected session"""
        from js import window

        # Show modal and get user choice
        chosen_key = await self.show_startup_modal()

        if chosen_key:
            # User selected a saved session
            window.console.log(f"üìÇ User selected: {chosen_key}")
            loaded_data = await self.load_specific_session(chosen_key)

            if loaded_data:
                self.app.analytics_data = loaded_data
                self.app.progress_analyzer.analytics_data = loaded_data
                self.app.display_manager.display_analytics(loaded_data, [])
                window.console.log(f"‚úÖ Restored {len(loaded_data)} analytics entries")
            else:
                window.console.log("‚ö†Ô∏è No data loaded, starting fresh")
        else:
            # User chose to start fresh
            window.console.log("üÜï User chose to start fresh")
            self.app.analytics_data = []
            self.app.progress_analyzer.analytics_data = []
            self.app.display_manager.display_analytics([], [])

    # =========================================================
    # DELETE SELECTED SESSIONS MODAL
    # =========================================================
    async def show_delete_sessions_modal(self):
        """Show modal to select and delete saved sessions"""
        from js import document, window
        from pyodide.ffi import create_proxy
        import asyncio

        window.console.log("üóëÔ∏è Showing delete sessions modal...")

        # Get list of saved sessions
        self.db_manager._show_progress("üìã Loading saved sessions...")
        saved_keys = await self.list_saved_keys("analytics")
        self.db_manager._hide_progress()

        if not saved_keys:
            window.alert("No saved sessions to delete.")
            return

        window.console.log(f"üìã Found {len(saved_keys)} saved sessions")

        # Create modal overlay
        overlay = document.createElement("div")
        overlay.id = "delete-modal-overlay"
        overlay.className = "startup-modal-overlay"

        # Create modal content
        modal = document.createElement("div")
        modal.className = "startup-modal"

        # Build sessions list with checkboxes
        sessions_html = '<div class="saved-sessions-list" style="max-height: 400px; overflow-y: auto;">'
        for key in saved_keys:
            sessions_html += f'''
                <div class="session-item" style="padding: 12px; border: 1px solid #e5e7eb; border-radius: 8px; margin-bottom: 8px;">
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" class="session-checkbox" value="{self._escape(key)}"
                               style="margin-right: 12px; width: 18px; height: 18px; cursor: pointer;">
                        <div>
                            <div class="session-name" style="font-weight: 600; color: #111827;">üìä {self._escape(key)}</div>
                            <div class="session-info" style="font-size: 12px; color: #6b7280;">Saved analytics session</div>
                        </div>
                    </label>
                </div>
            '''
        sessions_html += '</div>'

        modal.innerHTML = f'''
            <h2 style="margin-top: 0;">üóëÔ∏è Delete Saved Sessions</h2>
            <p style="color: #6b7280;">Select one or more sessions to delete permanently.</p>
            <div style="margin: 16px 0;">
                <label style="display: flex; align-items: center; cursor: pointer; font-size: 14px; color: #111827;">
                    <input type="checkbox" id="select-all-checkbox"
                           style="margin-right: 8px; width: 16px; height: 16px; cursor: pointer;">
                    <strong>Select All</strong>
                </label>
            </div>
            {sessions_html}
            <div class="modal-actions" style="margin-top: 20px; display: flex; gap: 12px;">
                <button class="modal-btn modal-btn-secondary" id="cancel-delete-btn">
                    Cancel
                </button>
                <button class="modal-btn" id="confirm-delete-btn"
                        style="background: #ef4444; color: white;" disabled>
                    üóëÔ∏è Delete Selected
                </button>
            </div>
        '''

        overlay.appendChild(modal)
        document.body.appendChild(overlay)

        # Get elements
        checkboxes = modal.querySelectorAll(".session-checkbox")
        select_all = modal.querySelector("#select-all-checkbox")
        confirm_btn = modal.querySelector("#confirm-delete-btn")
        cancel_btn = modal.querySelector("#cancel-delete-btn")

        # Update button state based on selection
        def update_button_state():
            selected_count = len([cb for cb in checkboxes if cb.checked])
            confirm_btn.disabled = selected_count == 0
            if selected_count > 0:
                confirm_btn.textContent = f"üóëÔ∏è Delete {selected_count} Session{'s' if selected_count > 1 else ''}"
            else:
                confirm_btn.textContent = "üóëÔ∏è Delete Selected"

        # Handle checkbox changes
        def on_checkbox_change(e):
            update_button_state()
            # Update select all checkbox
            all_checked = all(cb.checked for cb in checkboxes)
            some_checked = any(cb.checked for cb in checkboxes)
            select_all.checked = all_checked
            select_all.indeterminate = some_checked and not all_checked

        # Handle select all
        def on_select_all(e):
            for cb in checkboxes:
                cb.checked = select_all.checked
            update_button_state()

        # Bind checkbox events
        checkbox_proxy = create_proxy(on_checkbox_change)
        for cb in checkboxes:
            cb.addEventListener("change", checkbox_proxy)

        select_all_proxy = create_proxy(on_select_all)
        select_all.addEventListener("change", select_all_proxy)

        # Handle cancel
        def close_modal(e=None):
            overlay.remove()
            checkbox_proxy.destroy()
            select_all_proxy.destroy()
            cancel_proxy.destroy()
            confirm_proxy.destroy()

        # Handle confirm delete
        async def confirm_delete(e=None):
            selected_keys = [cb.value for cb in checkboxes if cb.checked]

            if not selected_keys:
                return

            # Confirm deletion
            count = len(selected_keys)
            if not window.confirm(f"‚ö†Ô∏è Are you sure you want to delete {count} session{'s' if count > 1 else ''}?\n\nThis action cannot be undone."):
                return

            # Show loading indicator
            self.db_manager._show_progress(f"üóëÔ∏è Deleting {count} session{'s' if count > 1 else ''}...")

            # Delete each selected session
            deleted_count = 0
            for i, key in enumerate(selected_keys, 1):
                try:
                    self.db_manager._show_progress(f"üóëÔ∏è Deleting session {i}/{count}...")
                    await self.db_manager.delete_data("analytics", key)
                    window.console.log(f"üóëÔ∏è Deleted session: {key}")
                    deleted_count += 1
                except Exception as e:
                    window.console.error(f"‚ùå Failed to delete {key}: {e}")

            # Hide loading indicator
            self.db_manager._hide_progress()

            # Show result
            if deleted_count > 0:
                window.alert(f"‚úÖ Successfully deleted {deleted_count} session{'s' if deleted_count > 1 else ''}.")

            close_modal()

        cancel_proxy = create_proxy(close_modal)
        confirm_proxy = create_proxy(confirm_delete)

        cancel_btn.addEventListener("click", cancel_proxy)
        confirm_btn.addEventListener("click", confirm_proxy)

        # Close on overlay click
        overlay.addEventListener("click", create_proxy(lambda e: close_modal() if e.target == overlay else None))

# ================================================================
# WHATSAPP SERVICE
# ================================================================
class WhatsAppService:
    """Service for parsing WhatsApp chat exports and extracting progress reports"""

    def __init__(self):
        self.base64_pattern = r'[A-Za-z0-9+/]{100,}={0,2}'  # Pattern for base64 data (min 100 chars)

    def combine_segmented_messages(self, chat_text):
        """
        Detect and combine segmented messages (marked with [Part X/N])

        Args:
            chat_text: Raw text from WhatsApp/Telegram chat

        Returns:
            Text with segmented messages combined
        """
        import re
        from js import window

        if not chat_text:
            return chat_text

        lines = chat_text.split('\n')
        combined_lines = []
        segment_buffer = {}  # Store segments by sender: {sender: {part_num: content}}

        # Pattern for part markers: [Part 1/3], [Part 2/3], etc.
        part_pattern = r'\[Part\s+(\d+)/(\d+)\]'

        message_pattern = r'\[?(\d{1,2}/\d{1,2}/\d{2,4}),?\s+(\d{1,2}:\d{2}(?::\d{2})?)\]?\s*-?\s*([^:]+):\s*(.+)'

        for line in lines:
            match = re.match(message_pattern, line)

            if match:
                date, time, sender, content = match.groups()
                sender_key = sender.strip()

                # Check if this message contains a part marker
                part_match = re.search(part_pattern, content)

                if part_match:
                    part_num = int(part_match.group(1))
                    total_parts = int(part_match.group(2))

                    # Remove part marker from content
                    content_clean = re.sub(part_pattern, '', content).strip()

                    # Initialize buffer for this sender if needed
                    if sender_key not in segment_buffer:
                        segment_buffer[sender_key] = {
                            'parts': {},
                            'total': total_parts,
                            'header': f"[{date}, {time}] {sender}: "
                        }

                    # Store this part
                    segment_buffer[sender_key]['parts'][part_num] = content_clean

                    # Check if we have all parts
                    if len(segment_buffer[sender_key]['parts']) == total_parts:
                        # Combine all parts in order
                        combined_content = []
                        for i in range(1, total_parts + 1):
                            if i in segment_buffer[sender_key]['parts']:
                                combined_content.append(segment_buffer[sender_key]['parts'][i])

                        # Create combined message
                        full_message = segment_buffer[sender_key]['header'] + '\n'.join(combined_content)
                        combined_lines.append(full_message)

                        window.console.log(f"‚úÖ Combined {total_parts} segments from {sender_key}")

                        # Clear buffer for this sender
                        del segment_buffer[sender_key]
                else:
                    # Regular message, not a segment
                    combined_lines.append(line)
            else:
                # Not a message header, could be continuation
                combined_lines.append(line)

        # Add warning for incomplete segments
        for sender, data in segment_buffer.items():
            window.console.warn(f"‚ö†Ô∏è Incomplete segmented message from {sender}: " +
                              f"got {len(data['parts'])}/{data['total']} parts")

        return '\n'.join(combined_lines)

    def parse_chat_export(self, chat_text):
        """
        Parse WhatsApp chat export and extract progress reports

        Args:
            chat_text: Raw text from WhatsApp chat export

        Returns:
            List of dictionaries containing:
            - data: base64-encoded progress report
            - phone: sender's phone number
            - timestamp: message timestamp
            - sender: sender name
        """
        import re
        from js import window

        if not chat_text:
            return []

        # First, combine any segmented messages
        chat_text = self.combine_segmented_messages(chat_text)

        reports = []
        lines = chat_text.split('\n')

        # WhatsApp export format patterns:
        # [DD/MM/YYYY, HH:MM:SS] Name: Message
        # or
        # DD/MM/YYYY, HH:MM - Name: Message

        message_pattern = r'\[?(\d{1,2}/\d{1,2}/\d{2,4}),?\s+(\d{1,2}:\d{2}(?::\d{2})?)\]?\s*-?\s*([^:]+):\s*(.+)'

        current_message = None
        current_data = []

        for line in lines:
            line = line.strip()
            if not line:
                continue

            # Try to match a new message header
            match = re.match(message_pattern, line)

            if match:
                # Save previous message if it had base64 data
                if current_message and current_data:
                    combined = ''.join(current_data)
                    if len(combined) >= 100:  # Minimum length for valid base64 export
                        reports.append({
                            'data': combined,
                            'phone': current_message.get('phone', ''),
                            'timestamp': current_message.get('timestamp', ''),
                            'sender': current_message.get('sender', ''),
                            'date': current_message.get('date', '')
                        })

                # Start new message
                date, time, sender, content = match.groups()
                current_message = {
                    'date': date,
                    'time': time,
                    'timestamp': f"{date} {time}",
                    'sender': sender.strip(),
                    'phone': self._extract_phone_from_sender(sender),
                }
                current_data = []

                # Check if this line contains base64 data
                base64_matches = re.findall(self.base64_pattern, content)
                if base64_matches:
                    current_data.extend(base64_matches)

            else:
                # Continuation of previous message
                if current_message:
                    # Look for base64 data in continuation lines
                    base64_matches = re.findall(self.base64_pattern, line)
                    if base64_matches:
                        current_data.extend(base64_matches)

        # Don't forget the last message
        if current_message and current_data:
            combined = ''.join(current_data)
            if len(combined) >= 100:
                reports.append({
                    'data': combined,
                    'phone': current_message.get('phone', ''),
                    'timestamp': current_message.get('timestamp', ''),
                    'sender': current_message.get('sender', ''),
                    'date': current_message.get('date', '')
                })

        window.console.log(f"WhatsApp Service: Found {len(reports)} potential progress reports")
        return reports

    def _extract_phone_from_sender(self, sender):
        """Extract phone number from sender name if present"""
        import re

        if not sender:
            return ""

        # Look for phone number patterns in sender name
        # Common formats: +62 XXX, 0XXX, +62XXX
        phone_pattern = r'(\+?62\s?\d[\d\s-]{7,13}|0\d[\d\s-]{7,13})'
        match = re.search(phone_pattern, sender)

        if match:
            phone = match.group(1)
            # Normalize phone number
            phone = re.sub(r'[^\d+]', '', phone)
            if phone.startswith('0'):
                phone = '+62' + phone[1:]
            elif phone.startswith('62') and not phone.startswith('+'):
                phone = '+' + phone
            return phone

        return ""

    def validate_base64_export(self, data):
        """Validate if a base64 string looks like a valid progress export"""
        import re

        if not data or len(data) < 100:
            return False

        # Check if it's valid base64 format
        if not re.match(r'^[A-Za-z0-9+/]+=*$', data):
            return False

        # Try to decode and check for expected structure
        try:
            import base64
            import brotli
            import json

            decoded_bytes = base64.b64decode(data)
            decompressed = brotli.decompress(decoded_bytes)
            obj = json.loads(decompressed)

            # Check for expected fields
            if 'submissions' in obj or 'metadata' in obj:
                return True

        except Exception:
            pass

        return False

class AnalyticsApp:
    def __init__(self):
        self.roster_manager = RosterManager()
        self.progress_analyzer = ProgressAnalyzer()
        self.display_manager = DisplayManager()
        self.persistence_manager = PersistenceManager()
        
        self.student_roster = {}
        self.analytics_data = []
        self.debug_mode = False
        
        self.roster_manager.app = self
        self.progress_analyzer.app = self
        self.display_manager.app = self
        self.persistence_manager.app = self
    
    async def initialize(self):
        self.update_status("‚è≥ Initializing...")

        self.update_status("üìã Loading roster manager...")
        self.roster_manager.initialize()

        self.update_status("üìä Loading progress analyzer...")
        self.progress_analyzer.initialize()

        self.update_status("üñ•Ô∏è Loading display manager...")
        self.display_manager.initialize()

        self.update_status("üíæ Initializing database...")
        await self.persistence_manager.initialize()

        self.update_status("‚úÖ Ready!")

        overlay = document.querySelector("#loadingOverlay")
        if overlay:
            overlay.style.opacity = "0"
            window.setTimeout(create_proxy(lambda: overlay.remove()), 600)
    
    def update_status(self, msg):
        box = document.querySelector("#loadingStatus")
        if box:
            d = document.createElement("div")
            d.textContent = msg
            box.appendChild(d)
        window.console.log(msg)
    
    def create_modal(self, title, content, on_close=None):
        modal = document.createElement("div")
        modal.className = "modal"
        
        modal_content = document.createElement("div")
        modal_content.className = "modal-content"
        
        modal_header = document.createElement("div")
        modal_header.className = "modal-header"
        modal_header.innerHTML = f"""
            <div class="modal-title">{title}</div>
            <button class="modal-close">Close</button>
        """
        
        modal_body = document.createElement("div")
        modal_body.innerHTML = content
        
        modal_content.appendChild(modal_header)
        modal_content.appendChild(modal_body)
        modal.appendChild(modal_content)
        
        def close_modal(e=None):
            modal.remove()
            if on_close:
                on_close()
        
        modal_header.querySelector(".modal-close").addEventListener("click", create_proxy(close_modal))
        modal.addEventListener("click", lambda e: close_modal() if e.target == modal else None)
        
        document.body.appendChild(modal)
        return modal

# ================================================================
# INITIALIZATION
# ================================================================
async def init_app():
    global app
    app = AnalyticsApp()
    await app.initialize()
    window.app = app

def start_init():
    import asyncio
    asyncio.ensure_future(init_app())

window.setTimeout(create_proxy(start_init), 800)
  </script>

</body>
</html>
