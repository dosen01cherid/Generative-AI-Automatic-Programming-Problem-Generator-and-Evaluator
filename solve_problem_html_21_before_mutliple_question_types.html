<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
    <title>Problem Solver ‚Äì Fast Loading with Cache</title>

    <!-- External Libraries -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mathquill/0.10.1/mathquill.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathquill/0.10.1/mathquill.min.js"></script>

    <!-- ‚ö° Cache-First Pyodide Loading -->
    <script>
      const CACHE_VERSION = 'problem-solver-v1';
      const PYODIDE_URL = 'https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js';

      function updateStatus(msg) {
        const el = document.getElementById('loadingStatus');
        if (el) el.innerHTML = `<div>${msg}</div>`;
        console.log(msg);
      }

      async function getCachedScript(url) {
        try {
          const cache = await caches.open(CACHE_VERSION);
          let response = await cache.match(url);
          
          if (!response) {
            updateStatus('üì• Downloading Pyodide (first time)...');
            response = await fetch(url);
            await cache.put(url, response.clone());
            updateStatus('‚úÖ Cached for next time!');
          } else {
            updateStatus('‚ö° Loading from cache...');
          }
          
          return await response.text();
        } catch (e) {
          updateStatus('‚ö†Ô∏è Cache unavailable, using CDN...');
          const response = await fetch(url);
          return await response.text();
        }
      }

      // Initialize Pyodide with caching
      async function initPyodide() {
        updateStatus('üîß Loading Pyodide...');
        
        // Get script from cache or CDN
        const scriptText = await getCachedScript(PYODIDE_URL);
        
        // Execute script inline
        const script = document.createElement('script');
        script.textContent = scriptText;
        document.head.appendChild(script);
        
        // Wait for loadPyodide to be available
        await new Promise(resolve => setTimeout(resolve, 100));
        
        window.pyodide = await loadPyodide({
          indexURL: 'https://cdn.jsdelivr.net/pyodide/v0.24.1/full/'
        });
        
        updateStatus('‚úÖ Pyodide ready!');
        
        // Load packages
        updateStatus('üì¶ Loading packages (sympy, lark, brotli)...');
        await window.pyodide.loadPackage(['micropip']);
        await window.pyodide.runPythonAsync(`
import micropip
await micropip.install(['sympy', 'lark', 'Brotli'])
print("‚úÖ Packages installed")
        `);
        
        updateStatus('‚úÖ All packages loaded!');
        
        // ‚úÖ Setup pyscript compatibility layer
        await setupPyScriptCompat();
        
        // Now execute Python scripts in the page
        await executePyScripts();
      }

      // ‚úÖ FIXED: Setup pyscript module compatibility
      async function setupPyScriptCompat() {
        updateStatus('üîß Setting up pyscript compatibility...');
        
        // Create the pyscript module in Python
        await window.pyodide.runPythonAsync(`
import sys
from types import ModuleType
from pyodide.ffi import to_js, create_proxy

# Create a minimal pyscript module
pyscript = ModuleType('pyscript')

# Import js to get access to JavaScript objects
import js as _js

# Expose document and window from JavaScript
pyscript.document = _js.document
pyscript.window = _js.window

# Add to sys.modules so imports work
sys.modules['pyscript'] = pyscript

print("‚úÖ pyscript module created and registered")
print(f"   document type: {type(pyscript.document)}")
print(f"   window type: {type(pyscript.window)}")
        `);
        
        updateStatus('‚úÖ pyscript compatibility ready!');
      }

      // Execute all <script type="py"> tags
      async function executePyScripts() {
        updateStatus('üêç Running Python code...');
        
        const pyScripts = document.querySelectorAll('script[type="py"]');
        console.log(`Found ${pyScripts.length} Python scripts`);
        
        for (let i = 0; i < pyScripts.length; i++) {
          const script = pyScripts[i];
          const code = script.textContent;
          
          updateStatus(`üêç Executing Python script ${i + 1}/${pyScripts.length}...`);
          
          try {
            console.log('Executing Python code...');
            await window.pyodide.runPythonAsync(code);
            console.log('‚úÖ Python code executed successfully');
          } catch (e) {
            console.error('Python execution error:', e);
            console.error('Error details:', e.message);
            updateStatus('‚ùå Python error: ' + e.message);
            
            // Show error in alert for debugging
            alert('Python Error:\n' + e.message + '\n\nCheck console for details.');
            throw e;
          }
        }
        
        updateStatus('‚úÖ Python app ready!');
        
        // Hide loading overlay
        const overlay = document.getElementById('loadingOverlay');
        if (overlay) {
          overlay.style.opacity = '0';
          setTimeout(() => overlay.remove(), 400);
        }
      }

      // Start loading on page load
      window.addEventListener('load', async () => {
        try {
          await initPyodide();
        } catch (e) {
          updateStatus('‚ùå Error: ' + e.message);
          console.error('Initialization error:', e);
        }
      });
    </script>

    <!-- MathJax Configuration -->
    <script>
     window.MathJax = {
  tex: {
    inlineMath: [['\\(', '\\)'], ['$', '$']],
    displayMath: [['\\[', '\\]'], ['$$', '$$']]
  },
  asciimath: {
    delimiters: [['`', '`']]
  },
  loader: {
    load: ['input/tex', 'input/asciimath', 'output/chtml']
  },
  chtml: { 
    scale: 1.2 
  },
  startup: { 
    typeset: false,
    ready: () => {
      console.log('‚úÖ MathJax ready (LaTeX + AsciiMath)');
      MathJax.startup.defaultReady();
    }
  }
};
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script>

    <style>
    /* 
    ========================================
    INSERT YOUR COMPLETE CSS HERE
    ========================================
    */
    * { 
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body { 
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial; 
      margin: 0; 
      padding: 0;
      background: #f3f6fb; 
      color: #0b1020; 
      overflow-x: hidden;
    }

    #loadingOverlay { 
      position: fixed; 
      top: 0; 
      left: 0; 
      right: 0; 
      bottom: 0; 
      background: rgba(15,23,42,0.95); 
      z-index: 9999; 
      display: flex; 
      flex-direction: column; 
      align-items: center; 
      justify-content: center; 
      color: #fff; 
    }

    .spinner { 
      width: 60px; 
      height: 60px; 
      border: 4px solid rgba(59,130,246,0.3); 
      border-top-color: #3b82f6; 
      border-radius: 50%; 
      animation: spin 1s linear infinite; 
      margin-bottom: 20px; 
    }

    @keyframes spin { 
      to { transform: rotate(360deg); } 
    }

    .loading-text {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 12px;
    }

    #loadingStatus {
      font-size: 14px;
      color: #94a3b8;
      text-align: center;
      max-width: 80%;
    }

    .panel { 
      background: #fff; 
      padding: 10px;
      border-radius: 8px; 
      box-shadow: 0 6px 20px rgba(11,20,40,0.06); 
      margin-bottom: 8px;
    }

    .btn { 
      padding: 10px 16px; 
      border-radius: 8px; 
      border: none; 
      cursor: pointer; 
      background: #0b6efd; 
      color: #fff; 
      font-size: 15px; 
      font-weight: 500; 
      transition: all 0.2s ease;
      width: 100%;
      margin-bottom: 8px;
    }

    .btn:hover { 
      transform: translateY(-1px); 
      box-shadow: 0 4px 12px rgba(11,110,253,0.3); 
    }

    .btn.ghost { 
      background: transparent; 
      color: #0b6efd; 
      border: 1px solid #dbe9ff; 
    }

    .storage-indicator { 
      position: fixed; 
      bottom: 16px; 
      right: 16px; 
      padding: 10px 14px; 
      background: #10b981; 
      color: #fff; 
      border-radius: 8px; 
      font-size: 13px; 
      opacity: 0; 
      transition: opacity 0.3s; 
      pointer-events: none; 
      z-index: 1000;
      font-weight: 600;
    }

    .storage-indicator.show { 
      opacity: 1; 
    }

    
/* SVG button content styling */
.input-btn svg {
  display: block;
  margin: 0 auto;
  pointer-events: none; /* Prevent SVG from intercepting clicks */
}

/* Ensure SVG buttons maintain proper sizing */
.input-btn.navigation svg,
.input-btn.special svg {
  width: 100%;
  height: 100%;
  max-width: 32px;
  max-height: 32px;
}
    /* Scrollable attempt entries */
.attempt-entry-wrapper {
  overflow-x: auto;
  overflow-y: hidden;
  max-width: 100%;
  -webkit-overflow-scrolling: touch;
  margin-bottom: 10px;
  padding: 10px;
  border-radius: 8px;
}

/* Smooth scrollbar for attempt entries */
.attempt-entry-wrapper::-webkit-scrollbar {
  height: 6px;
  background: #f1f5f9;
  border-radius: 3px;
}

.attempt-entry-wrapper::-webkit-scrollbar-thumb {
  background: #cbd5e1;
  border-radius: 3px;
}

.attempt-entry-wrapper::-webkit-scrollbar-thumb:hover {
  background: #94a3b8;
}

/* Mobile adjustments */
@media (max-width: 768px) {
  .attempt-entry-wrapper::-webkit-scrollbar {
    height: 8px;
  }
}

.attempts-history {
  margin-top: 12px;
  max-height: 400px;
  overflow-y: auto;
  background: #f8fafc;
  padding: 10px;
  border-radius: 8px;
  font-size: 14px;
}
  /* Target the MathQuill editable container */
.mq-editable-field {
  /* Base "outer" border style */
  border: 2px solid #007bff !important;
  border-radius: 4px !important;
  position: relative; /* ensure outline etc. are properly placed */
  overflow-x: auto !important;  /* Add horizontal scroll */
  overflow-y: hidden !important;  /* Prevent vertical scroll */
  max-width: 100%;  /* Respect container width */
}

/* Remove or override MathQuill's focus styling */
.mq-editable-field.mq-focused,
.mq-math-mode .mq-editable-field.mq-focused {
  /* Keep your border color on focus */
  border: 2px solid #007bff !important;
  /* Remove or suppress box-shadow (or replace with your own) */
  box-shadow: none !important;
  /* If MathQuill sets border-color, override it */
  border-color: #007bff !important;
}

/* If you used "double-border" via outline + border trick */
.mq-editable-field {
  border: 2px solid #005cbf !important;           /* inner border */
  outline: 3px solid #99c0ff !important;           /* outer border / highlight */
  outline-offset: 2px !important;
}

/* On focus, adjust the outer border if desired */
.mq-editable-field.mq-focused {
  outline: 3px solid #3399ff !important;
}

/* Minimal Input Buttons - BIGGER WITH NO MARGINS */
.input-btn {
  padding: 12px 8px;
  border-radius: 5px;
  border: 1px solid #cbd5e1;
  background: #ffffff;
  cursor: pointer;
  font-size: 16px;
  font-weight: 600;
  transition: all 0.15s ease;
  min-height: 50px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.input-btn:hover {
  background: #f1f5f9;
  border-color: #0b6efd;
  transform: translateY(-1px);
}

.input-btn:active {
  transform: translateY(0);
  background: #e2e8f0;
}

.input-btn.symbol {
  background: #fef3c7;
  border-color: #f59e0b;
  font-weight: 600;
  font-style: italic;
}

.input-btn.symbol:hover {
  background: #fde68a;
}

.input-btn.special {
  background: #fef3c7;
  border-color: #fbbf24;
}

.input-btn.special:hover {
  background: #fde68a;
}

.input-btn.operator {
  background: #dbeafe;
  border-color: #3b82f6;
  font-weight: 600;
}

.input-btn.operator:hover {
  background: #bfdbfe;
}

.input-btn.navigation {
  background: #e0e7ff;
  border-color: #818cf8;
  font-size: 14px;
}

.input-btn.navigation:hover {
  background: #c7d2fe;
}

.input-btn.delete {
  background: #fee2e2;
  border-color: #ef4444;
}

.input-btn.delete:hover {
  background: #fecaca;
}

/* Keyboard Activate/Lock Buttons - More Prominent */
.input-btn.keyboard-activate,
.input-btn.keyboard-lock {
  background: linear-gradient(135deg, rgba(145, 234, 102, 0.4) 0%, rgba(145, 234, 102, 0.4) 100%);
  border: 2px solid #5a67d8;
  color: #000;
  font-weight: 700;
  min-height: 70px;
  display: flex;
  flex-direction: column;
  gap: 3px;
  box-shadow: 0 4px 12px rgba(145, 234, 102, 0.4);
  transition: all 0.2s ease;
}

.input-btn.keyboard-activate:hover,
.input-btn.keyboard-lock:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 16px rgba(102, 234, 163, 0.6);
  background: linear-gradient(135deg, rgba(145, 234, 102, 0.5) 0%, rgba(145, 234, 102, 0.5) 100%);
}

.input-btn.keyboard-activate:active,
.input-btn.keyboard-lock:active {
  transform: translateY(0);
  box-shadow: 0 2px 8px rgba(145, 234, 102, 0.4);
}

.input-btn.keyboard-activate svg,
.input-btn.keyboard-lock svg {
  filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2));
  width: 32px;
  height: 32px;
}

.input-btn.keyboard-activate span,
.input-btn.keyboard-lock span {
  font-size: 11px;
  margin-top: 2px;
}

/* Base Styles - MINIMAL MARGINS */
* { 
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body { 
  font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial; 
  margin: 0; 
  padding: 0;
  background: #f3f6fb; 
  color: #0b1020; 
  overflow-x: hidden;
}

/* Layout - MINIMAL MARGINS */
.app-container {
  display: flex;
  min-height: 100vh;
  margin: 0;
  padding: 0;
}

/* Sidebar */
.sidebar {
  width: 320px;
  background: #fff;
  box-shadow: 4px 0 12px rgba(0,0,0,0.1);
  padding: 16px;
  overflow-y: auto;
  flex-shrink: 0;
  transition: transform 0.3s ease;
}

.sidebar-header {
  margin-bottom: 20px;
}

.nav-menu {
  margin-bottom: 20px;
}

.nav-item {
  display: flex;
  align-items: center;
  padding: 12px 16px;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s ease;
  margin-bottom: 4px;
  font-weight: 500;
}

.nav-item:hover {
  background: #f0f4ff;
}

.nav-item.active {
  background: #dbeafe;
  color: #1d4ed8;
}

.nav-icon {
  margin-right: 12px;
  font-size: 18px;
}

/* Main Content - MINIMAL MARGINS */
.main-content {
  flex: 1;
  padding: 10px;
  max-width: 100%;
  margin: 0;
  width: 100%;
}

/* Pages */
.page {
  display: none;
}

.page.active {
  display: block;
}

/* Components - MINIMAL PADDING */
.panel { 
  background: #fff; 
  padding: 10px;
  border-radius: 8px; 
  box-shadow: 0 6px 20px rgba(11,20,40,0.06); 
  margin-bottom: 8px;
}

.btn { 
  padding: 10px 16px; 
  border-radius: 8px; 
  border: none; 
  cursor: pointer; 
  background: #0b6efd; 
  color: #fff; 
  font-size: 15px; 
  font-weight: 500; 
  transition: all 0.2s ease;
  width: 100%;
  margin-bottom: 8px;
}

.btn:hover { 
  transform: translateY(-1px); 
  box-shadow: 0 4px 12px rgba(11,110,253,0.3); 
}

.btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  transform: none;
}

.btn.ghost { 
  background: transparent; 
  color: #0b6efd; 
  border: 1px solid #dbe9ff; 
}

.btn.ghost:hover { 
  background: rgba(11,110,253,0.05); 
}

label { 
  display: block; 
  font-weight: 600; 
  margin-bottom: 8px;
  font-size: 15px;
}

textarea {
  width: 100%;
  min-height: 120px;
  padding: 10px;
  border-radius: 8px;
  border: 1px solid #e6eef8;
  font-size: 14px;
  font-family: monospace;
  resize: vertical;
}

input[type="file"] {
  display: block;
  width: 100%;
  padding: 12px;
  border: 2px dashed #0b6efd;
  border-radius: 8px;
  margin-bottom: 12px;
  cursor: pointer;
  background: #f0f9ff;
  font-size: 14px;
  transition: all 0.2s ease;
}

input[type="file"]:hover {
  background: #dbeafe;
  border-color: #1d4ed8;
}

.math-input { 
  min-height: 44px; 
  border: 2px solid #e6eef8; 
  border-radius: 8px; 
  padding: 10px; 
  background: #fff;
  font-size: 18px;
  overflow-x: auto;  /* Add horizontal scroll */
  overflow-y: hidden;  /* Prevent vertical scroll */
  white-space: nowrap;  /* Prevent wrapping */
}

/* Accordion */
.accordion-problem { 
  border: 2px solid #e2e8f0; 
  border-radius: 12px; 
  margin-bottom: 16px; 
  background: #ffffff; 
  box-shadow: 0 4px 12px rgba(0,0,0,0.08); 
  overflow: hidden; 
}

.accordion-problem.open { 
  border-color: #3b82f6; 
}

.accordion-problem.finished { 
  border-color: #10b981; 
  background: #f0fdf4; 
}

.accordion-header { 
  padding: 16px; 
  font-weight: 700; 
  cursor: pointer; 
  display: flex; 
  justify-content: space-between; 
  align-items: center; 
  background: #f0f4ff; 
  transition: background 0.2s ease;
  font-size: 16px;
  min-height: 60px;
}

.accordion-header:hover { 
  background: #dbeafe; 
}

.accordion-body { 
  max-height: 0; 
  overflow: hidden; 
  transition: max-height 0.3s ease-in-out; 
  padding: 0 16px; 
}

.accordion-problem.open .accordion-body { 
  max-height: 10000px; 
  padding: 16px; 
}

.progress-summary { 
  font-size: 14px; 
  color: #6b7280; 
  font-weight: 600; 
}

/* Step styling - MINIMAL PADDING */
.step {
  padding: 10px;
  font-size: 16px;
}

.step-description {
  background: #f0fdf4;
  padding: 10px;
  border-radius: 8px;
  margin-bottom: 8px;
  font-size: 16px;
  line-height: 1.6;
  overflow-x: auto;  /* Add horizontal scroll */
  overflow-y: hidden;  /* Prevent vertical scroll */
}

.step-feedback {
  font-size: 15px;
  padding: 10px;
  border-radius: 6px;
  margin-top: 10px;
  font-weight: 600;
  overflow-x: auto;  /* Add horizontal scroll */
  overflow-y: hidden;
}

.attempts-history {
  margin-top: 12px;
  max-height: 400px;
  overflow-y: auto;
  overflow-x: auto;  /* Add horizontal scroll for math */
  background: #f8fafc;
  padding: 10px;
  border-radius: 8px;
  font-size: 14px;
}

/* Problem description with MathJax */
.problem-description {
  overflow-x: auto;  /* Add horizontal scroll */
  overflow-y: hidden;
}

/* Freestyle problem display */
#freestyleProblemDisplay {
  overflow-x: auto;  /* Add horizontal scroll */
  overflow-y: hidden;
  max-width: 100%;
}

/* Smooth scrollbar styling for webkit browsers */
.math-input::-webkit-scrollbar,
.mq-editable-field::-webkit-scrollbar,
.step-description::-webkit-scrollbar,
.problem-description::-webkit-scrollbar,
#freestyleProblemDisplay::-webkit-scrollbar,
.step-feedback::-webkit-scrollbar,
.attempts-history::-webkit-scrollbar {
  height: 6px;
  background: #f1f5f9;
  border-radius: 3px;
}

.math-input::-webkit-scrollbar-thumb,
.mq-editable-field::-webkit-scrollbar-thumb,
.step-description::-webkit-scrollbar-thumb,
.problem-description::-webkit-scrollbar-thumb,
#freestyleProblemDisplay::-webkit-scrollbar-thumb,
.step-feedback::-webkit-scrollbar-thumb,
.attempts-history::-webkit-scrollbar-thumb {
  background: #cbd5e1;
  border-radius: 3px;
}

.math-input::-webkit-scrollbar-thumb:hover,
.mq-editable-field::-webkit-scrollbar-thumb:hover,
.step-description::-webkit-scrollbar-thumb:hover,
.problem-description::-webkit-scrollbar-thumb:hover,
#freestyleProblemDisplay::-webkit-scrollbar-thumb:hover,
.step-feedback::-webkit-scrollbar-thumb:hover,
.attempts-history::-webkit-scrollbar-thumb:hover {
  background: #94a3b8;
}

/* Loading */
#loadingOverlay { 
  position: fixed; 
  top: 0; 
  left: 0; 
  right: 0; 
  bottom: 0; 
  background: rgba(15,23,42,0.95); 
  z-index: 9999; 
  display: flex; 
  flex-direction: column; 
  align-items: center; 
  justify-content: center; 
  color: #fff; 
}

.spinner { 
  width: 60px; 
  height: 60px; 
  border: 4px solid rgba(59,130,246,0.3); 
  border-top-color: #3b82f6; 
  border-radius: 50%; 
  animation: spin 1s linear infinite; 
  margin-bottom: 20px; 
}

@keyframes spin { 
  to { transform: rotate(360deg); } 
}

/* Storage Indicator */
.storage-indicator { 
  position: fixed; 
  bottom: 16px; 
  right: 16px; 
  padding: 10px 14px; 
  background: #10b981; 
  color: #fff; 
  border-radius: 8px; 
  font-size: 13px; 
  opacity: 0; 
  transition: opacity 0.3s; 
  pointer-events: none; 
  z-index: 1000;
  font-weight: 600;
}

.storage-indicator.show { 
  opacity: 1; 
}

/* Mobile Responsive - MINIMAL MARGINS FOR AESTHETICS */
@media (max-width: 768px) {
  /* Remove all default padding from body and html */
  html {
    margin: 0;
    padding: 0;
  }
  
  body {
    padding: 0;
    margin: 0;
    font-size: 17px;
  }
  
  .app-container {
    flex-direction: column;
    padding: 0;
    margin: 0;
  }
  
  /* Full-width sidebar on mobile */
  .sidebar {
    position: fixed;
    left: -100%;
    top: 0;
    width: 85%;
    max-width: 400px;
    height: 100vh;
    z-index: 1000;
    box-shadow: 4px 0 12px rgba(0,0,0,0.1);
    padding: 20px;
  }
  
  .sidebar.open {
    left: 0;
  }
  
  /* MINIMAL MARGINS FOR AESTHETICS - Just enough breathing room */
  .main-content {
    padding: 60px 4px 4px 4px;  /* Very minimal 4px side margins */
    width: 100%;
    max-width: 100%;
    margin: 0;
  }
  
  /* Menu button with minimal margin */
  .menu-btn {
    position: fixed;
    top: 5px;
    left: 5px;
    z-index: 1001;
    width: 50px;
    height: 50px;
    background: #0b6efd;
    color: #fff;
    border: none;
    border-radius: 12px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 26px;
    box-shadow: 0 4px 16px rgba(11,110,253,0.5);
    font-weight: bold;
  }
  
  .sidebar-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.6);
    z-index: 999;
    display: none;
  }
  
  .sidebar-overlay.show {
    display: block;
  }
  
  /* LARGER FONTS ON MOBILE */
  h3 {
    font-size: 22px;
  }
  
  h4 {
    font-size: 20px;
  }
  
  label {
    font-size: 17px;
  }
  
  /* Accordion with minimal padding */
  .accordion-problem {
    margin-bottom: 6px;  /* Minimal margin between accordions */
    border-radius: 10px;
  }
  
  .accordion-header {
    padding: 14px 6px;  /* Minimal side padding */
    font-size: 17px;
    min-height: 60px;
  }
  
  .progress-summary {
    font-size: 16px;
  }
  
  .accordion-body {
    padding: 0 6px;  /* Minimal side padding */
  }
  
  .accordion-problem.open .accordion-body {
    padding: 8px 6px;  /* Minimal side padding when open */
  }
  
  /* Minimal padding on panels */
  .panel {
    padding: 6px;  /* Minimal padding */
    margin-bottom: 4px;
    border-radius: 8px;
  }
  
  /* Minimal padding on steps */
  .step {
    padding: 6px;  /* Minimal padding */
    font-size: 17px;
  }
  
  .step-description {
    padding: 10px;
    font-size: 17px;
    line-height: 1.6;
    margin-bottom: 8px;
  }
  
  /* BIGGER MOBILE INPUT BUTTONS - NEARLY FULL WIDTH */
  .input-btn {
    padding: 16px 8px;
    min-height: 60px;
    font-size: 19px;
    border-radius: 6px;
    border-width: 1.5px;
    font-weight: 600;
  }
  
  .input-btn.navigation {
    font-size: 17px;
    min-height: 60px;
  }
  
  /* 5 COLUMN GRID - MINIMAL GAPS */
  .button-grid {
    grid-template-columns: repeat(5, 1fr) !important;
    gap: 3px !important;  /* Minimal gap for aesthetics */
    margin: 0 !important;
    padding: 0 !important;
  }
  
  /* BIGGER KEYBOARD BUTTONS */
  .input-btn.keyboard-activate,
    min-height: 80px;
    grid-column: span 3;
    font-size: 14px;
    box-shadow: 0 4px 12px rgba(145, 234, 102, 0.5);
    padding: 12px 8px;
  }

  .input-btn.keyboard-lock {
    min-height: 80px;
    grid-column: span 2;
    font-size: 14px;
    box-shadow: 0 4px 12px rgba(145, 234, 102, 0.5);
    padding: 12px 8px;
  }
  
  .input-btn.keyboard-activate svg,
  .input-btn.keyboard-lock svg {
    width: 36px;
    height: 36px;
  }
  
  .input-btn.keyboard-activate span,
  .input-btn.keyboard-lock span {
    font-size: 12px;
    margin-top: 2px;
  }
  
  /* Larger math input field */
  .math-input {
    min-height: 65px;
    padding: 14px;
    font-size: 22px;
    border-width: 3px;
  }
  
  /* Larger MathQuill fields */
  .mq-editable-field {
    font-size: 22px !important;
    min-height: 65px;
    padding: 14px !important;
  }
  
  /* Ensure math containers scroll smoothly on mobile */
  .math-input,
  .mq-editable-field,
  .step-description,
  .problem-description,
  #freestyleProblemDisplay,
  .step-feedback {
    -webkit-overflow-scrolling: touch;  /* Smooth scrolling on iOS */
  }
  
  /* Larger scrollbar on mobile for easier dragging */
  .math-input::-webkit-scrollbar,
  .mq-editable-field::-webkit-scrollbar,
  .step-description::-webkit-scrollbar,
  .problem-description::-webkit-scrollbar,
  #freestyleProblemDisplay::-webkit-scrollbar,
  .step-feedback::-webkit-scrollbar,
  .attempts-history::-webkit-scrollbar {
    height: 8px;  /* Larger on mobile */
  }
  
  /* Larger action buttons */
  .btn {
    padding: 18px 20px;
    font-size: 19px;
    border-radius: 10px;
    margin-bottom: 8px;
    min-height: 60px;
    font-weight: 600;
  }
  
  /* Larger feedback text */
  .step-feedback {
    font-size: 17px;
    padding: 14px;
    margin-top: 14px;
  }
  
  /* Larger attempts history */
  .attempts-history {
    font-size: 16px;
    padding: 14px;
    margin-top: 16px;
  }
  
  /* Larger nav items in sidebar */
  .nav-item {
    padding: 16px 18px;
    font-size: 18px;
    margin-bottom: 8px;
  }
  
  .nav-icon {
    font-size: 22px;
    margin-right: 14px;
  }
  
  /* Larger textarea */
  textarea {
    min-height: 150px;
    padding: 14px;
    font-size: 16px;
  }
  
  /* Larger file input */
  input[type="file"] {
    padding: 16px;
    font-size: 16px;
  }
  
  /* Optimize storage indicator for mobile */
  .storage-indicator {
    bottom: 12px;
    right: 12px;
    padding: 12px 16px;
    font-size: 15px;
  }
  
  /* Larger loading overlay text */
  #loadingOverlay {
    font-size: 18px;
  }
  
  .spinner {
    width: 70px;
    height: 70px;
    border-width: 5px;
  }
  
  /* Optimize problem set info on mobile */
  #problemSetInfo {
    font-size: 17px;
  }
  
  #currentProblemSetDescription {
    font-size: 16px;
  }
  
  #currentProblemSetUuid {
    font-size: 14px;
    padding: 10px;
  }
}

@media (min-width: 769px) {
  .menu-btn,
  .sidebar-overlay {
    display: none !important;
  }
}
/* Keyboard Accordions */
.keyboard-accordion {
  border: 2px solid #e2e8f0;
  border-radius: 8px;
  overflow: hidden;
  background: #fff;
}

.keyboard-accordion-header {
  background: #f0f4ff;
  padding: 12px 14px;
  cursor: pointer;
  font-weight: 600;
  display: flex;
  justify-content: space-between;
  align-items: center;
  transition: all 0.2s ease;
  font-size: 15px;
}

.keyboard-accordion-header:hover {
  background: #dbeafe;
}

.keyboard-accordion.open .keyboard-accordion-header {
  background: #dbeafe;
  border-bottom: 2px solid #e2e8f0;
}

.keyboard-accordion-body {
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.3s ease;
  background: #fafbfc;
}

.keyboard-accordion.open .keyboard-accordion-body {
  max-height: 500px;
}

.keyboard-accordion-icon {
  font-size: 14px;
  transition: transform 0.3s ease;
}

.keyboard-accordion.open .keyboard-accordion-icon {
  transform: rotate(180deg);
}

/* Mobile adjustments */
@media (max-width: 768px) {
  .keyboard-accordion-header {
    padding: 14px 16px;
    font-size: 16px;
  }
}
      /* Image Viewer Modal */
#imageViewerModal {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.95);
  z-index: 10000;
  overflow: hidden;
}

#imageViewerModal.active {
  display: flex;
  flex-direction: column;
}

.image-viewer-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px;
  background: rgba(0, 0, 0, 0.8);
  color: white;
}

.image-viewer-controls {
  display: flex;
  gap: 12px;
  align-items: center;
}

.image-viewer-btn {
  background: rgba(255, 255, 255, 0.2);
  border: 1px solid rgba(255, 255, 255, 0.3);
  color: white;
  padding: 8px 16px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 16px;
  font-weight: 600;
  transition: all 0.2s;
}

.image-viewer-btn:hover {
  background: rgba(255, 255, 255, 0.3);
}

.image-viewer-btn:active {
  transform: scale(0.95);
}

.zoom-slider-container {
  display: flex;
  align-items: center;
  gap: 8px;
  min-width: 200px;
}

.zoom-slider {
  flex: 1;
  height: 6px;
  border-radius: 3px;
  background: rgba(255, 255, 255, 0.2);
  outline: none;
  -webkit-appearance: none;
}

.zoom-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: #0b6efd;
  cursor: pointer;
  border: 2px solid white;
}

.zoom-slider::-moz-range-thumb {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: #0b6efd;
  cursor: pointer;
  border: 2px solid white;
}

.zoom-level {
  color: white;
  font-size: 14px;
  min-width: 60px;
  text-align: right;
  font-weight: 600;
}

.image-viewer-content {
  flex: 1;
  overflow: auto;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: grab;
  -webkit-overflow-scrolling: touch;
}

.image-viewer-content:active {
  cursor: grabbing;
}

.image-viewer-img {
  display: block;
  max-width: none;
  height: auto;
  transition: transform 0.1s ease-out;
  user-select: none;
  -webkit-user-select: none;
}

/* Mobile optimizations */
@media (max-width: 768px) {
  .image-viewer-header {
    flex-wrap: wrap;
    gap: 12px;
  }

  .image-viewer-controls {
    width: 100%;
    flex-wrap: wrap;
  }

  .zoom-slider-container {
    width: 100%;
    min-width: unset;
  }

  .image-viewer-btn {
    padding: 10px 14px;
    font-size: 15px;
  }
}

/* Clickable image indicators */
.img-inline {
  cursor: pointer;
  transition: transform 0.2s, box-shadow 0.2s;
}

.img-inline:hover {
  transform: scale(1.02);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
}
    </style>
  </head>
  <body>
    <!-- Loading Overlay -->
    <div id="loadingOverlay">
      <div class="spinner"></div>
      <div class="loading-text">‚ö° Fast Loading Problem Solver...</div>
      <div id="loadingStatus">
        <div>‚è≥ Starting up...</div>
      </div>
    </div>

    <!-- Mobile Menu Button -->
    <button class="menu-btn" id="menuBtn">‚ò∞</button>

    <!-- Sidebar Overlay -->
    <div class="sidebar-overlay" id="sidebarOverlay"></div>

    <!-- Main App Container -->
    <div class="app-container">
      <!-- Sidebar -->
      <aside class="sidebar" id="sidebar">
        <div class="sidebar-header">
          <h3>üßÆ Problem Solver</h3>
        </div>

        <!-- Problem Set Info -->
        <div id="problemSetInfo" class="panel" style="display: none">
          <div style="font-size: 16px; font-weight: 700; margin-bottom: 8px">Problem Set</div>
          <div id="currentProblemSetDescription" style="font-size: 14px; color: #64748b; margin-bottom: 8px">
            No problem set loaded
          </div>
          <div
            id="currentProblemSetUuid"
            style="
              font-family: monospace;
              font-size: 12px;
              color: #0369a1;
              background: #f0f9ff;
              padding: 8px;
              border-radius: 6px;
            ">
            No UUID
          </div>
        </div>

        <!-- Navigation -->
<nav class="nav-menu">
  <div class="nav-item active" data-page="problems">
    <span class="nav-icon">üßÆ</span>
    <span>Work on Problems</span>
  </div>
  <div class="nav-item" data-page="freestyle">
    <span class="nav-icon">‚úèÔ∏è</span>
    <span>Freestyle Practice</span>
  </div>
  <div class="nav-item" data-page="load">
    <span class="nav-icon">üìÇ</span>
    <span>Load Problem Set</span>
  </div>
  <div class="nav-item" data-page="export">
    <span class="nav-icon">üì§</span>
    <span>Submit Progress</span>
  </div>
  <div class="nav-item" data-page="settings">
    <span class="nav-icon">‚öôÔ∏è</span>
    <span>Settings</span>
  </div>
</nav>
</aside>

      <!-- Main Content -->
      <main class="main-content">
        <!-- Problems Page -->
        <div id="problemsPage" class="page active">
          <div id="initialLoadPanel" class="panel">
            <h3>üìÇ Load Problem Set</h3>
            <p>No problems loaded. Use the sidebar to load a problem set.</p>
          </div>
          <div id="solveProblemsContainer"></div>
        </div>
        <!-- Free Style Practice Page -->
        <div id="freestylePage" class="page">
          <div class="panel">
            <h3>‚úèÔ∏è Free Style Practice</h3>
            <p style="color: #64748b; margin-bottom: 16px">
              Create and solve your own problem. Enter a mathematical expression, then try to solve it!
            </p>

            <div style="margin-bottom: 20px">
              <label>üìù Problem Expression</label>
              <div
                style="
                  overflow-x: auto;
                  overflow-y: hidden;
                  max-width: 100%;
                  -webkit-overflow-scrolling: touch;
                  border: 2px solid #e6eef8;
                  border-radius: 8px;
                  padding: 10px;
                  background: #fff;
                ">
                <div
                  id="freestyleProblemInput"
                  class="math-input"
                  style="min-height: 60px; border: none; padding: 0"></div>
              </div>
              <button id="setFreestyleProblem" class="btn" style="margin-top: 10px">Set Problem</button>
            </div>
            <div id="freestyleSolveArea" style="display: none">
              <hr style="margin: 20px 0; border: none; border-top: 2px solid #e5e7eb" />
              <div style="display: flex; flex-direction: column; gap: 8px; margin-top: 16px">
                <button id="freestyleReset" class="btn ghost" style="background: #dc2626; color: #fff">
                  Reset Problem
                </button>
                <button id="freestyleFinalize" class="btn ghost" disabled>Finalize Solution</button>
                <button id="freestyleSubmit" class="btn">Submit Attempt</button>
              </div>
              <div style="background: #f0fdf4; padding: 16px; border-radius: 8px; margin-bottom: 16px">
                <div style="font-weight: 700; margin-bottom: 8px">Problem to Solve:</div>
                <div id="freestyleProblemDisplay" style="font-size: 20px"></div>
              </div>

              <div style="margin-bottom: 20px">
                <label>üéØ Your Solution</label>
                <div
                  style="
                    overflow-x: auto;
                    overflow-y: hidden;
                    max-width: 100%;
                    -webkit-overflow-scrolling: touch;
                    border: 2px solid #e6eef8;
                    border-radius: 8px;
                    padding: 10px;
                    background: #fff;
                  ">
                  <div
                    id="freestyleAnswerInput"
                    class="math-input"
                    style="min-height: 60px; border: none; padding: 0"></div>
                </div>
                <!-- ‚úÖ FEEDBACK AREA - THIS IS THE CRITICAL PART -->
                <div id="freestyleFeedback" style="margin-top: 16px; min-height: 20px"></div>
              </div>
            </div>
            <!-- Comprehensive Keyboard - MULTIPLE ACCORDIONS -->
            <div style="margin-top: 16px">
              <div style="font-weight: 600; margin-bottom: 8px; font-size: 15px">‚å®Ô∏è Input Keyboard:</div>

              <!-- Numbers & Basic Accordion -->
              <div class="keyboard-accordion" style="margin-bottom: 6px">
                <div class="keyboard-accordion-header" data-target="numbersBody">
                  <span>üî¢ Numbers & Basic</span>
                  <span class="keyboard-accordion-icon">‚ñº</span>
                </div>
                <div id="numbersBody" class="keyboard-accordion-body">
                  <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 3px; padding: 8px">
                    <button class="input-btn digit" data-action="7">7</button>
                    <button class="input-btn digit" data-action="8">8</button>
                    <button class="input-btn digit" data-action="9">9</button>
                    <button class="input-btn special" data-action="^" id="freestylePower"></button>
                    <button class="input-btn special" data-action="_" id="freestyleSubscript"></button>
                    <button class="input-btn digit" data-action="4">4</button>
                    <button class="input-btn digit" data-action="5">5</button>
                    <button class="input-btn digit" data-action="6">6</button>
                    <button class="input-btn operator" data-action="/">√∑</button>
                    <button class="input-btn operator" data-action="\\times">√ó</button>
                    <button class="input-btn digit" data-action="1">1</button>
                    <button class="input-btn digit" data-action="2">2</button>
                    <button class="input-btn digit" data-action="3">3</button>
                    <button class="input-btn operator" data-action="-">‚àí</button>
                    <button class="input-btn operator" data-action="+">+</button>
                    <button class="input-btn special" data-action="(">(</button>
                    <button class="input-btn digit" data-action="0">0</button>
                    <button class="input-btn special" data-action=")">)</button>
                    <button class="input-btn special" data-action=".">.</button>
                    <button class="input-btn special" data-action="=">=</button>
                    <button class="input-btn special" data-action="[">[</button>
                    <button class="input-btn special" data-action=",">,</button>
                    <button class="input-btn special" data-action="]">]</button>
                    <button class="input-btn symbol" data-action="x">x</button>
                    <button class="input-btn delete" data-action="BACKSPACE">‚å´</button>
                    <button class="input-btn navigation" data-action="MOVE_LEFT" id="freestyleMoveLeft"></button>
                    <button class="input-btn navigation" data-action="MOVE_RIGHT" id="freestyleMoveRight"></button>
                    <button class="input-btn navigation" data-action="SELECT_LEFT" id="freestyleSelectLeft"></button>
                    <button class="input-btn navigation" data-action="SELECT_RIGHT" id="freestyleSelectRight"></button>
                    <button class="input-btn delete" data-action="CLEAR">Clear</button>
                  </div>
                </div>
              </div>

              <!-- Algebra Accordion -->
<div class="keyboard-accordion" style="margin-bottom: 6px">
  <div class="keyboard-accordion-header" data-target="algebraBody">
    <span>üî§ Algebra</span>
    <span class="keyboard-accordion-icon">‚ñº</span>
  </div>
  <div id="algebraBody" class="keyboard-accordion-body">
    <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 3px; padding: 8px">
      <button class="input-btn symbol" data-action="x">x</button>
      <button class="input-btn symbol" data-action="y">y</button>
      <button class="input-btn symbol" data-action="z">z</button>
      <button class="input-btn symbol" data-action="a">a</button>
      <button class="input-btn symbol" data-action="b">b</button>
      
      <button class="input-btn symbol" data-action="c">c</button>
      <button class="input-btn symbol" data-action="n">n</button>
      <button class="input-btn symbol" data-action="i">i</button>
      <button class="input-btn symbol" data-action="j">j</button>
      <button class="input-btn symbol" data-action="k">k</button>
      
      <button class="input-btn special" data-action="\\frac">√∑(fr)</button>
      <button class="input-btn special" data-action="|">|x|</button>
      <button class="input-btn operator" data-action="\\times">√ó</button>
      <button class="input-btn operator" data-action="/">√∑</button>
      <button class="input-btn operator" data-action="+">+</button>
      
      <button class="input-btn operator" data-action="-">‚àí</button>
      <button class="input-btn special" data-action="\\sqrt">‚àö</button>
      <button class="input-btn special" data-action="!">!</button>
      <button class="input-btn special" data-action="\\{" style="grid-column: span 1;">{</button>
      <button class="input-btn special" data-action="\\}" style="grid-column: span 1;">}</button>
    </div>
  </div>
</div>

              <!-- Calculus Accordion -->
<div class="keyboard-accordion" style="margin-bottom: 6px">
  <div class="keyboard-accordion-header" data-target="calculusBody">
    <span>‚à´ Calculus</span>
    <span class="keyboard-accordion-icon">‚ñº</span>
  </div>
  <div id="calculusBody" class="keyboard-accordion-body">
    <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 3px; padding: 8px">
      <button class="input-btn operator" data-action="SEQ:d,/,d,x">d/dx</button>
      <button class="input-btn operator" data-action="\\int">‚à´</button>
      <button class="input-btn operator" data-action="\\sum">Œ£</button>
      <button class="input-btn operator" data-action="\\prod">‚àè</button>
      <button class="input-btn operator" data-action="\\lim">lim</button>
      
      <button class="input-btn operator" data-action="SEQ:\\lim,_,x,\\to,0,{Right},{Right}">lim‚Üí0</button>
      <button class="input-btn operator" data-action="SEQ:\\lim,_,x,\\to,\\infty,{Right},{Right}">lim‚Üí‚àû</button>
      <button class="input-btn operator" data-action="SEQ:\\lim,_,n,\\to,\\infty,{Right},{Right}">lim(n‚Üí‚àû)</button>
      <button class="input-btn operator" data-action="\\to">‚Üí</button>
      <button class="input-btn operator" data-action="\\infty">‚àû</button>
      
      <button class="input-btn operator" data-action="\\partial">‚àÇ</button>
      <button class="input-btn operator" data-action="e">e</button>
      <button class="input-btn operator" data-action="\\exp">exp</button>
    </div>
  </div>
</div>

              <!-- Trigonometry Accordion -->
              <div class="keyboard-accordion" style="margin-bottom: 6px">
                <div class="keyboard-accordion-header" data-target="trigBody">
                  <span>üìä Trigonometry</span>
                  <span class="keyboard-accordion-icon">‚ñº</span>
                </div>
                <div id="trigBody" class="keyboard-accordion-body">
                  <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 3px; padding: 8px">
                    <button class="input-btn operator" data-action="\\sin">sin</button>
                    <button class="input-btn operator" data-action="\\cos">cos</button>
                    <button class="input-btn operator" data-action="\\tan">tan</button>
                    <button class="input-btn operator" data-action="\\cot">cot</button>
                    <button class="input-btn operator" data-action="\\sec">sec</button>
                    <button class="input-btn operator" data-action="\\csc">csc</button>
                    <button class="input-btn operator" data-action="\\arcsin">asin</button>
                    <button class="input-btn operator" data-action="\\arccos">acos</button>
                    <button class="input-btn operator" data-action="\\arctan">atan</button>
                    <button class="input-btn operator" data-action="SEQ:^,\\circ,{Right}">deg&deg;</button>
                    <button class="input-btn operator" data-action="\\ln">ln</button>
                    <button class="input-btn symbol" data-action="\\pi">œÄ</button>
                  </div>
                </div>
              </div>

              <!-- Matrix & Row Operations Accordion -->
<div class="keyboard-accordion" style="margin-bottom: 6px">
  <div class="keyboard-accordion-header" data-target="matrixBody">
    <span>‚¨ú Matrix & Row Operations</span>
    <span class="keyboard-accordion-icon">‚ñº</span>
  </div>
  <div id="matrixBody" class="keyboard-accordion-body">
    <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 3px; padding: 8px">
      <!-- Basic Matrix Notation -->
      <button class="input-btn special" data-action="[">[</button>
      <button class="input-btn special" data-action="]">]</button>
      <button class="input-btn special" data-action=",">,</button>
      <button class="input-btn special" data-action="\\\\">\</button>
      <button class="input-btn special" data-action="&">&</button>
      
      <!-- Matrix Operations -->
      <button class="input-btn operator" data-action="\\det">det</button>
      <button class="input-btn special" data-action="^T">[&nbsp;]<sup><sup>T</sup></sup></button>
      <button class="input-btn special" data-action="^{-1}">[&nbsp;]<sup><sup>-1</sup></sup></button>
      <button class="input-btn operator" data-action="\\cdot">¬∑</button>
      <button class="input-btn operator" data-action="\\times">√ó</button>
      
      <!-- Row Operation Buttons -->
      <button class="input-btn symbol" data-action="R">R</button>
      <button class="input-btn special" data-action="_" id="freestyleSubscriptMatrix"></button>
      <button class="input-btn special" data-action="|">|</button>
      <button class="input-btn operator" data-action="\\to">‚Üí</button>
      <button class="input-btn operator" data-action="\\leftarrow">‚Üê</button>
      <button class="input-btn operator" data-action="\\leftrightarrow" style="grid-column: span 1;">‚Üî</button>
      
      <!-- Division for Row Scaling -->
      <button class="input-btn operator" data-action="/">√∑</button>
      <button class="input-btn operator" data-action="+">+</button>
      <button class="input-btn operator" data-action="-">‚àí</button>
      
      <!-- Identity and Zero matrices -->
      <button class="input-btn operator" data-action="I">I</button>
      <button class="input-btn operator" data-action="O">O</button>
      <button class="input-btn operator" data-action="\\text{rref}">rref</button>
      <button class="input-btn operator" data-action="\\text{rank}">rank</button>
      <button class="input-btn operator" data-action="\\text{tr}">tr</button>
    </div>
  </div>
</div>


              <!-- Greek Letters Accordion -->
              <div class="keyboard-accordion" style="margin-bottom: 6px">
                <div class="keyboard-accordion-header" data-target="greekBody">
                  <span>üá¨üá∑ Greek Letters</span>
                  <span class="keyboard-accordion-icon">‚ñº</span>
                </div>
                <div id="greekBody" class="keyboard-accordion-body">
                  <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 3px; padding: 8px">
                    <button class="input-btn symbol" data-action="\\alpha">Œ±</button>
                    <button class="input-btn symbol" data-action="\\beta">Œ≤</button>
                    <button class="input-btn symbol" data-action="\\gamma">Œ≥</button>
                    <button class="input-btn symbol" data-action="\\delta">Œ¥</button>
                    <button class="input-btn symbol" data-action="\\theta">Œ∏</button>
                    <button class="input-btn symbol" data-action="\\lambda">Œª</button>
                    <button class="input-btn symbol" data-action="\\sigma">œÉ</button>
                    <button class="input-btn symbol" data-action="\\phi">œÜ</button>
                    <button class="input-btn symbol" data-action="\\omega">œâ</button>
                    <button class="input-btn symbol" data-action="\\mu">Œº</button>
                    <button class="input-btn symbol" data-action="\\rho">œÅ</button>
                    <button class="input-btn symbol" data-action="\\tau">œÑ</button>
                  </div>
                </div>
              </div>
              
              <!-- Comparison & Logic Accordion -->
<div class="keyboard-accordion" style="margin-bottom: 6px">
  <div class="keyboard-accordion-header" data-target="comparisonBody">
    <span>‚öñÔ∏è Comparison & Logic</span>
    <span class="keyboard-accordion-icon">‚ñº</span>
  </div>
  <div id="comparisonBody" class="keyboard-accordion-body">
    <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 3px; padding: 8px">
      <!-- Comparison operators -->
      <button class="input-btn operator" data-action="=">=</button>
      <button class="input-btn operator" data-action="\\neq">‚â†</button>
      <button class="input-btn operator" data-action="\\lt">&lt;</button>
      <button class="input-btn operator" data-action="\\gt">&gt;</button>
      <button class="input-btn operator" data-action="\\leq">‚â§</button>
      
      <button class="input-btn operator" data-action="\\geq">‚â•</button>
      <button class="input-btn operator" data-action="\\approx">‚âà</button>
      <button class="input-btn operator" data-action="\\equiv">‚â°</button>
      <button class="input-btn operator" data-action="\\propto">‚àù</button>
      <button class="input-btn operator" data-action="\\pm">¬±</button>
      
      <!-- Set theory -->
      <button class="input-btn operator" data-action="\\in">‚àà</button>
      <button class="input-btn operator" data-action="\\notin">‚àâ</button>
      <button class="input-btn operator" data-action="\\subset">‚äÇ</button>
      <button class="input-btn operator" data-action="\\subseteq">‚äÜ</button>
      <button class="input-btn operator" data-action="\\cup">‚à™</button>
      
      <button class="input-btn operator" data-action="\\cap">‚à©</button>
      <button class="input-btn operator" data-action="\\emptyset">‚àÖ</button>
      <button class="input-btn operator" data-action="\\forall">‚àÄ</button>
      <button class="input-btn operator" data-action="\\exists">‚àÉ</button>
      <button class="input-btn operator" data-action="\\therefore">‚à¥</button>
    </div>
  </div>
</div>

                <!-- Navigation & Controls Accordion -->
                <div style="display:none" class="keyboard-accordion" style="margin-bottom: 6px">
                  <div class="keyboard-accordion-header" data-target="hiddenBody">
                    <span>üéÆ Navigation & Controls</span>
                    <span class="keyboard-accordion-icon">‚ñº</span>
                  </div>
                  <div id="hiddenBody" class="keyboard-accordion-body">
                    <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 3px; padding: 8px">
                      <button class="input-btn navigation" data-action="MOVE_LEFT" id="freestyleMoveLeft"></button>
                      <button class="input-btn navigation" data-action="MOVE_RIGHT" id="freestyleMoveRight"></button>
                      <button class="input-btn navigation" data-action="SELECT_LEFT" id="freestyleSelectLeft"></button>
                      <button class="input-btn navigation" data-action="SELECT_RIGHT" id="freestyleSelectRight"></button>
                      <button class="input-btn delete" data-action="BACKSPACE" style="grid-column: span 2">‚å´ Back</button>
                      <button class="input-btn delete" data-action="CLEAR" style="grid-column: span 2">Clear</button>
                    </div>
                  </div>
                </div>
              <!-- ‚úÖ HISTORY AREA - THIS IS THE CRITICAL PART -->
              <div id="freestyleHistory" style="margin-top: 16px; min-height: 20px"></div>
            </div>
          </div>
        </div>

        <!-- Load Page -->
        <div id="loadPage" class="page">
          <div class="panel">
            <h3>üìÇ Load Problem Set</h3>

            <label>Load Problem Set From File</label>
            <input type="file" id="uploadFile" accept=".txt,text/plain" />

            <div style="text-align: center; margin: 12px 0; color: #94a3b8">‚Äî OR ‚Äî</div>

            <label>üìã Paste JSON</label>
            <textarea id="pasteJson" placeholder="Paste base64-compressed JSON"></textarea>
            <button id="loadJsonBtn" class="btn">üìÇ Load Problem Set From Pasted JSON</button>
          </div>
        </div>

        <!-- Export Page -->
        <div id="exportPage" class="page">
          <div class="panel">
            <h3>üì§ Submit Progress</h3>
            <h4 style="text-align: center;">Teacher Number&nbsp;&nbsp;&nbsp;Student Number</h4>
            <div style="align-items: center;justify-content: center;height:50px;margin-top: 5px;display:flex">
              <input type="text" style="font-size:1.2rem;text-align: center;" id="teacherPhoneNumber" placeholder="Enter phone number" value="+628161342820" />
              <input type="text" style="font-size:1.2rem;text-align: center;" id="student PhoneNumber" placeholder="Enter phone number" value="+628161342820" />
            </div>
            <div style="align-items: center;justify-content: center;height:40px;margin-top: 5px;display:flex">
            
              <a id="shareWhatsappProgressBtn" href="#" >
                <img src="https://upload.wikimedia.org/wikipedia/commons/6/6b/WhatsApp.svg" alt="WhatsApp" width="40" height="40">
              </a>

            <a id="exportTelegramBtn" href="#" onclick="window.open('https://t.me/share/url?text=' + encodeURIComponent(document.getElementById('msg').value), '_blank'); return false;">
                <img src="https://upload.wikimedia.org/wikipedia/commons/8/82/Telegram_logo.svg" width="40" height="40" alt="Telegram">
              </a>
            </div>
            <button id="exportProgressBtn" class="btn" style="background: #10b981">üì§ Export to File</button>
          </div>
        </div>

        <!-- Settings Page -->
        <div id="settingsPage" class="page">
          <div class="panel">
            <h3>‚öôÔ∏è Settings</h3>
            
            <div style="margin-bottom:16px;padding:12px;background:#f0f9ff;border-radius:8px;border:2px solid #bfdbfe;">
              <div style="font-weight:600;margin-bottom:8px;">üíæ Browser Cache Status</div>
              <div style="font-size:13px;color:#6b7280;margin-bottom:8px;">
                Pyodide is cached after first load. Second load will be lightning fast! ‚ö°
              </div>
            </div>
            
            <button id="clearStorageBtn" class="btn ghost" style="background: #dc2626; color: #fff">
              üóëÔ∏è Clear All Data
            </button>
            <button id="clearCacheBtn" class="btn ghost" style="background: #f59e0b; color: #fff; margin-top: 8px;">
              üóëÔ∏è Clear Browser Cache
            </button>
          </div>
        </div>
      </main>
    </div>

    <!-- Storage Indicator -->
    <div id="storageIndicator" class="storage-indicator">üíæ Saved</div>

    <!-- ‚ö° Python Script - Just paste your original code here! -->
<script type="py">
from pyscript import document, window
from pyodide.ffi import create_proxy
import json, html, re, base64, uuid

class MathParser:
    """Handles LaTeX parsing, structural comparison, and error popups"""

    GRAMMAR = r"""
start: matrix_ops
   | expr

?expr: sum

?sum: sum "+" product   -> add
  | sum "-" product   -> sub
  | product

?product: scalar matrix                 -> scalar_matrix_mul
      | scalar matrix_env             -> scalar_matrix_mul
      | product ("*" | "\\cdot" | "\\times" | "\\ast") implicit   -> mul
      | product "/" implicit                                      -> div
      | implicit

?implicit: implicit power        -> implicit_mul
       | power

?power: "-" power                -> neg
    | atom_degree              -> atom_to_degree
    | atom "^" power           -> power
    | atom

?atom: NUMBER                    -> number
   | derivative_function
   | partial_derivative_function
   | trig_function
   | log_function
   | limit
   | fraction
   | abs_function
   | matrix
   | matrix_env
   | "(" expr ")"              -> paren_expr
   | "{" expr "}"              -> braces_expr
   | PI                        -> pi_symbol
   | INFTY                     -> infty_symbol
   | SYMBOL                    -> symbol
   | row_op

scalar: NUMBER | SYMBOL

trig_function: TRIG_NAME "(" expr ")"    -> trig_func

log_function: LOG_NAME "(" expr ")"      -> log_func

limit: "\\lim" "_" "{" SYMBOL "\\to" expr "}" expr -> limit_expr

derivative_function: "__derivative" "(" SYMBOL "," expr ")" -> derivative_func

partial_derivative_function: "__partial_derivative" "(" SYMBOL "," expr ")" -> partial_derivative_func

fraction: "\\frac" "{" expr "}" "{" expr "}" -> frac

abs_function: "\\left" "|" expr "\\right" "|"     -> abs_func
          | "|" expr "|"                          -> abs_func

atom_degree: atom "^" degree_expr

degree_expr: "{" CIRC "}"

matrix: "[" matrix_rows "]" -> matrix_rows
matrix_rows: row ("," row)* -> matrix_rows
row: "[" elements "]" -> row
elements: expr ("," expr)* -> elements

matrix_env: "\\begin" "{" /(bmatrix|pmatrix|matrix)/ "}" matrix_env_body "\\end" "{" /(bmatrix|pmatrix|matrix)/ "}" -> matrix_env

matrix_env_body: matrix_env_row ( "\\\\" matrix_env_row )*
matrix_env_row: expr ( "&" expr )*

matrix_ops: matrix ("|" row_op)+ -> matrix_apply_ops

row_op: "R_" INT arrow row_expr                 -> row_replace
    | "R_" INT swap_arrow "R_" INT            -> row_swap

arrow: "\\to" | "\\leftarrow"
swap_arrow: "\\leftrightarrow"

row_expr: "R_" INT                     -> row_reference
       | expr "R_" INT               -> row_scale
       | "R_" INT op expr "R_" INT   -> row_combine

op: "+" | "-"

TRIG_NAME.2: "\\sin" | "\\cos" | "\\tan" | "\\cot" | "\\sec" | "\\csc"
         | "\\arcsin" | "\\arccos" | "\\arctan"
LOG_NAME.2: "\\log" | "\\ln" | "\\exp"
LIM.2: "\\lim"
NUMBER: /[+-]?\d+(\.\d*)?|\.\d+/
INT: /\d+/
PI.2: "\\pi"
INFTY.2: "\\infty"
SYMBOL: /\\?(?!(?:sin|cos|tan|cot|sec|csc|arcsin|arccos|arctan|log|ln|exp|frac|left|right|begin|end|pi|infty|lim|lvert|rvert)(?![a-zA-Z0-9]))[a-zA-Z][a-zA-Z0-9]*/
CIRC: "\\circ"

%import common.WS_INLINE
%ignore WS_INLINE
"""
    
    def __init__(self):
        from lark import Lark
        self.parser = Lark(self.GRAMMAR, parser="earley", start="start")
        self.transformer = self._create_transformer()

    def _preprocess_derivatives(self, latex_str):
        """
        Rewrites \frac{d}{dx}(...) and \frac{\partial}{\partial x}(...)
        patterns into unique function calls before parsing.
        """
        import re

        # 1. Handle total derivatives: \frac{d}{dx}(...)
        total_derivative_pattern = re.compile(r"\\frac\{d\}\{d([a-zA-Z]+)\}\(([^)]+)\)")
        total_replacement = r"__derivative(\1, \2)"
        processed_str = total_derivative_pattern.sub(total_replacement, latex_str)

        # 2. Handle partial derivatives: \frac{\partial}{\partial x}(...)
        # This regex is slightly different to handle the \partial command and optional space.
        partial_derivative_pattern = re.compile(r"\\frac\{\\partial\}\{\\partial\s*([a-zA-Z]+)\}\(([^)]+)\)")
        partial_replacement = r"__partial_derivative(\1, \2)"
        final_str = partial_derivative_pattern.sub(partial_replacement, processed_str)

        return final_str

    def _show_error_popup(self, message):
        """Display error popup with close button - optimized for mobile"""
        safe_msg = message.replace("`", "'").replace("\\", "\\\\").replace("\n", "\\n")
        js_code = f"""
            (function(){{
                let existing = document.querySelector('#parseErrorPopup');
                if(existing) existing.remove();

                let popup = document.createElement('div');
                popup.id = 'parseErrorPopup';

                // Detect if mobile/small screen
                let isMobile = window.innerWidth <= 768;

                if(isMobile) {{
                    // Mobile styles - fullscreen-like
                    popup.style.cssText = `
                        position:fixed;
                        top:0;
                        left:0;
                        right:0;
                        bottom:0;
                        background:#f8fafc;
                        color:#0f172a;
                        font-family:monospace;
                        padding:60px 16px 16px 16px;
                        border:none;
                        border-radius:0;
                        box-shadow:none;
                        white-space:pre-wrap;
                        z-index:9999;
                        overflow:auto;
                        -webkit-overflow-scrolling:touch;
                    `;
                }} else {{
                    // Desktop styles - centered dialog
                    popup.style.cssText = `
                        position:fixed;
                        top:50%;
                        left:50%;
                        transform:translate(-50%, -50%);
                        background:#f8fafc;
                        color:#0f172a;
                        font-family:monospace;
                        padding:24px 24px 16px 24px;
                        border:2px solid #ef4444;
                        border-radius:12px;
                        box-shadow:0 12px 40px rgba(0,0,0,0.2);
                        white-space:pre;
                        z-index:9999;
                        max-width:650px;
                        max-height:70vh;
                        overflow:auto;
                    `;
                }}

                let btn = document.createElement('button');
                btn.textContent = '‚úñ';
                btn.title = 'Close';

                if(isMobile) {{
                    // Mobile close button - larger and top-left
                    btn.style.cssText = `
                        position:fixed;
                        top:12px;
                        right:12px;
                        width:44px;
                        height:44px;
                        border:none;
                        background:#ef4444;
                        color:#fff;
                        font-size:24px;
                        font-weight:bold;
                        cursor:pointer;
                        line-height:1;
                        border-radius:8px;
                        box-shadow:0 4px 12px rgba(239,68,68,0.4);
                        z-index:10000;
                    `;
                }} else {{
                    // Desktop close button - small and subtle
                    btn.style.cssText = `
                        position:absolute;
                        top:8px;
                        right:10px;
                        border:none;
                        background:transparent;
                        color:#ef4444;
                        font-size:18px;
                        font-weight:bold;
                        cursor:pointer;
                        line-height:1;
                    `;
                }}
                btn.onclick = () => popup.remove();

                let title = document.createElement('div');
                title.textContent = '‚ö†Ô∏è Parse Error';

                if(isMobile) {{
                    title.style.cssText = `
                        font-size:22px;
                        font-weight:bold;
                        color:#ef4444;
                        margin-bottom:16px;
                        padding-right:50px;
                    `;
                }} else {{
                    title.style.cssText = `
                        font-size:18px;
                        font-weight:bold;
                        color:#ef4444;
                        margin-bottom:12px;
                    `;
                }}

                let content = document.createElement('div');
                content.textContent = `{safe_msg}`;

                if(isMobile) {{
                    content.style.cssText = `
                        font-size:14px;
                        line-height:1.6;
                        word-break:break-word;
                        padding-top:8px;
                    `;
                }} else {{
                    content.style.cssText = `
                        padding-top:8px;
                    `;
                }}

                popup.appendChild(btn);
                popup.appendChild(title);
                popup.appendChild(content);
                document.body.appendChild(popup);
            }})();
        """
        window.eval(js_code)

    def _preprocess_row_operations(self, latex_str):
        """
        Safe preprocessing: only apply row-operation regexes to the operation part.
        Normalizes matrix numbers separately so matrix content is not mangled.
        """
        import re

        # 0. Quick generic cleanups that are safe everywhere
        s = latex_str.replace(r'\ ', ' ')
        s = s.replace(r'\left(', '(').replace(r'\right)', ')')
        s = s.replace(r'\left[', '[').replace(r'\right]', ']')
        s = s.replace(r'\left\{', '{').replace(r'\right\}', '}')
        s = s.replace(r'\left|', '|').replace(r'\right|', '|')
        s = s.replace(r'\cdot', '*')

        # Split into matrix part and operations part.
        # Prefer explicit '|' split. If no pipe, attempt to split at arrow (\to or ->).
        if '|' in s:
            matrix_part, ops_part = s.split('|', 1)
        else:
            # attempt to split at first arrow occurrence
            m = re.search(r'(\\to|\\rightarrow|->|<-)','%s' % s)
            if m:
                # split so matrix_part includes everything before arrow, ops_part includes arrow+rest
                idx = m.start()
                matrix_part = s[:idx]
                ops_part = s[idx:]
            else:
                # nothing to do: treat entire string as matrix_part (no row op)
                matrix_part, ops_part = s, ''

        # -------------------------
        # Normalize matrix_part (do NOT run row-op rewrites here)
        # -------------------------
        # 1) collapse repeated spaces
        matrix_part = re.sub(r'\s+', ' ', matrix_part).strip()

        # 2) Remove stray spaces between minus and number/fraction inside matrix
        #    Examples: [0, - 1, - \frac{1}{2}] -> [0, -1, -\frac{1}{2}]
        matrix_part = re.sub(r'-\s+\\frac', r'-\\frac', matrix_part)          # - \frac -> -\frac
        matrix_part = re.sub(r'-\s+(\d)', r'-\1', matrix_part)                 # - 1 -> -1
        matrix_part = re.sub(r'(\{)\s+', r'\1', matrix_part)                  # remove space after { 
        matrix_part = re.sub(r'\s+(\})', r'\1', matrix_part)                  # remove space before }
        matrix_part = re.sub(r'\[\s+', '[', matrix_part)
        matrix_part = re.sub(r'\s+\]', ']', matrix_part)

        # 3) (Optional) convert simple LaTeX fractions in matrix to explicit form so parser sees them consistently
        #    e.g. replace \frac{1}{2} with (1/2) ‚Äî only inside matrix part
        #    If you prefer leaving \frac for parser, skip this.
        matrix_part = re.sub(r'\\frac\{([^{}]+)\}\{([^{}]+)\}', r'(\1/\2)', matrix_part)

        # -------------------------
        # Now operate on ops_part only (row-operation specific rewrites)
        # -------------------------
        ops = ops_part  # local alias for clarity

        if ops:
            # 1) Ensure there's a space after arrows so tokenizer can separate parts
            ops = re.sub(r'\\to(?=\S)', r'\\to ', ops)
            ops = re.sub(r'\\rightarrow(?=\S)', r'\\rightarrow ', ops)
            ops = re.sub(r'->(?=\S)', r'-> ', ops)
            ops = re.sub(r'<-(?=\S)', r'<- ', ops)

            # 2) Fix fractions with row reference in denominator: \frac{1}{2R_3} -> (1/2)R_3
            ops = re.sub(r'\\frac\{([^{}]+)\}\{\(?(\d+)\)?R_(\d+)\}', r'(\1/\2)R_\3', ops)

            # 3) Fix fractions before row reference: \frac{1}{2}R_ -> (1/2)R_
            ops = re.sub(r'\\frac\{([^{}]+)\}\{\(?([^{}]+?)\)?\}R_', r'(\1/\2)R_', ops)

            # 4) Negative fractions -\frac{...}R_ -> (-1/2)R_
            ops = re.sub(r'-\\frac\{([^{}]+)\}\{\(?([^{}]+?)\)?\}R_', r'(-\1/\2)R_', ops)

            # 5) Fix fractions in combines: R_2+\frac{1}{2}R_3 -> R_2+(1/2)R_3
            ops = re.sub(r'([+\-])\\frac\{([^{}]+)\}\{\(?([^{}]+?)\)?\}R_', r'\1(\2/\3)R_', ops)

            # 6) Remove outer wrapping parentheses from row scale expressions
            ops = re.sub(r'\((-?\([^)]+\)R_\d+)\)', r'\1', ops)
            ops = re.sub(
                r'(R_\d+\s*(?:\\to|\\rightarrow|->)\s*)\(([^()]+R_\d+)\)(?=\s*(?:\||$))',
                r'\1\2',
                ops
            )
            ops = re.sub(r'\((R_\d+)\)', r'\1', ops)

            # 7) Remove single-number parentheses before R_: (2)R_1 -> 2R_1; (-2)R_1 -> -2R_1
            ops = re.sub(r'\((\d+)\)R_', r'\1R_', ops)
            ops = re.sub(r'\((-\d+)\)R_', r'\1R_', ops)

            # 7.5 Insert implicit coefficient 1 in row combinations (ONLY in ops_part)
            # Handles: R_2-R_1 -> R_2-1R_1 ; R_2+R_1 -> R_2+1R_1
            ops = re.sub(r'(R_\d+)\s*([+\-])\s*R_', r'\1\g<2>1R_', ops)

            # 7c. Force spaces around + and - inside ops_part so lexer never fuses +5 into a single token
            ops = re.sub(r'([+\-])', r' \1 ', ops)

            # 7d. Canonicalize multiple +/- combos: "--"->"+", "+-"|"-+"->"-"
            ops = re.sub(r'\+\s*\+', ' + ', ops)
            ops = re.sub(r'-\s*-', ' + ', ops)
            ops = re.sub(r'\+\s*-|-\s*\+', ' - ', ops)

            # 8) Clean up multiple spaces in ops
            ops = re.sub(r'\s+', ' ', ops).strip()

        # -------------------------
        # Recombine matrix_part and ops_part (if ops existed)
        # -------------------------
        if ops:
            # Ensure single pipe between matrix and ops
            out = matrix_part.strip() + '|' + ops
        else:
            out = matrix_part.strip()

        # Final cleanup (a little extra safety)
        out = re.sub(r'\|{2,}', '|', out)
        out = re.sub(r'\s+', ' ', out).strip()
        out = re.sub(r'\|\s*$', '', out)  # remove trailing pipe
        # --- Step 7: Final sanity rewrite for self-row combos ---
        # Convert R_n+nR_n ‚Üí R_n-(-n)R_n
            # --- Step 7: Final rewrite for all "+" row operations ---
        # Convert any R_n1 + nR_n2 ‚Üí R_n1 - (-n)R_n2
        out = re.sub(
            r'(R_(\d+))\s*\+\s*([0-9]+)R_(\d+)',
            lambda m: f"{m.group(1)} - (-{m.group(3)})R_{m.group(4)}",
            out
        )

        # Convert any R_n1 + R_n2 ‚Üí R_n1 - (-1)R_n2
        out = re.sub(
            r'(R_(\d+))\s*\+\s*R_(\d+)',
            lambda m: f"{m.group(1)} - (-1)R_{m.group(3)}",
            out
        )

        return out


    def parse(self, latex):
        """Parse LaTeX to SymPy expression with error popup display"""
        import re
        from lark.exceptions import UnexpectedToken, UnexpectedCharacters, UnexpectedEOF

        cleaned = self.clean_latex(latex)

        # Preprocess derivatives
        clean = self._preprocess_derivatives(cleaned)

        # ‚úÖ ADD THIS: Preprocess row operations
        clean = self._preprocess_row_operations(clean)

        window.console.log(f"üîç Original LaTeX: {latex}")
        window.console.log(f"üîç Cleaned LaTeX: {clean}")

        try:
            tree = self.parser.parse(clean)
            window.console.log(f"üîç Parse tree: {tree.pretty()}")
            result = self.transformer.transform(tree)
            window.console.log(f"üîç Transformed result: {result}")
            return result

        except (UnexpectedToken, UnexpectedCharacters, UnexpectedEOF) as e:
            pos = getattr(e, "pos_in_stream", None)
            line = getattr(e, "line", "?")
            col = getattr(e, "column", "?")

            # Remove "Expected ‚Ä¶" section from Lark message
            raw_msg = str(e)
            simplified_msg = re.sub(r"Expected one of:.*", "", raw_msg, flags=re.DOTALL).strip()

            # Build context with caret pointing to error
            try:
                span = 35
                start = max(0, (pos or 0) - span)
                end = min(len(clean), (pos or 0) + span)
                snippet = clean[start:end]
                caret_pos = (pos or 0) - start
                caret_line = " " * caret_pos + "‚Üë"
                context = f"{snippet}\n{caret_line}"
            except Exception:
                context = clean

            msg = (
                f"‚ùå Parse error in LaTeX:\n\n"
                f"Line: {line}, Column: {col}\n"
                f"Type: {type(e).__name__}\n"
                f"Message: {simplified_msg}\n\n"
                f"Context:\n{context}"
            )
            self._show_error_popup(msg)
            window.console.error(msg)
            return None

        except Exception as e:
            msg = f"‚ùå General parse error: {e}"
            window.console.error(msg)
            self._show_error_popup(msg)
            return None

    def clean_latex(self, tex):
        """Normalize LaTeX string for parsing"""
        import re
        if not tex:
            return ""
        t = str(tex)

        # Remove \left and \right but keep the parentheses
        t = t.replace("\\left(", "(")
        t = t.replace("\\right)", ")")
        t = t.replace("\\left[", "[")
        t = t.replace("\\right]", "]")
        t = t.replace("\\left\\{", "{")
        t = t.replace("\\right\\}", "}")
        t = t.replace("\\left|", "|")
        t = t.replace("\\right|", "|")

        # Replace mathrm{d} with d
        t = t.replace("\\mathrm{d}", "d")

        # Remove spacing macros
        t = re.sub(r"\\(?:,|;|:|!|quad|qquad| )", "", t)

        # Remove whitespace
        t = re.sub(r"\s+", "", t)

        return t.strip()

    def _create_transformer(self):
        """Create the Lark transformer with improved rules"""
        from lark import Transformer, v_args
        import sympy as sp

        # ‚úÖ Define canonical_scalar at the top level of this function
        def canonical_scalar(x):
            """Convert/normalize a value to a canonical SymPy scalar (Integer/Rational/Float simplified)."""
            if not isinstance(x, sp.Basic):
                try:
                    x = sp.sympify(x)
                except Exception:
                    return x
            # Prefer exact rationals for floats represented as strings
            if isinstance(x, sp.Float):
                try:
                    x = sp.Rational(str(x))
                except Exception:
                    pass
            # Simplify and evaluate any Mul/Add wrappers (handles Mul(-1,n) -> -n)
            x = sp.simplify(x)
            try:
                x = x.doit()
            except Exception:
                pass
            return sp.simplify(x)
          
        @v_args(inline=True)
        class Latex2Sympy(Transformer):
            _canonical_scalar = canonical_scalar
            def paren_expr(self, expr):
                return expr

            def braces_expr(self, expr):
                return expr

            def number(self, tok):
                s = str(tok)
                return sp.Integer(s) if '.' not in s else sp.Float(s)

            def symbol(self, tok):
                s = str(tok).strip()
                return sp.Symbol(s[1:] if s.startswith("\\") else s)

            def pi_symbol(self, _):
                return sp.pi

            def infty_symbol(self, _):
                return sp.oo

            def infinity(self, tok):
                s = str(tok)
                return -sp.oo if s.startswith('-') else sp.oo

            def abs_func(self, expr):
                return sp.Abs(expr)

            def neg(self, v):
                return sp.Mul(-1, v, evaluate=False)

            def add(self, a, b):
                return sp.Add(a, b, evaluate=False)

            def sub(self, a, b):
                return sp.Add(a, sp.Mul(-1, b, evaluate=False), evaluate=False)

            def mul(self, a, b):
                if isinstance(a, (sp.MatrixBase, sp.MatrixExpr)) or isinstance(b, (sp.MatrixBase, sp.MatrixExpr)):
                    a_ = sp.UnevaluatedExpr(a) if isinstance(a, (sp.MatrixBase, sp.MatrixExpr)) else a
                    b_ = sp.UnevaluatedExpr(b) if isinstance(b, (sp.MatrixBase, sp.MatrixExpr)) else b
                    return sp.Mul(a_, b_, evaluate=False)
                return sp.Mul(a, b, evaluate=True)

            def div(self, a, b):
                return sp.Mul(a, sp.Pow(b, -1, evaluate=False), evaluate=False)

            def frac(self, numerator, denominator):
                return sp.Mul(numerator, sp.Pow(denominator, -1, evaluate=False), evaluate=False)

            def trig_func(self, func_name, expr):
                func_str = str(func_name).strip().replace("\\", "")
                func_map = {
                    "sin": sp.sin,
                    "cos": sp.cos,
                    "tan": sp.tan,
                    "cot": sp.cot,
                    "sec": sp.sec,
                    "csc": sp.csc,
                    "arcsin": sp.asin,
                    "arccos": sp.acos,
                    "arctan": sp.atan,
                }
                func = func_map.get(func_str)
                if func:
                    return func(expr)
                return sp.Function(func_str)(expr)

            def log_func(self, func_name, expr):
                func_str = str(func_name).strip().replace("\\", "")
                if func_str == "ln":
                    return sp.ln(expr)
                elif func_str == "log":
                    return sp.log(expr, 10)
                elif func_str == "exp":
                    return sp.exp(expr)
                return sp.Function(func_str)(expr)

            def limit_expr(self, var, value, expr):
                return sp.Limit(expr, sp.Symbol(str(var)), value)

            def implicit_mul(self, a, b):
                if isinstance(a, sp.Matrix) or isinstance(b, sp.Matrix):
                    return sp.Mul(a, b, evaluate=False)
                return sp.Mul(a, b, evaluate=False)

            def power(self, a, b):
                """
                Handle right-associative power like 10^100^0 correctly.
                Lark gives us nested trees due to right recursion.
                """
                import sympy as sp

                # If right child is another power, handle it recursively.
                # Example: a=10, b=Pow(100, 0) -> Pow(10, (100**0))
                if isinstance(b, sp.Pow):
                    return sp.Pow(a, b, evaluate=False)

                return sp.Pow(a, b, evaluate=False)

            # --- NEW METHOD FOR DEGREES ---
            def atom_to_degree(self, tree):
                """
                Handles expressions like 90^\circ.
                Converts degrees to radians by multiplying by pi/180.
                """
                # tree.children[0] is the already-transformed atom (e.g., the number 90)
                atom = tree.children[0]
                # We don't need tree.children[1] which is the degree_expr
                return sp.pi * atom / 180

            def elements(self, *items):
                return list(items)

            def row(self, elements):
                return list(elements) if isinstance(elements, (list, tuple)) else [elements]

            def matrix_rows(self, *rows):
                row_list = [list(r) if isinstance(r, (list, tuple)) else [r] for r in rows]
                return sp.Matrix(row_list)

            def matrix_env(self, *args):
                rows = []
                for a in args:
                    if a is None:
                        continue
                    if isinstance(a, list) and a and all(isinstance(x, (list, tuple)) for x in a):
                        rows.extend([list(r) for r in a])
                    elif isinstance(a, (list, tuple)):
                        rows.append(list(a))
                    else:
                        rows.append([a])
                return sp.Matrix(rows)

            def scalar_matrix_mul(self, scalar, matrix):
                return sp.Mul(scalar, matrix, evaluate=False)

            def row_reference(self, i):
                return ("ref", int(i))

            def row_scale(self, factor, i):
                return ("scale", int(i), factor)

            def row_replace(self, target, arrow, expr):
                """Row replacement operation - arrow parameter is captured but not used"""
                return ("replace", int(target), expr)

            def row_swap(self, i, swap_arrow, j):
                """Row swap operation - swap_arrow parameter is captured but not used"""
                return ("swap", int(i), int(j))

            def row_combine(self, i, op, factor, j):
                return ("combine", int(i), str(op), factor, int(j))

            def matrix_apply_ops(self, matrix, *ops):
              import sympy as sp
              # Ensure we have a writable SymPy Matrix copy
              m = sp.Matrix(matrix) if not isinstance(matrix, sp.Matrix) else matrix.copy()

              # ‚úÖ Store original matrix and track operations
              original_matrix = m.copy()
              operations_list = []

              # Canonicalize input matrix elements up-front (avoids '- 1' split issues)
              m = m.applyfunc(canonical_scalar)

              for op in ops:
                  # ‚úÖ Record each operation BEFORE applying it
                  operations_list.append({
                      "type": op[0],
                      "details": list(op[1:]) if len(op) > 1 else []
                  })

                  if op[0] == "replace":
                      _, target, expr = op
                      tgt = int(target) - 1  # 0-based

                      if expr[0] == "ref":
                          _, src = expr
                          # copy row to avoid aliasing
                          m[tgt, :] = m[int(src)-1, :].copy()

                      elif expr[0] == "scale":
                          _, src, factor = expr
                          src_row = [canonical_scalar(v) for v in list(m[int(src)-1, :].copy())]
                          factor_sym = canonical_scalar(factor)
                          new_elems = [ canonical_scalar(factor_sym * v) for v in src_row ]
                          m[tgt, :] = sp.Matrix([ new_elems ]).reshape(1, m.cols)

                      elif expr[0] == "combine":
                          _, src, op_str, factor, other = expr
                          src_idx = int(src) - 1
                          other_idx = int(other) - 1

                          # CRITICAL: copy both source rows so we compute from originals
                          src_row = [ canonical_scalar(v) for v in list(m[src_idx, :].copy()) ]
                          other_row = [ canonical_scalar(v) for v in list(m[other_idx, :].copy()) ]

                          factor_sym = canonical_scalar(factor)

                          new_elems = []
                          for a, b in zip(src_row, other_row):
                              if op_str == "+":
                                  val = canonical_scalar(a + factor_sym * b)
                              else:
                                  val = canonical_scalar(a - factor_sym * b)
                              new_elems.append(val)

                          m[tgt, :] = sp.Matrix([ new_elems ]).reshape(1, m.cols)

                  elif op[0] == "swap":
                      _, i, j = op
                      i0, j0 = int(i)-1, int(j)-1
                      temp = m[i0, :].copy()
                      m[i0, :] = m[j0, :].copy()
                      m[j0, :] = temp

              # final pass to ensure everything canonicalized
              result = m.applyfunc(canonical_scalar)

              # ‚úÖ CRITICAL: Store metadata on the FINAL result matrix
              # This preserves the operation history even after canonicalization
              result._matrix_op_metadata = {
                  "operations": operations_list,
                  "original_shape": (original_matrix.rows, original_matrix.cols)
              }

              window.console.log(f"‚úÖ Stored metadata on matrix with {len(operations_list)} operation(s)")

              return result

            # --- METHODS FOR PREPROCESSED DERIVATIVES ---
            def derivative_func(self, var, expr):
                """Handles the preprocessed __derivative(var, expr) call."""
                return sp.Derivative(expr, sp.Symbol(str(var)))

            def partial_derivative_func(self, var, expr):
                """Handles the preprocessed __partial_derivative(var, expr) call."""
                return sp.Derivative(expr, sp.Symbol(str(var)))

            def start(self, e):
                return e

        return Latex2Sympy()

    def validate_limit(self, limit_expr):
        """
        Validate if a limit problem is suitable for students.
        Returns (is_valid, error_message)

        Invalid cases:
        1. Different left and right limit values (discontinuity)
        2. Oscillating limits (e.g., sin(1/x) as x->0)
        3. Limits that evaluate to infinity
        """
        import sympy as sp

        if not isinstance(limit_expr, sp.Limit):
            return (True, None)  # Not a limit, skip validation

        try:
            # Get the limit components
            expr = limit_expr.args[0]
            var = limit_expr.args[1]
            point = limit_expr.args[2]

            # Evaluate the limit
            limit_value = limit_expr.doit()

            # Check 1: Limit evaluates to infinity
            if limit_value.has(sp.oo) or limit_value == sp.oo or limit_value == -sp.oo:
                return (False, f"Limit evaluates to infinity: {limit_value}")

            # Check 2: Limit does not exist (returns unevaluated or NaN)
            if isinstance(limit_value, sp.Limit) or limit_value is sp.nan:
                return (False, "Limit does not exist or cannot be determined")

            # Check 3: Different left and right limits (if approaching a finite point)
            if point != sp.oo and point != -sp.oo:
                try:
                    left_limit = sp.limit(expr, var, point, '-')
                    right_limit = sp.limit(expr, var, point, '+')

                    # Simplify both limits
                    left_simplified = sp.simplify(left_limit)
                    right_simplified = sp.simplify(right_limit)

                    # Check if they're different
                    if not sp.simplify(left_simplified - right_simplified) == 0:
                        return (False, f"Left and right limits differ: left={left_simplified}, right={right_simplified}")
                except:
                    pass

            # Check 4: Oscillating behavior (limit doesn't exist due to oscillation)
            # This is tricky - we check if the limit is AccumBounds or contains zoo
            if hasattr(limit_value, 'is_finite') and not limit_value.is_finite:
                if limit_value != sp.oo and limit_value != -sp.oo:
                    return (False, "Limit oscillates or is undefined")

            # Check for AccumBounds (accumulated bounds, indicates oscillation)
            if 'AccumBounds' in str(type(limit_value)):
                return (False, "Limit oscillates between multiple values")

            # Check for zoo (complex infinity, often from oscillation)
            if limit_value == sp.zoo:
                return (False, "Limit is complex infinity (oscillation or undefined)")

            return (True, None)

        except Exception as e:
            window.console.error(f"Error validating limit: {e}")
            return (False, f"Error evaluating limit: {str(e)}")

    def normalize(self, expr):
      """
      Normalize a SymPy expression for comparison.
      Applies simplification to make structurally equivalent expressions comparable.
      """
      import sympy as sp

      if expr is None:
          return None

      try:
          # Handle matrices
          if isinstance(expr, sp.MatrixBase):
              return expr.applyfunc(sp.simplify)

          # Handle regular expressions
          return sp.simplify(expr)

      except Exception as e:
          window.console.error(f"Normalization error: {e}")
          # Return original if normalization fails
          return expr

    def compare(self, expr1, expr2):
      """
      Compare two SymPy expressions for mathematical equality.
      Returns True if expressions are mathematically equivalent.
      """
      import sympy as sp

      if expr1 is None or expr2 is None:
          return False

      try:
          # Handle matrix comparison
          if isinstance(expr1, sp.MatrixBase) and isinstance(expr2, sp.MatrixBase):
              if expr1.shape != expr2.shape:
                  return False

              # Compare element by element
              for i in range(expr1.rows):
                  for j in range(expr1.cols):
                      diff = sp.simplify(expr1[i, j] - expr2[i, j])
                      if diff != 0:
                          return False
              return True

          # Handle scalar comparison
          diff = sp.simplify(expr1 - expr2)
          return diff == 0

      except Exception as e:
          window.console.error(f"Comparison error: {e}")
          import traceback
          window.console.error(traceback.format_exc())
          return False
          
    def extract_structure(self, expr):
      """
      Extract structural fingerprint of expression INCLUDING matrix operations.
      Normalizes all numeric values to consistent float representation for reliable comparison.
      """
      import sympy as sp, traceback
      operators, operands, matrix_ops = {}, {}, []

      def normalize_numeric_to_string(node):
          """
          Convert any numeric value to normalized string representation.
          Rational(1, 2) ‚Üí "0.5"
          Integer(2) ‚Üí "2.0" 
          Float(0.5) ‚Üí "0.5"
          """
          try:
              # Check if it's a SymPy numeric type
              if isinstance(node, sp.Basic):
                  if hasattr(node, 'is_number') and node.is_number:
                      # Convert to float for consistency
                      float_val = float(node.evalf())
                      # Check if it's effectively an integer
                      if float_val == int(float_val):
                          return str(int(float_val))
                      else:
                          return str(float_val)

              # Check if it's a Python numeric type
              if isinstance(node, (int, float)):
                  if isinstance(node, int) or float(node) == int(float(node)):
                      return str(int(node))
                  else:
                      return str(float(node))

              # Try to parse as number from string
              node_str = str(node)
              if '/' in node_str:
                  # Handle fraction strings like "1/2"
                  parts = node_str.split('/')
                  if len(parts) == 2:
                      try:
                          num = float(parts[0].strip())
                          denom = float(parts[1].strip())
                          if denom != 0:
                              result = num / denom
                              if result == int(result):
                                  return str(int(result))
                              else:
                                  return str(result)
                      except:
                          pass

              # Try direct float conversion
              try:
                  float_val = float(node_str)
                  if float_val == int(float_val):
                      return str(int(float_val))
                  else:
                      return str(float_val)
              except:
                  pass

          except Exception as e:
              window.console.log(f"normalize_numeric_to_string error: {e}")

          # If all else fails, return string representation
          return str(node).strip().replace(" ", "")

      def normalize_matrix_metadata(metadata):
          """
          Normalize matrix operation metadata to ensure consistent numeric representation.
          """
          if not metadata or not isinstance(metadata, dict):
              return metadata

          normalized = {
              "type": metadata.get("type"),
              "operations": [],
              "original_shape": metadata.get("original_shape")
          }

          for operation in metadata.get("operations", []):
              normalized_op = {
                  "type": operation.get("type"),
                  "details": normalize_details_list(operation.get("details", []))
              }
              normalized["operations"].append(normalized_op)

          return normalized

      def normalize_details_list(details):
          """
          Recursively normalize a list/tuple of operation details.
          Converts nested structures and numeric values.
          """
          if details is None:
              return []

          if not isinstance(details, (list, tuple)):
              details = [details]

          normalized = []
          for item in details:
              if isinstance(item, (list, tuple)):
                  # Recursively normalize nested structures
                  normalized.append(normalize_details_list(item))
              elif isinstance(item, str):
                  # Keep strings as-is (like "scale", "swap", etc.)
                  normalized.append(item)
              else:
                  # Normalize numeric values
                  normalized.append(normalize_numeric_to_string(item))

          return normalized

      def process(node, parent_op=None):
          nonlocal matrix_ops

          if node is None:
              return

          # Skip tuple coordinates from matrix indexing
          if isinstance(node, (tuple, list)) and all(isinstance(i, sp.Integer) for i in node):
              return

          # ‚úÖ CRITICAL: Detect matrix operations by checking for metadata
          if isinstance(node, sp.MatrixBase):
              # Check if this matrix has row operation metadata
              if hasattr(node, '_matrix_op_metadata'):
                  metadata = node._matrix_op_metadata

                  # Normalize the metadata before storing
                  normalized_metadata = normalize_matrix_metadata(metadata)

                  matrix_ops.append({
                      "type": "matrix_with_row_ops",
                      "operations": normalized_metadata["operations"],
                      "original_shape": normalized_metadata["original_shape"]
                  })

                  window.console.log(f"‚úÖ Found matrix with {len(metadata['operations'])} operation(s)")
                  window.console.log(f"   Normalized operations: {normalized_metadata['operations']}")
              else:
                  window.console.log(f"‚ÑπÔ∏è Matrix has no _matrix_op_metadata attribute")

              # Process matrix elements
              for el in node:
                  process(el, parent_op)
              return

          # Handle MatrixExpr (symbolic matrix operations)
          if isinstance(node, sp.MatrixExpr) and not isinstance(node, sp.MatrixBase):
              val = normalize_numeric_to_string(node)
              operands[val] = operands.get(val, 0) + 1
              return

          # Check if this is a Mul(-1, x) pattern (negation)
          if isinstance(node, sp.Mul) and len(node.args) == 2:
              a, b = node.args
              if a == sp.Integer(-1) and isinstance(b, (sp.Symbol, sp.Number)):
                  # Simplify Mul(-1, x) to -x
                  simplified = sp.simplify(node)
                  val = normalize_numeric_to_string(simplified)
                  operands[val] = operands.get(val, 0) + 1
                  window.console.log(f"‚úÖ Simplified Mul(-1, {b}) -> {val}")
                  return

          # Handle nodes with arguments (operators)
          if hasattr(node, "args") and len(node.args) > 0:
              op_name = type(node).__name__

              # Skip Tuple nodes
              if op_name == "Tuple":
                  for c in node.args:
                      process(c, parent_op)
                  return

              # Don't double-count nested Mul operations
              if not (op_name == "Mul" and (parent_op == "Mul" or len(node.args) == 1)):
                  operators[op_name] = operators.get(op_name, 0) + 1

              # Recursively process children
              for c in node.args:
                  process(c, op_name)
              return

          # Handle leaf nodes (operands) - NORMALIZE HERE
          val = normalize_numeric_to_string(node)

          # Skip -1 as it's usually part of subtraction/negation
          if val == "-1":
              return

          operands[val] = operands.get(val, 0) + 1

      try:
          process(expr)
      except Exception as e:
          window.console.log(f"extract_structure error: {e}")
          window.console.log(traceback.format_exc())

      result = {
          "operators": operators,
          "operands": operands,
          "matrix_ops": matrix_ops,
          "total_ops": sum(operators.values()),
          "total_operands": sum(operands.values())
      }

      window.console.log(f"üìä Extracted structure: {len(matrix_ops)} matrix operation(s)")
      if matrix_ops:
          window.console.log(f"   Matrix ops details: {matrix_ops}")

      return result
    

class KeyboardInputHandler:
  """Common handler for keyboard input to MathQuill fields"""

  @staticmethod
  def handle_action(mathquill_field, action):
      """
      Handle keyboard action for a MathQuill field

      Args:
          mathquill_field: MathQuill field instance
          action: String action from button data-action attribute
      """
      if not mathquill_field:
          window.console.error("No MathQuill field provided")
          return

      window.console.log(f"KeyboardInputHandler: Action = {action}")

      # ==================== NAVIGATION & CONTROL ====================
      if action == "BACKSPACE":
          mathquill_field.keystroke("Backspace")
      elif action == "CLEAR":
          mathquill_field.latex("")
      elif action == "MOVE_LEFT":
          mathquill_field.keystroke("Left")
      elif action == "MOVE_RIGHT":
          mathquill_field.keystroke("Right")
      elif action == "SELECT_LEFT":
          mathquill_field.keystroke("Shift-Left")
      elif action == "SELECT_RIGHT":
          mathquill_field.keystroke("Shift-Right")
      elif action == "MOVE_UP":
          mathquill_field.keystroke("Up")
      elif action == "MOVE_DOWN":
          mathquill_field.keystroke("Down")
      elif action == "HOME":
          mathquill_field.keystroke("Home")
      elif action == "END":
          mathquill_field.keystroke("End")

      # ==================== KEYBOARD ACTIVATION ====================
      elif action == "ACTIVATE_KEYBOARD":
          try:
              el = mathquill_field.el()
              textarea = el.querySelector('textarea')
              if textarea:
                  textarea.style.width = f"{el.offsetWidth}px"
                  textarea.style.height = f"{el.offsetHeight}px"
                  textarea.style.overflow = "hidden"
                  textarea.style.resize = "none"
                  textarea.style.boxSizing = "border-box"
                  textarea.removeAttribute('readonly')
                  textarea.removeAttribute('disabled')
                  textarea.style.pointerEvents = 'auto'
                  textarea.style.opacity = '1'
                  textarea.style.position = 'absolute'
                  textarea.style.left = '0'
                  textarea.focus()
                  window.console.log("‚úÖ Keyboard activated")
          except Exception as e:
              window.console.error(f"Failed to activate keyboard: {e}")

      elif action == "DEACTIVATE_KEYBOARD":
          try:
              el = mathquill_field.el()
              textarea = el.querySelector('textarea')
              if textarea:
                  textarea.blur()
                  textarea.setAttribute('readonly', 'readonly')
                  textarea.setAttribute('disabled', 'disabled')
                  textarea.style.pointerEvents = 'none'
                  textarea.style.opacity = '0'
                  textarea.style.position = 'absolute'
                  textarea.style.left = '-9999px'
                  window.console.log("‚úÖ Keyboard deactivated")
          except Exception as e:
              window.console.error(f"Failed to deactivate keyboard: {e}")

      # ==================== SPECIAL OPERATORS ====================
      elif action == "^":
          mathquill_field.cmd("^")
      elif action == "_":
          mathquill_field.cmd("_")
      elif action == "/":
          mathquill_field.cmd("/")

      # ==================== ARITHMETIC OPERATORS ====================
      elif action == "+":
          mathquill_field.write("+")
      elif action == "-":
          mathquill_field.write("-")
      elif action == "*":
          mathquill_field.cmd("times")
      elif action == "\\times":
          mathquill_field.cmd("times")
      elif action == "\\cdot":
          mathquill_field.cmd("cdot")
      elif action == "\\div":
          mathquill_field.cmd("div")
      elif action == "=":
          mathquill_field.write("=")

      # ==================== BRACKETS & DELIMITERS ====================
      elif action == "(":
          mathquill_field.write("(")
      elif action == ")":
          mathquill_field.write(")")
      elif action == "[":
          mathquill_field.write("[")
      elif action == "]":
          mathquill_field.write("]")
      elif action == "{":
          mathquill_field.write("{")
      elif action == "}":
          mathquill_field.write("}")
      elif action == "|":
          mathquill_field.cmd("|")
      elif action == ",":
          mathquill_field.write(",")
      elif action == ".":
          mathquill_field.write(".")
      elif action == "&":
          mathquill_field.write("&")
      elif action == "\\\\":
          mathquill_field.write("\\\\")

      # ==================== ALGEBRA & CALCULUS ====================
      elif action == "\\sqrt":
          mathquill_field.cmd("sqrt")
      elif action == "\\frac":
          mathquill_field.cmd("frac")
      elif action == "\\int":
          mathquill_field.cmd("int")
      elif action == "\\sum":
          mathquill_field.cmd("sum")
      elif action == "\\prod":
          mathquill_field.cmd("prod")
      elif action == "\\infty":
          mathquill_field.cmd("infty")
      elif action == "\\partial":
          mathquill_field.cmd("partial")
      elif action == "\\to":
          mathquill_field.cmd("to")

# ==================== LIMIT VARIATIONS ====================
      elif action == "\\lim":
          # Simple lim symbol only
          mathquill_field.cmd("lim")

      elif action == "\\lim_sequence":
          # Full limit notation: lim_{x\to 0}
          mathquill_field.cmd("lim")
          mathquill_field.cmd("_")
          mathquill_field.write("x")
          mathquill_field.cmd("to")
          mathquill_field.keystroke("Spacebar")
          mathquill_field.write("0")
          mathquill_field.keystroke("Right")

      elif action == "\\lim_to_zero":
          # lim_{x\to 0}
          mathquill_field.cmd("lim")
          mathquill_field.cmd("_")
          mathquill_field.write("x")
          mathquill_field.cmd("to")
          mathquill_field.write("0")
          mathquill_field.keystroke("Right")

      elif action == "\\lim_to_infty":
          # lim_{x\to \infty}
          mathquill_field.cmd("lim")
          mathquill_field.cmd("_")
          mathquill_field.write("x")
          mathquill_field.cmd("to")
          mathquill_field.cmd("infty")
          mathquill_field.keystroke("Right")
          mathquill_field.keystroke("Right")

      elif action == "\\lim_n_to_infty":
          # lim_{n\to \infty}
          mathquill_field.cmd("lim")
          mathquill_field.cmd("_")
          mathquill_field.write("n")
          mathquill_field.cmd("to")
          mathquill_field.cmd("infty")
          mathquill_field.keystroke("Right")
          mathquill_field.keystroke("Right")

      # ==================== TRIGONOMETRY ====================
      elif action == "\\sin":
          mathquill_field.cmd("sin")
      elif action == "\\cos":
          mathquill_field.cmd("cos")
      elif action == "\\tan":
          mathquill_field.cmd("tan")
      elif action == "\\cot":
          mathquill_field.cmd("cot")
      elif action == "\\sec":
          mathquill_field.cmd("sec")
      elif action == "\\csc":
          mathquill_field.cmd("csc")
      elif action == "\\arcsin":
          mathquill_field.cmd("arcsin")
      elif action == "\\arccos":
          mathquill_field.cmd("arccos")
      elif action == "\\arctan":
          mathquill_field.cmd("arctan")

      # ==================== LOGARITHMS ====================
      elif action == "\\log":
          mathquill_field.cmd("log")
      elif action == "\\ln":
          mathquill_field.cmd("ln")
      elif action == "\\exp":
          mathquill_field.cmd("exp")
      elif action == "e":
          mathquill_field.write("e")

      # ==================== GREEK LETTERS ====================
      elif action == "\\alpha":
          mathquill_field.cmd("alpha")
      elif action == "\\beta":
          mathquill_field.cmd("beta")
      elif action == "\\gamma":
          mathquill_field.cmd("gamma")
      elif action == "\\delta":
          mathquill_field.cmd("delta")
      elif action == "\\theta":
          mathquill_field.cmd("theta")
      elif action == "\\lambda":
          mathquill_field.cmd("lambda")
      elif action == "\\pi":
          mathquill_field.cmd("pi")
      elif action == "\\sigma":
          mathquill_field.cmd("sigma")
      elif action == "\\phi":
          mathquill_field.cmd("phi")
      elif action == "\\omega":
          mathquill_field.cmd("omega")
      elif action == "\\mu":
          mathquill_field.cmd("mu")
      elif action == "\\rho":
          mathquill_field.cmd("rho")
      elif action == "\\tau":
          mathquill_field.cmd("tau")
      elif action == "\\epsilon":
          mathquill_field.cmd("epsilon")
      elif action == "\\xi":
          mathquill_field.cmd("xi")
      elif action == "\\zeta":
          mathquill_field.cmd("zeta")
      elif action == "\\eta":
          mathquill_field.cmd("eta")
      elif action == "\\iota":
          mathquill_field.cmd("iota")
      elif action == "\\kappa":
          mathquill_field.cmd("kappa")
      elif action == "\\nu":
          mathquill_field.cmd("nu")
      elif action == "\\omicron":
          mathquill_field.cmd("omicron")
      elif action == "\\upsilon":
          mathquill_field.cmd("upsilon")
      elif action == "\\chi":
          mathquill_field.cmd("chi")
      elif action == "\\psi":
          mathquill_field.cmd("psi")

      # ==================== MATRIX OPERATIONS ====================
      elif action == "\\det":
          mathquill_field.cmd("det")
      elif action == "^T":
          mathquill_field.write("^T")
      elif action == "^{-1}":
          mathquill_field.write("^{-1}")

      # ==================== SEQUENCES ====================
      elif action.startswith("SEQ:"):
          # Handle sequences like d/dx, SEQ:d,/,d,x
          # Now supports keystrokes in curly braces like {Space}, {Right}
          sequence = action[4:]
          keys = sequence.split(",")
          for key in keys:
              key = key.strip()

              # Check if it's a keystroke command in curly braces
              if key.startswith("{") and key.endswith("}"):
                  # Extract keystroke name (e.g., {Space} -> Space, {Right} -> Right)
                  keystroke_name = key[1:-1]
                  mathquill_field.keystroke(keystroke_name)
              elif key == "/":
                  mathquill_field.cmd("/")
              elif key == "_":
                  # Underscore needs to be a keystroke command, not written text
                  mathquill_field.cmd("_")
              elif key == "^":
                  # Caret/power needs to be a keystroke command, not written text
                  mathquill_field.cmd("^")
              elif key.startswith("\\"):
                  mathquill_field.cmd(key[1:])  # Remove backslash
              else:
                  mathquill_field.write(key)

      # ==================== GENERIC LATEX COMMAND ====================
      elif action.startswith("\\"):
          # Remove backslash and use cmd()
          cmd_name = action[1:]
          window.console.log(f"Generic LaTeX cmd: {cmd_name}")
          mathquill_field.cmd(cmd_name)

      # ==================== REGULAR TEXT/NUMBERS ====================
      else:
          # Regular text (numbers, letters, etc.)
          mathquill_field.write(action)

      window.console.log(f"‚úÖ Action '{action}' handled successfully")

class ProblemSolverApp:
  def share_whatsapp_progress(self, event):
    """Share progress via WhatsApp"""
    if not self.problem_set:
        window.alert("No problems to share")
        return

    try:
        window.console.log("=== Starting WhatsApp share ===")

        # Save current problem state first
        if self.current_problem_index is not None and hasattr(self, 'solve_state'):
            serializable_state = []
            for step in self.solve_state:
                step_data = {
                    "step": step.get("step", {}),
                    "attempts": step.get("attempts", 0),
                    "attempt_history": step.get("attempt_history", []),
                    "correct": step.get("correct", False),
                    "finalize_attempts": step.get("finalize_attempts", 0),
                    "finalize_history": step.get("finalize_history", []),
                    "structure_correct": step.get("structure_correct", False),
                    "finalized": step.get("finalized", False),
                    "step_start_time": step.get("step_start_time", window.Date.now())
                }
                serializable_state.append(step_data)
            self.problem_states[self.current_problem_index] = serializable_state

        # Create complete problem states for ALL problems
        complete_problem_states = {}
        for prob_idx in range(len(self.problem_set)):
            if prob_idx in self.problem_states:
                complete_problem_states[prob_idx] = self.problem_states[prob_idx]
            else:
                problem = self.problem_set[prob_idx]
                steps = problem.get("steps", [])
                empty_state = []
                for step_idx, step_data in enumerate(steps):
                    empty_step = {
                        "step": step_data,
                        "attempts": 0,
                        "attempt_history": [],
                        "correct": False,
                        "finalize_attempts": 0,
                        "finalize_history": [],
                        "structure_correct": False,
                        "finalized": False,
                        "step_start_time": 0
                    }
                    empty_state.append(empty_step)
                complete_problem_states[prob_idx] = empty_state

        # Build export data
        raw_export_data = {
            "problem_set_id": self.current_problem_set_uuid,
            "problem_set": self.problem_set,
            "problem_states": complete_problem_states,
            "export_date": window.Date.new().toISOString()
        }

        # Convert to native types
        export_data = self._convert_to_native(raw_export_data)

        # Serialize to JSON
        json_str = json.dumps(export_data)

        # Compress
        import brotli
        compressed = brotli.compress(json_str.encode('utf-8'))

        # Encode to base64
        b64_str = base64.b64encode(compressed).decode('utf-8')

        # Create message with export data
        worked_problems = len(self.problem_states)
        total_problems = len(self.problem_set)
        
        message = f"""
=== STUDENT PROGRESS EXPORT ===
{b64_str}
=== END EXPORT ==="""

        # Get phone number
        phone_input = document.getElementById("teacherPhoneNumber")
        if not phone_input:
            window.alert("Phone number input not found")
            return
            
        phone = phone_input.value.strip()
        if not phone:
            window.alert("Please enter teacher's phone number")
            return

        # Encode message for WhatsApp URL
        encoded_message = window.encodeURIComponent(message)
        
        # Open WhatsApp
        whatsapp_url = f"https://wa.me/{phone}?text={encoded_message}"
        window.open(whatsapp_url, '_blank')
        
        window.console.log("‚úÖ WhatsApp share prepared successfully")

    except Exception as e:
        window.console.error(f"WhatsApp share failed: {e}")
        import traceback
        window.console.error(traceback.format_exc())
        window.alert(f"Share failed: {e}")
  def inject_freestyle_navigation_svgs(self):
    """Inject SVG icons into freestyle navigation and algebra buttons"""
    try:
        # Get SVG content for navigation
        move_left_svg = self.get_move_left_svg("24")
        move_right_svg = self.get_move_right_svg("24")
        select_left_svg = self.get_select_left_svg("24")
        select_right_svg = self.get_select_right_svg("24")

        # Inject into navigation buttons
        move_left_btn = document.querySelector("#freestyleMoveLeft")
        if move_left_btn:
            move_left_btn.innerHTML = move_left_svg
            window.console.log("‚úÖ Injected move left SVG")

        move_right_btn = document.querySelector("#freestyleMoveRight")
        if move_right_btn:
            move_right_btn.innerHTML = move_right_svg
            window.console.log("‚úÖ Injected move right SVG")

        select_left_btn = document.querySelector("#freestyleSelectLeft")
        if select_left_btn:
            select_left_btn.innerHTML = select_left_svg
            window.console.log("‚úÖ Injected select left SVG")

        select_right_btn = document.querySelector("#freestyleSelectRight")
        if select_right_btn:
            select_right_btn.innerHTML = select_right_svg
            window.console.log("‚úÖ Injected select right SVG")

        # ‚úÖ Get SVG content for power and subscript
        power_svg = self.get_power_svg("24")
        subscript_svg = self.get_subscript_svg("24")

        # ‚úÖ Inject into algebra buttons
        power_btn = document.querySelector("#freestylePower")
        if power_btn:
            power_btn.innerHTML = power_svg
            window.console.log("‚úÖ Injected power SVG")
        else:
            window.console.warn("‚ö†Ô∏è Power button not found")
            
        power_btn_matrix = document.querySelector("#freestylePowerMatrix")
        if power_btn_matrix:
            power_btn_matrix.innerHTML = power_svg
            window.console.log("‚úÖ Injected power matrix SVG")
        else:
            window.console.warn("‚ö†Ô∏è Power button matrix not found")

          
        subscript_btn = document.querySelector("#freestyleSubscript")
        if subscript_btn:
            subscript_btn.innerHTML = subscript_svg
            window.console.log("‚úÖ Injected subscript SVG")
        else:
            window.console.warn("‚ö†Ô∏è Subscript button not found")

                  
        subscript_btn_marix = document.querySelector("#freestyleSubscriptMatrix")
        if subscript_btn_marix:
            subscript_btn_marix.innerHTML = subscript_svg
            window.console.log("‚úÖ Injected subscript SVG")
        else:
            window.console.warn("‚ö†Ô∏è Subscript button not found")

            
        window.console.log("‚úÖ All freestyle SVGs injected successfully")
    except Exception as e:
        window.console.error(f"Failed to inject freestyle SVGs: {e}")
        import traceback
        window.console.error(traceback.format_exc())

  def toggle_keyboard_accordion(self, target_id):
      """Toggle keyboard accordion, move to top, and disable/enable MathQuill textarea"""
      target_body = document.querySelector(f"#{target_id}")
      if not target_body:
          return

      # Prefer closest keyboard-accordion ancestor (more robust than parentElement)
      accordion = target_body.closest(".keyboard-accordion") or target_body.parentElement
      if not accordion:
          return

      # Find the keyboard container (prefer explicit container id, fallback to parent)
      keyboard_container = document.querySelector("#keyboardAccordionsContainer") or accordion.parentElement

      # Check if currently open
      is_open = accordion.classList.contains("open")

      # Determine which field to affect (problem input or answer input)
      current_field = None
      if getattr(self, "freestyle_problem", False):
          # Problem is set, use answer field
          current_field = getattr(self, "freestyle_answer_mf", None)
      else:
          # No problem yet, use problem input field
          current_field = getattr(self, "freestyle_problem_mf", None)

      if is_open:
          # Close this accordion
          accordion.classList.remove("open")

          # Check if any accordion is still open
          all_accordions = document.querySelectorAll(".keyboard-accordion")
          any_open = False
          for i in range(all_accordions.length):
              if all_accordions[i].classList.contains("open"):
                  any_open = True
                  break

          # If no accordion is open, re-enable MathQuill textarea (activate keyboard)
          if not any_open and current_field:
              try:
                  el = current_field.el()
                  textarea = el.querySelector('textarea')
                  if textarea:
                      textarea.removeAttribute('readonly')
                      textarea.removeAttribute('disabled')
                      textarea.style.pointerEvents = 'auto'
                      textarea.style.opacity = '1'
                      window.console.log("‚úÖ MathQuill textarea enabled (no accordion open)")
              except Exception as e:
                  window.console.error(f"Failed to enable textarea: {e}")
      else:
          # Close all other accordions first
          all_accordions = document.querySelectorAll(".keyboard-accordion")
          for i in range(all_accordions.length):
              all_accordions[i].classList.remove("open")

          # Open this accordion
          accordion.classList.add("open")

          # Identify if this is the Navigation accordion
          is_navigation = target_id == "numbersBody"

          # Move this accordion to the top of the accordion stack:
          # ‚Äî find the first existing .keyboard-accordion child (ignore labels/header nodes),
          # ‚Äî insert before it, unless it's already the first one.
          try:
              if keyboard_container:
                  first_accordion = keyboard_container.querySelector('.keyboard-accordion')

                  if is_navigation:
                      # Navigation accordion should be in second position
                      # Find the first accordion and insert after it
                      if first_accordion:
                          # Insert after the first accordion (second position)
                          if first_accordion.nextElementSibling:
                              keyboard_container.insertBefore(accordion, first_accordion.nextElementSibling)
                          else:
                              keyboard_container.appendChild(accordion)
                          window.console.log("‚úÖ Navigation accordion moved to second position")
                      else:
                          # No accordion exists, just append
                          keyboard_container.appendChild(accordion)
                          window.console.log("‚úÖ Navigation accordion appended (no existing accordion)")
                  else:
                      # Non-navigation accordion goes to first position
                      # If there's a first accordion and it's not this one, insert before it.
                      if first_accordion and first_accordion != accordion:
                          keyboard_container.insertBefore(accordion, first_accordion)
                          window.console.log("‚úÖ Accordion moved to top (inserted before first .keyboard-accordion)")
                      else:
                          # If no .keyboard-accordion exists, append as the first accordion child
                          if not first_accordion:
                              keyboard_container.appendChild(accordion)
                              window.console.log("‚úÖ Accordion appended (no existing .keyboard-accordion found)")
                          else:
                              # first_accordion == accordion -> it's already at top, do nothing
                              window.console.log("‚ÑπÔ∏è Accordion is already at top")

                      # After moving non-navigation accordion to top, ensure Navigation is in second position
                      self._ensure_navigation_second_position(keyboard_container)

          except Exception as e:
              window.console.error(f"Failed to move accordion: {e}")

          # Disable MathQuill textarea when accordion opens
          if current_field:
              try:
                  el = current_field.el()
                  textarea = el.querySelector('textarea')
                  if textarea:
                      textarea.setAttribute('readonly', 'readonly')
                      textarea.setAttribute('disabled', 'disabled')
                      textarea.style.pointerEvents = 'none'
                      textarea.style.opacity = '0.7'
                      window.console.log("‚úÖ MathQuill textarea disabled")
              except Exception as e:
                  window.console.error(f"Failed to disable textarea: {e}")

  def _ensure_navigation_second_position(self, keyboard_container):
      """Helper method to ensure Navigation accordion is always in second position"""
      try:
          # Find the navigation accordion by looking for the one with navBody
          all_accordions = keyboard_container.querySelectorAll('.keyboard-accordion')
          nav_accordion = None

          for i in range(all_accordions.length):
              acc = all_accordions[i]
              # Check if this accordion contains the navBody
              if acc.querySelector('#numbersBody'):
                  nav_accordion = acc
                  break

          if nav_accordion and all_accordions.length >= 2:
              first_accordion = all_accordions[0]
              second_accordion = all_accordions[1]

              # If navigation is not in second position, move it there
              if nav_accordion != second_accordion:
                  # Insert navigation after the first accordion
                  if first_accordion.nextElementSibling:
                      keyboard_container.insertBefore(nav_accordion, first_accordion.nextElementSibling)
                  else:
                      keyboard_container.appendChild(nav_accordion)
                  window.console.log("‚úÖ Navigation accordion repositioned to second position")

      except Exception as e:
          window.console.error(f"Failed to ensure navigation second position: {e}")

  """
  ## Summary of Complete Integration:

  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  ‚îÇ                  KeyboardInputHandler                        ‚îÇ
  ‚îÇ              (Shared by Both Systems)                        ‚îÇ
  ‚îÇ  - Handles all input actions (navigation, operators, etc.)  ‚îÇ
  ‚îÇ  - Includes limit support: \\lim, \\lim_sequence, etc.     ‚îÇ
  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                      ‚ñ≤                    ‚ñ≤
                      ‚îÇ                    ‚îÇ
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ   Teacher-Based      ‚îÇ    ‚îÇ     Freestyle        ‚îÇ
        ‚îÇ   Problem Solving    ‚îÇ    ‚îÇ   Problem Solving    ‚îÇ
        ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
        ‚îÇ generate_minimal_    ‚îÇ    ‚îÇ handle_freestyle_    ‚îÇ
        ‚îÇ   buttons()          ‚îÇ    ‚îÇ   input()            ‚îÇ
        ‚îÇ   - Detects Limit    ‚îÇ    ‚îÇ   - Static keyboard  ‚îÇ
        ‚îÇ   - Adds lim buttons ‚îÇ    ‚îÇ   - All buttons      ‚îÇ
        ‚îÇ                      ‚îÇ    ‚îÇ                      ‚îÇ
        ‚îÇ handle_input_button()‚îÇ    ‚îÇ toggle_keyboard_     ‚îÇ
        ‚îÇ   - Step-specific    ‚îÇ    ‚îÇ   accordion()        ‚îÇ
        ‚îÇ   - Calls handler    ‚îÇ    ‚îÇ   - Manages state    ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
  """

  def toggle_keyboard_accordion_old(self, target_id):
      """Toggle keyboard accordion, move to top, and disable/enable MathQuill textarea"""
      target_body = document.querySelector(f"#{target_id}")
      if not target_body:
          return

      # Prefer closest keyboard-accordion ancestor (more robust than parentElement)
      accordion = target_body.closest(".keyboard-accordion") or target_body.parentElement
      if not accordion:
          return

      # Find the keyboard container (prefer explicit container id, fallback to parent)
      keyboard_container = document.querySelector("#keyboardAccordionsContainer") or accordion.parentElement

      # Check if currently open
      is_open = accordion.classList.contains("open")

      # Determine which field to affect (problem input or answer input)
      current_field = None
      if getattr(self, "freestyle_problem", False):
          # Problem is set, use answer field
          current_field = getattr(self, "freestyle_answer_mf", None)
      else:
          # No problem yet, use problem input field
          current_field = getattr(self, "freestyle_problem_mf", None)

      if is_open:
          # Close this accordion
          accordion.classList.remove("open")

          # Re-enable MathQuill textarea when accordion closes
          if current_field:
              try:
                  el = current_field.el()
                  textarea = el.querySelector('textarea')
                  if textarea:
                      textarea.removeAttribute('readonly')
                      textarea.removeAttribute('disabled')
                      textarea.style.pointerEvents = 'auto'
                      textarea.style.opacity = '1'
                      window.console.log("‚úÖ MathQuill textarea enabled")
              except Exception as e:
                  window.console.error(f"Failed to enable textarea: {e}")
      else:
          # Close all other accordions first
          all_accordions = document.querySelectorAll(".keyboard-accordion")
          for i in range(all_accordions.length):
              all_accordions[i].classList.remove("open")

          # Open this accordion
          accordion.classList.add("open")

          # Move this accordion to the top of the accordion stack:
          # ‚Äî find the first existing .keyboard-accordion child (ignore labels/header nodes),
          # ‚Äî insert before it, unless it's already the first one.
          try:
              if keyboard_container:
                  first_accordion = keyboard_container.querySelector('.keyboard-accordion')
                  # If there's a first accordion and it's not this one, insert before it.
                  if first_accordion and first_accordion != accordion:
                      keyboard_container.insertBefore(accordion, first_accordion)
                      window.console.log("‚úÖ Accordion moved to top (inserted before first .keyboard-accordion)")
                  else:
                      # If no .keyboard-accordion exists, append as the first accordion child
                      if not first_accordion:
                          keyboard_container.appendChild(accordion)
                          window.console.log("‚úÖ Accordion appended (no existing .keyboard-accordion found)")
                      else:
                          # first_accordion == accordion -> it's already at top, do nothing
                          window.console.log("‚ÑπÔ∏è Accordion is already at top")
          except Exception as e:
              window.console.error(f"Failed to move accordion: {e}")

          # Disable MathQuill textarea when accordion opens
          if current_field:
              try:
                  el = current_field.el()
                  textarea = el.querySelector('textarea')
                  if textarea:
                      textarea.setAttribute('readonly', 'readonly')
                      textarea.setAttribute('disabled', 'disabled')
                      textarea.style.pointerEvents = 'none'
                      textarea.style.opacity = '0.7'
                      window.console.log("‚úÖ MathQuill textarea disabled")
              except Exception as e:
                  window.console.error(f"Failed to disable textarea: {e}")

  def init_freestyle_page(self):
      """Initialize the freestyle problem page with MathQuill fields"""
      if not self.MQ:
          return

      # Initialize MathQuill fields
      problem_input = document.querySelector("#freestyleProblemInput")
      answer_input = document.querySelector("#freestyleAnswerInput")

      if problem_input:
          self.freestyle_problem_mf = self.MQ.MathField(problem_input)

      if answer_input:
          self.freestyle_answer_mf = self.MQ.MathField(answer_input)

      # Setup accordion toggles for all keyboard sections
      accordion_headers = document.querySelectorAll(".keyboard-accordion-header")
      for i in range(accordion_headers.length):
          header = accordion_headers[i]
          target_id = header.getAttribute("data-target")

          def make_accordion_handler(target):
              def handler(e):
                  self.toggle_keyboard_accordion(target)
              return handler

          header.addEventListener("click", create_proxy(make_accordion_handler(target_id)))

      # Setup event listeners for freestyle page
      set_btn = document.querySelector("#setFreestyleProblem")
      if set_btn:
          set_btn.addEventListener("click", create_proxy(lambda e: self.set_freestyle_problem(e)))

      submit_btn = document.querySelector("#freestyleSubmit")
      if submit_btn:
          submit_btn.addEventListener("click", create_proxy(lambda e: self.freestyle_submit(e)))

      finalize_btn = document.querySelector("#freestyleFinalize")
      if finalize_btn:
          finalize_btn.addEventListener("click", create_proxy(lambda e: self.freestyle_finalize(e)))

      reset_btn = document.querySelector("#freestyleReset")
      if reset_btn:
          reset_btn.addEventListener("click", create_proxy(lambda e: self.freestyle_reset(e)))

      # Setup keyboard buttons
      keyboard_btns = document.querySelectorAll(".keyboard-accordion-body .input-btn")
      for i in range(keyboard_btns.length):
          btn = keyboard_btns[i]
          action = btn.getAttribute("data-action")

          def make_keyboard_handler(act):
              def handler(e):
                  self.handle_freestyle_input(act)
              return handler

          btn.addEventListener("click", create_proxy(make_keyboard_handler(action)))

      # ‚úÖ Inject SVG icons into navigation buttons
      self.inject_freestyle_navigation_svgs()

  def handle_freestyle_input(self, action):
      """Handle keyboard input for freestyle fields (problem or answer)"""
      # Determine which field to use
      if self.freestyle_problem:
          # Problem is set, input goes to answer
          target_field = self.freestyle_answer_mf
      else:
          # No problem yet, input goes to problem input
          target_field = self.freestyle_problem_mf

      if not target_field:
          window.console.error("No target field available")
          return

      # ‚úÖ Use the common KeyboardInputHandler
      KeyboardInputHandler.handle_action(target_field, action)

  def _show_limit_validation_error_popup(self, message):
      """Display full-screen limit validation error popup optimized for mobile"""
      safe_msg = str(message).replace("`", "'").replace("\\", "\\\\").replace("\n", "\\n")
      js_code = f"""
          (function(){{
              let existing = document.querySelector('#limitValidationErrorPopup');
              if(existing) existing.remove();

              let popup = document.createElement('div');
              popup.id = 'limitValidationErrorPopup';

              // Detect if mobile/small screen
              let isMobile = window.innerWidth <= 768;

              if(isMobile) {{
                  // Mobile styles - fullscreen-like
                  popup.style.cssText = `
                      position:fixed;
                      top:0;
                      left:0;
                      right:0;
                      bottom:0;
                      background:#fef2f2;
                      color:#991b1b;
                      font-family:system-ui, -apple-system, sans-serif;
                      padding:60px 16px 16px 16px;
                      border:none;
                      border-radius:0;
                      box-shadow:none;
                      white-space:pre-wrap;
                      z-index:9999;
                      overflow:auto;
                      -webkit-overflow-scrolling:touch;
                  `;
              }} else {{
                  // Desktop styles - centered dialog
                  popup.style.cssText = `
                      position:fixed;
                      top:50%;
                      left:50%;
                      transform:translate(-50%, -50%);
                      background:#fef2f2;
                      color:#991b1b;
                      font-family:system-ui, -apple-system, sans-serif;
                      padding:24px 24px 16px 24px;
                      border:3px solid #dc2626;
                      border-radius:12px;
                      box-shadow:0 12px 40px rgba(220, 38, 38, 0.3);
                      white-space:pre-wrap;
                      z-index:9999;
                      max-width:800px;
                      max-height:90vh;
                      overflow:auto;
                  `;
              }}

              let btn = document.createElement('button');
              btn.textContent = '‚úñ';
              btn.title = 'Close';

              if(isMobile) {{
                  // Mobile close button - larger and top-right
                  btn.style.cssText = `
                      position:fixed;
                      top:12px;
                      right:12px;
                      width:44px;
                      height:44px;
                      border:none;
                      background:#dc2626;
                      color:#fff;
                      font-size:24px;
                      font-weight:bold;
                      cursor:pointer;
                      line-height:1;
                      border-radius:8px;
                      box-shadow:0 4px 12px rgba(220,38,38,0.4);
                      z-index:10000;
                  `;
              }} else {{
                  // Desktop close button - small and subtle
                  btn.style.cssText = `
                      position:absolute;
                      top:8px;
                      right:10px;
                      border:none;
                      background:transparent;
                      color:#dc2626;
                      font-size:20px;
                      font-weight:bold;
                      cursor:pointer;
                      line-height:1;
                  `;
              }}
              btn.onclick = () => popup.remove();

              let title = document.createElement('div');
              title.textContent = '‚ö†Ô∏è Invalid Limit Problem';

              if(isMobile) {{
                  title.style.cssText = `
                      font-size:24px;
                      font-weight:bold;
                      color:#dc2626;
                      margin-bottom:20px;
                      padding-right:50px;
                      line-height:1.3;
                  `;
              }} else {{
                  title.style.cssText = `
                      font-size:20px;
                      font-weight:bold;
                      color:#dc2626;
                      margin-bottom:16px;
                  `;
              }}

              let content = document.createElement('div');
              content.textContent = `{safe_msg}`;

              if(isMobile) {{
                  content.style.cssText = `
                      font-size:16px;
                      line-height:1.6;
                      word-break:break-word;
                      padding-top:8px;
                      margin-bottom:20px;
                  `;
              }} else {{
                  content.style.cssText = `
                      font-size:14px;
                      line-height:1.6;
                      padding-top:8px;
                      margin-bottom:16px;
                  `;
              }}

              let validExamples = document.createElement('div');
              validExamples.innerHTML = `
                  <div style='margin-bottom:20px;padding:16px;background:#dcfce7;border-radius:8px;border:2px solid #86efac;'>
                      <div style='font-weight:bold;margin-bottom:12px;color:#166534;'>‚úÖ Examples of VALID limit problems:</div>
                      <div style='color:#166534;line-height:2.2;'>
                          \\\\(\\\\lim_{{x \\\\to 0}} \\\\frac{{\\\\sin(x)}}{{x}} = 1\\\\)<br>
                          \\\\(\\\\lim_{{x \\\\to \\\\infty}} \\\\left(1 + \\\\frac{{1}}{{x}}\\\\right)^x = e\\\\)<br>
                          \\\\(\\\\lim_{{x \\\\to 2}} \\\\frac{{x^2 - 4}}{{x - 2}} = 4\\\\)<br>
                          \\\\(\\\\lim_{{x \\\\to 0}} \\\\frac{{e^x - 1}}{{x}} = 1\\\\)
                      </div>
                  </div>
              `;

              let invalidExamples = document.createElement('div');
              invalidExamples.innerHTML = `
                  <div style='padding:16px;background:#fee2e2;border-radius:8px;border:2px solid #fecaca;'>
                      <div style='font-weight:bold;margin-bottom:16px;color:#7f1d1d;'>‚ùå Examples to AVOID:</div>

                      <div style='margin-bottom:14px;'>
                          <div style='font-weight:600;color:#7f1d1d;margin-bottom:6px;'>Limits that equal infinity:</div>
                          <div style='color:#7f1d1d;line-height:1.8;margin-left:10px;'>
                              \\\\(\\\\lim_{{x \\\\to 0}} \\\\frac{{1}}{{x^2}}\\\\) &nbsp;&nbsp; \\\\(\\\\lim_{{x \\\\to \\\\infty}} x^2\\\\)
                          </div>
                      </div>

                      <div style='margin-bottom:14px;'>
                          <div style='font-weight:600;color:#7f1d1d;margin-bottom:6px;'>Left and right limits differ:</div>
                          <div style='color:#7f1d1d;line-height:1.8;margin-left:10px;'>
                              \\\\(\\\\lim_{{x \\\\to 0}} \\\\frac{{|x|}}{{x}}\\\\) &nbsp;&nbsp; \\\\(\\\\lim_{{x \\\\to 0}} \\\\frac{{x}}{{|x|}}\\\\)
                          </div>
                      </div>

                      <div style='margin-bottom:14px;'>
                          <div style='font-weight:600;color:#7f1d1d;margin-bottom:6px;'>Oscillating limits:</div>
                          <div style='color:#7f1d1d;line-height:1.8;margin-left:10px;'>
                              \\\\(\\\\lim_{{x \\\\to 0}} \\\\sin\\\\left(\\\\frac{{1}}{{x}}\\\\right)\\\\) &nbsp;&nbsp; \\\\(\\\\lim_{{x \\\\to \\\\infty}} \\\\sin(x)\\\\)
                          </div>
                      </div>

                      <div>
                          <div style='font-weight:600;color:#7f1d1d;margin-bottom:6px;'>Undefined/indeterminate:</div>
                          <div style='color:#7f1d1d;line-height:1.8;margin-left:10px;'>
                              \\\\(\\\\lim_{{x \\\\to 0}} \\\\cos\\\\left(\\\\frac{{1}}{{x^2}}\\\\right)\\\\)
                          </div>
                      </div>
                  </div>
              `;

              if(isMobile) {{
                  validExamples.querySelector('div').style.fontSize = '15px';
                  invalidExamples.querySelector('div').style.fontSize = '15px';
              }}

              popup.appendChild(btn);
              popup.appendChild(title);
              popup.appendChild(content);
              popup.appendChild(validExamples);
              popup.appendChild(invalidExamples);
              document.body.appendChild(popup);

              // Render MathJax after adding to DOM
              if(window.MathJax && window.MathJax.typesetPromise) {{
                  window.MathJax.typesetPromise([popup]);
              }}
          }})();
      """
      window.eval(js_code)
  def set_freestyle_problem(self, event):
      """Set the freestyle problem from user input and create solve area dynamically"""
      window.console.log("=== set_freestyle_problem called ===")

      if not self.freestyle_problem_mf:
          window.alert("‚ö†Ô∏è Problem input not ready")
          return

      problem_latex = self.freestyle_problem_mf.latex().strip()
      window.console.log(f"Problem latex: {problem_latex}")

      if not problem_latex:
          window.alert("‚ö†Ô∏è Please enter a problem first")
          return

      # Parse the problem to validate it
      try:
          window.console.log("Parsing problem...")
          parsed = self.math_parser.parse(problem_latex)
          window.console.log(f"Parsed: {parsed}")

          if parsed is None:
              window.alert("‚ö†Ô∏è Could not parse the problem. Please check your input.")
              return
      except Exception as e:
          window.console.error(f"Parse error: {e}")
          import traceback
          window.console.error(traceback.format_exc())
          window.alert(f"‚ö†Ô∏è Parse error: {e}")
          return

      # In the set_freestyle_problem method, replace the existing limit validation section:

      # Validate limit problems
      try:
          window.console.log("Validating limit problem...")
          is_valid, error_msg = self.math_parser.validate_limit(parsed)
          if not is_valid:
              window.console.error(f"Invalid limit problem: {error_msg}")

              # Build comprehensive error message
              full_error_msg = f"""{error_msg}

      Please choose a limit problem with a finite, well-defined value.

      Common issues to avoid:
      - Limits that equal infinity or negative infinity
      - Limits with different left and right values (discontinuities)
      - Oscillating limits that don't converge to a single value
      - Limits that are undefined or indeterminate

      Try using limits that evaluate to specific finite numbers instead."""

              self._show_limit_validation_error_popup(full_error_msg)
              return
          window.console.log("‚úÖ Limit validation passed")
      except Exception as e:
          window.console.error(f"Limit validation error: {e}")
          import traceback
          window.console.error(traceback.format_exc())
          # Continue anyway if validation fails (non-limit problems)
          pass

      # --- KEY CHANGE IS HERE ---
      # We normalize to check for errors, but we store the RAW parsed expression.
      # The actual normalization for comparison will happen in the submit handler.
      try:
          window.console.log("Normalizing to check for errors...")
          # We still run normalize here to catch any errors during processing
          # --- NEW CODE ---
          normalized = self.math_parser.normalize(parsed)
          window.console.log(f"Normalization check passed. Result: {normalized}")

          # Store the problem with the RAW parsed expression
          self.freestyle_problem = {
              "latex": problem_latex,
              "parsed": parsed,  # <-- Store the raw Lark Tree or SymPy expression
              # "normalized" and "structure" are no longer needed to be stored here
          }
          window.console.log("‚úÖ Problem stored successfully with raw parsed expression")

      except Exception as e:
          window.console.error(f"Error processing problem: {e}")
          import traceback
          window.console.error(traceback.format_exc())
          window.alert(f"‚ö†Ô∏è Error: {e}")
          return

      # Reset state
      self.freestyle_attempts = []
      self.freestyle_correct = False
      self.freestyle_finalized = False

      if self.freestyle_answer_mf:
          self.freestyle_answer_mf.latex("")

      # Create or update solve area dynamically
      try:
          # Check if solve area already exists
          solve_area = document.querySelector("#freestyleSolveArea")
          keyboard_container = document.querySelector("#keyboardAccordionsContainer")

          if not solve_area:
              # Create solve area if it doesn't exist
              solve_area = document.createElement("div")
              solve_area.id = "freestyleSolveArea"
              solve_area.innerHTML = """
              <hr style='margin:20px 0;border:none;border-top:2px solid #e5e7eb;'>

              <div style='background:#f0fdf4;padding:16px;border-radius:8px;margin-bottom:16px;'>
                <div style='font-weight:700;margin-bottom:8px;'>Problem to Solve:</div>
                <div id='freestyleProblemDisplay' style='font-size:20px;overflow-x:auto;'></div>
              </div>

              <div style='margin-bottom:20px;'>
                <label>üéØ Your Solution</label>
                <div style='overflow-x:auto;overflow-y:hidden;max-width:100%;-webkit-overflow-scrolling:touch;border:2px solid #e6eef8;border-radius:8px;padding:10px;background:#fff;'>
                  <div id='freestyleAnswerInput' class='math-input' style='min-height:60px;border:none;padding:0;'></div>
                </div>

                <div style='display:flex;flex-direction:column;gap:8px;margin-top:16px;'>
                  <button id='freestyleSubmit' class='btn'>Submit Attempt</button>
                  <button id='freestyleFinalize' class='btn ghost' disabled>Finalize Solution</button>
                  <button id='freestyleReset' class='btn ghost' style='background:#dc2626;color:#fff;'>Reset Problem</button>
                </div>
              </div>

              <div id='freestyleFeedback' style='margin-top:16px;min-height:20px;'></div>
              <div id='freestyleHistory' style='margin-top:16px;min-height:20px;'></div>
              """

          # Insert solve area BEFORE keyboard
          if keyboard_container:
              keyboard_parent = keyboard_container.parentElement
              if keyboard_parent:
                  # Check if solve area is already in the right position
                  if solve_area.nextElementSibling != keyboard_container:
                      keyboard_parent.insertBefore(solve_area, keyboard_container)
                      window.console.log("‚úÖ Solve area positioned above keyboard")

          # Show solve area
          solve_area.style.display = "block"

          # Re-initialize MathQuill answer field if needed
          answer_input = document.querySelector("#freestyleAnswerInput")
          if answer_input and not self.freestyle_answer_mf:
              if self.MQ:
                  self.freestyle_answer_mf = self.MQ.MathField(answer_input)
                  window.console.log("‚úÖ Answer MathQuill field initialized")

          # Re-attach button event listeners
          submit_btn = document.querySelector("#freestyleSubmit")
          if submit_btn:
              # Remove old listener if exists, then add new
              submit_btn.replaceWith(submit_btn.cloneNode(True))
              submit_btn = document.querySelector("#freestyleSubmit")
              submit_btn.addEventListener("click", create_proxy(lambda e: self.freestyle_submit(e)))

          finalize_btn = document.querySelector("#freestyleFinalize")
          if finalize_btn:
              finalize_btn.replaceWith(finalize_btn.cloneNode(True))
              finalize_btn = document.querySelector("#freestyleFinalize")
              finalize_btn.addEventListener("click", create_proxy(lambda e: self.freestyle_finalize(e)))
              finalize_btn.disabled = True

          reset_btn = document.querySelector("#freestyleReset")
          if reset_btn:
              reset_btn.replaceWith(reset_btn.cloneNode(True))
              reset_btn = document.querySelector("#freestyleReset")
              reset_btn.addEventListener("click", create_proxy(lambda e: self.freestyle_reset(e)))

          # Update problem display
          problem_display = document.querySelector("#freestyleProblemDisplay")
          if problem_display:
              problem_display.innerHTML = f"\\({problem_latex}\\)"
              # Render MathJax
              if hasattr(window, 'MathJax'):
                  window.MathJax.typesetPromise([problem_display])

          # Clear feedback and history
          feedback = document.querySelector("#freestyleFeedback")
          if feedback:
              feedback.innerHTML = ""

          history = document.querySelector("#freestyleHistory")
          if history:
              history.innerHTML = ""

          window.console.log("‚úÖ UI updated successfully")
          window.alert("‚úÖ Problem set! Now solve it.")

      except Exception as e:
          window.console.error(f"Error updating UI: {e}")
          import traceback
          window.console.error(traceback.format_exc())
          window.alert(f"‚ö†Ô∏è Error updating display: {e}")

  def freestyle_submit(self, event):
      """Submit a solution attempt for the freestyle problem"""
      window.console.log("=== freestyle_submit called ===")

      if not self.freestyle_problem:
          window.alert("‚ö†Ô∏è Set a problem first")
          return

      if not self.freestyle_answer_mf:
          window.alert("‚ö†Ô∏è Answer input not ready")
          return

      user_latex = self.freestyle_answer_mf.latex().strip()
      window.console.log(f"User latex: '{user_latex}'")

      if not user_latex:
          window.alert("‚ö†Ô∏è Enter an answer first")
          return

      # Parse user answer
      try:
          window.console.log("Parsing user answer...")
          window.console.log(f"Raw user_latex before parsing: '{user_latex}'")

          # Check if latex is empty or whitespace only
          if not user_latex or user_latex.isspace():
              self.show_freestyle_feedback("‚ö†Ô∏è Please enter a valid answer", "#b91c1c")
              return

          parsed_user = self.math_parser.parse(user_latex)
          window.console.log(f"Parsed user: {parsed_user}")

          if parsed_user is None:
              # Parse returns None - invalid syntax
              self.show_freestyle_feedback("‚ö†Ô∏è Could not parse your answer. Please check your syntax.", "#b91c1c")
              return
      except Exception as e:
          window.console.error(f"Parse error: {e}")
          import traceback
          window.console.error(traceback.format_exc())
          self.show_freestyle_feedback(f"‚ö†Ô∏è Parse error: {e}", "#b91c1c")
          return

      # Validate user's limit answer (if it's a limit)
      try:
          is_valid, error_msg = self.math_parser.validate_limit(parsed_user)
          if not is_valid:
              window.console.error(f"Invalid limit answer: {error_msg}")
              self.show_freestyle_feedback(
                  f"‚ö†Ô∏è Invalid answer: {error_msg}<br><br>"
                  "Please provide a finite, well-defined limit value.",
                  "#b91c1c"
              )
              return
      except Exception as e:
          window.console.error(f"Limit validation error: {e}")
          # Continue anyway if validation fails
          pass

      # --- KEY CHANGE IS HERE ---
      # Get problem data and normalize it alongside the user's answer
      try:
          window.console.log("Getting and normalizing problem data...")

          # Get the raw parsed expression
          parsed_problem = self.freestyle_problem["parsed"]
          window.console.log(f"Raw problem parsed: {parsed_problem}")

          # Normalize the problem expression, passing the transformer
          problem_normalized = self.math_parser.normalize(parsed_problem)

      except Exception as e:
          window.console.error(f"Error getting/normalizing problem data: {e}")
          import traceback
          window.console.error(traceback.format_exc())
          self.show_freestyle_feedback(f"‚ö†Ô∏è Error: Problem data could not be processed", "#b91c1c")
          return

      # Normalize user answer
      try:
          window.console.log("Normalizing user answer...")
          # Normalize the user's answer, also passing the transformer
          user_normalized = self.math_parser.normalize(parsed_user)
          window.console.log(f"Problem normalized: {problem_normalized}")
          window.console.log(f"User normalized: {user_normalized}")
      except Exception as e:
          window.console.error(f"Normalization error: {e}")
          import traceback
          window.console.error(traceback.format_exc())
          self.show_freestyle_feedback(f"‚ö†Ô∏è Error normalizing answer: {e}", "#b91c1c")
          return

      # Compare answers
      try:
          window.console.log("Comparing answers...")
          window.console.log(f"Comparing: problem_normalized={problem_normalized}, user_normalized={user_normalized}")

          # The compare function should now work correctly with two normalized SymPy expressions
          correct = self.math_parser.compare(problem_normalized, user_normalized)
          window.console.log(f"Correct: {correct}")
      except Exception as e:
          window.console.error(f"Comparison error: {e}")
          import traceback
          window.console.error(traceback.format_exc())
          self.show_freestyle_feedback(f"‚ö†Ô∏è Error comparing answers: {e}", "#b91c1c")
          return

      # Record attempt
      try:
          attempt = {
              "attempt_number": len(self.freestyle_attempts) + 1,
              "answer_latex": user_latex,
              "correct": correct,
              "timestamp": window.Date.now()
          }
          self.freestyle_attempts.append(attempt)
          window.console.log(f"Attempt recorded: {attempt}")
      except Exception as e:
          window.console.error(f"Error recording attempt: {e}")

      # Update UI
      try:
          if correct:
              self.freestyle_correct = True
              self.show_freestyle_feedback(
                  "‚úÖ Correct! Your answer equals the problem.<br>"
                  "Click <strong>Finalize</strong> to verify your solution method.",
                  "#059669"
              )
              finalize_btn = document.querySelector("#freestyleFinalize")
              if finalize_btn:
                  finalize_btn.disabled = False
                  window.console.log("Finalize button enabled")
          else:
              self.show_freestyle_feedback("‚ùå Incorrect. Try again!", "#b91c1c")

          # Add to history
          self.add_freestyle_attempt_to_history(user_latex, correct)
          window.console.log("‚úÖ Submit completed successfully")

      except Exception as e:
          window.console.error(f"Error updating UI: {e}")
          import traceback
          window.console.error(traceback.format_exc())
          self.show_freestyle_feedback(f"‚ö†Ô∏è Error updating display: {e}", "#b91c1c")

  def _add_freestyle_finalize_to_history(self, user_struct, expected_struct, success):
    """Add finalize attempt to freestyle history display"""
    history = document.querySelector("#freestyleHistory")
    if not history:
        return
    
    if history.innerHTML == "":
        history.innerHTML = "<div style='font-weight:700;margin-bottom:10px;font-size:16px;'>Finalize Attempts:</div>"
    
    entry = document.createElement("div")
    entry.style.cssText = "margin-bottom:10px;padding:12px;border-radius:8px;"
    
    if success:
        entry.style.background = "#dcfce7"
        entry.style.border = "2px solid #86efac"
        status_text = "‚úÖ Structure Match"
        status_emoji = "üéØ"
    else:
        entry.style.background = "#fef3c7"
        entry.style.border = "2px solid #fbbf24"
        status_text = "‚ö†Ô∏è Structure Mismatch"
        status_emoji = "üîç"
    
    entry.innerHTML = f"""
    <div style='font-weight:700;font-size:15px;'>
        {status_emoji} Finalize Attempt #{self.freestyle_finalize_attempts} - {status_text}
    </div>
    <div style='margin-top:6px;padding:8px;background:#fff;border-radius:6px;overflow-x:auto;'>
        <strong>Your structure:</strong><br>
        Operations: {user_struct.get('operators', {})}<br>
        Values: {user_struct.get('operands', {})}
    </div>
    """
    
    if not success:
        expected_info = document.createElement("div")
        expected_info.style.cssText = "margin-top:6px;padding:8px;background:#fff;border-radius:6px;overflow-x:auto;"
        expected_info.innerHTML = f"""
        <strong>Expected structure:</strong><br>
        Operations: {expected_struct.get('operators', {})}<br>
        Values: {expected_struct.get('operands', {})}
        """
        entry.appendChild(expected_info)
    
    history.appendChild(entry)

  def _has_simpler_representation(self, expr):
    """
    Check if expression can be simplified by removing matrix operation metadata.
    Returns (has_simpler, simplified_expr)
    """
    import sympy as sp
    
    # Check if this is a matrix with operation metadata
    if isinstance(expr, sp.MatrixBase) and hasattr(expr, '_matrix_op_metadata'):
        # Create a fresh matrix without metadata
        simplified = sp.Matrix(expr)
        return (True, simplified)
    
    return (False, expr)
    
  def freestyle_finalize(self, event):
    """
    Finalize validates structure - checks for simplest representation.
    Handles matrix operations and warns if simpler form available.
    """
    
    window.console.log(f"üîç Freestyle finalize called")
    
    if not self.freestyle_correct:
        window.alert("‚ö†Ô∏è Submit a correct answer first")
        return
    
    if not self.freestyle_answer_mf:
        return
    
    user_latex = self.freestyle_answer_mf.latex().strip()
    
    # Parse user answer (preserve metadata for structure checking)
    parsed_user = self.math_parser.parse(user_latex)
    
    if parsed_user is None:
        window.alert("‚ö†Ô∏è Could not parse your answer")
        return
    
    # Get problem's parsed expression
    if not self.freestyle_problem:
        window.alert("‚ö†Ô∏è No problem set")
        return
    
    parsed_problem = self.freestyle_problem["parsed"]
    
    # ‚úÖ NEW: Check if problem has simpler representation
    problem_has_simpler, problem_simplified = self._has_simpler_representation(parsed_problem)
    user_has_simpler, user_simplified = self._has_simpler_representation(parsed_user)
    
    # If PROBLEM has matrix operations (not simplest), use simplified version for comparison
    if problem_has_simpler:
        window.console.log("‚ö†Ô∏è Problem contains matrix operations - using simplified form for comparison")
        comparison_problem = problem_simplified
        # Extract structure from simplified problem (no matrix ops)
        problem_struct = self.math_parser.extract_structure(problem_simplified)
    else:
        comparison_problem = parsed_problem
        problem_struct = self.math_parser.extract_structure(parsed_problem)
    
    # Extract user structure from ORIGINAL (with metadata if present)
    try:
        window.console.log("=" * 60)
        window.console.log("üìä FREESTYLE STRUCTURE COMPARISON")
        window.console.log("=" * 60)
        
        user_struct = self.math_parser.extract_structure(parsed_user)
        
        window.console.log(f"Expected structure (simplified):")
        window.console.log(f"  Operators: {problem_struct.get('operators', {})}")
        window.console.log(f"  Operands: {problem_struct.get('operands', {})}")
        window.console.log(f"  Matrix ops: {problem_struct.get('matrix_ops', [])}")
        window.console.log(f"User structure:")
        window.console.log(f"  Operators: {user_struct.get('operators', {})}")
        window.console.log(f"  Operands: {user_struct.get('operands', {})}")
        window.console.log(f"  Matrix ops: {user_struct.get('matrix_ops', [])}")
        window.console.log("=" * 60)
        
    except Exception as e:
        window.console.error(f"‚ùå Structure extraction error: {e}")
        import traceback
        window.console.error(traceback.format_exc())
        
        self.show_freestyle_feedback(
            "‚ö†Ô∏è Error analyzing structure. Finalized (no structure check).",
            "#92400e"
        )
        self.freestyle_finalized = True
        
        # Disable buttons
        finalize_btn = document.querySelector("#freestyleFinalize")
        if finalize_btn:
            finalize_btn.disabled = True
        submit_btn = document.querySelector("#freestyleSubmit")
        if submit_btn:
            submit_btn.disabled = True
        
        return
    
    # Check if expected answer has matrix operations
    expected_has_matrix_ops = len(problem_struct.get("matrix_ops", [])) > 0
    user_has_matrix_ops = len(user_struct.get("matrix_ops", [])) > 0
    
    window.console.log(f"üî¢ Expected has matrix ops: {expected_has_matrix_ops}")
    window.console.log(f"üî¢ User has matrix ops: {user_has_matrix_ops}")
    
    # Track finalize attempts
    if not hasattr(self, 'freestyle_finalize_attempts'):
        self.freestyle_finalize_attempts = 0
    self.freestyle_finalize_attempts += 1
    
    # ‚úÖ KEY FIX: User shouldn't use matrix operations if expected doesn't need them
    if user_has_matrix_ops and not expected_has_matrix_ops:
        window.console.log("‚ùå User used matrix operations but simplest form doesn't need them")
        
        msg = f"""‚ùå Attempt {self.freestyle_finalize_attempts}: Not the simplest form.<br><br>
        <strong>‚ö†Ô∏è You don't need matrix row operations here!</strong><br>
        Your answer contains matrix operation notation, but the simplest form is just the final matrix.<br><br>
        <strong>Your answer:</strong> Matrix with row operations<br>
        <strong>Simplest form:</strong> Just the resulting matrix<br><br>
        <strong>üí° Try entering just the final matrix without the operation notation.</strong>
        """
        
        color = "#dc2626"
        self.show_freestyle_feedback(msg, color)
        self._add_freestyle_finalize_to_history(user_struct, problem_struct, False)
        
        # Re-render MathJax
        feedback = document.querySelector("#freestyleFeedback")
        if feedback and hasattr(window, 'MathJax'):
            window.MathJax.typesetPromise([feedback])
        
        return
    
    # Standard structure comparison
    same_operators = user_struct.get("operators", {}) == problem_struct.get("operators", {})
    same_operands = user_struct.get("operands", {}) == problem_struct.get("operands", {})
    same_matrix_ops = user_struct.get("matrix_ops", []) == problem_struct.get("matrix_ops", [])
    
    same_structure = same_operators and same_operands and same_matrix_ops
    
    window.console.log(f"  Operators match: {same_operators}")
    window.console.log(f"  Operands match: {same_operands}")
    window.console.log(f"  Matrix ops match: {same_matrix_ops}")
    window.console.log(f"üéØ Structure match result: {same_structure}")
    
    if same_structure:
        # ‚úÖ SUCCESS - finalize and proceed
        window.console.log("‚úÖ STRUCTURE MATCH - Finalizing")
        
        self.freestyle_finalized = True
        
        # Disable buttons
        finalize_btn = document.querySelector("#freestyleFinalize")
        if finalize_btn:
            finalize_btn.disabled = True
            finalize_btn.style.opacity = "0.5"
            finalize_btn.style.cursor = "not-allowed"
        
        submit_btn = document.querySelector("#freestyleSubmit")
        if submit_btn:
            submit_btn.disabled = True
            submit_btn.style.opacity = "0.5"
            submit_btn.style.cursor = "not-allowed"
        
        # Compute simplest form for display
        try:
            import sympy as sp
            problem_expr = self.math_parser.normalize(comparison_problem)
            simplest = sp.simplify(problem_expr)
            simplest_latex = sp.latex(simplest)
        except Exception as e:
            window.console.error(f"Error computing simplest form: {e}")
            simplest_latex = None
        
        msg = "‚úÖ Finalized ‚Äî your solution method matches the simplest form!"
        
        if simplest_latex:
            msg += f"<br><br><strong>Simplest form:</strong> \\({simplest_latex}\\)"
        
        color = "#059669"
        
    else:
        # ‚ùå FAILED - keep trying
        window.console.log("‚ùå STRUCTURE MISMATCH - Not finalizing")
        
        # Build detailed feedback
        msg_parts = [f"‚ùå Attempt {self.freestyle_finalize_attempts}: Structure mismatch.<br><br>"]
        
        if not same_operators and not same_operands:
            msg_parts.append(
                "<strong>Both operations and values differ.</strong><br>"
                f"<small>Expected: ops={problem_struct.get('operators', {})}, vals={problem_struct.get('operands', {})}</small><br>"
                f"<small>Yours: ops={user_struct.get('operators', {})}, vals={user_struct.get('operands', {})}</small><br><br>"
            )
        elif not same_operators:
            msg_parts.append(
                "<strong>Same values, different method.</strong><br>"
                f"<small>Expected operators: {problem_struct.get('operators', {})}</small><br>"
                f"<small>Your operators: {user_struct.get('operators', {})}</small><br><br>"
            )
        elif not same_operands:
            msg_parts.append(
                "<strong>Correct operations, different values.</strong><br>"
                f"<small>Expected values: {problem_struct.get('operands', {})}</small><br>"
                f"<small>Your values: {user_struct.get('operands', {})}</small><br><br>"
            )
        
        msg_parts.append("<strong>üí° Try a different approach and click Finalize again.</strong>")
        msg = "".join(msg_parts)
        color = "#dc2626"
        
        self._add_freestyle_finalize_to_history(user_struct, problem_struct, False)
    
    self.show_freestyle_feedback(msg, color)
    
    # Re-render MathJax
    feedback = document.querySelector("#freestyleFeedback")
    if feedback and hasattr(window, 'MathJax'):
        window.MathJax.typesetPromise([feedback])

  def freestyle_reset(self, event):
      """Reset the freestyle problem"""
      if not window.confirm("Reset freestyle problem? This will clear your progress."):
          return

      self.freestyle_problem = None
      self.freestyle_attempts = []
      self.freestyle_correct = False
      self.freestyle_finalized = False

      if self.freestyle_problem_mf:
          self.freestyle_problem_mf.latex("")

      if self.freestyle_answer_mf:
          self.freestyle_answer_mf.latex("")

      solve_area = document.querySelector("#freestyleSolveArea")
      if solve_area:
          solve_area.style.display = "none"

      feedback = document.querySelector("#freestyleFeedback")
      if feedback:
          feedback.innerHTML = ""

      history = document.querySelector("#freestyleHistory")
      if history:
          history.innerHTML = ""

      submit_btn = document.querySelector("#freestyleSubmit")
      if submit_btn:
          submit_btn.disabled = False

      finalize_btn = document.querySelector("#freestyleFinalize")
      if finalize_btn:
          finalize_btn.disabled = True

      window.alert("‚úÖ Freestyle problem reset")

  def show_freestyle_feedback(self, message, color):
      """Show feedback for freestyle problem"""
      feedback = document.querySelector("#freestyleFeedback")
      if feedback:
          feedback.innerHTML = f"<div style='color:{color};background:{color}20;padding:14px;border-radius:8px;border:2px solid {color};'>{message}</div>"

  def add_freestyle_attempt_to_history(self, latex, correct):
      """Add attempt to freestyle history display"""
      history = document.querySelector("#freestyleHistory")
      if not history:
          return

      if history.innerHTML == "":
          history.innerHTML = "<div style='font-weight:700;margin-bottom:10px;font-size:16px;'>Attempt History:</div>"

      entry = document.createElement("div")
      entry.style.cssText = "margin-bottom:10px;padding:12px;border-radius:8px;"
      entry.style.background = "#dcfce7" if correct else "#fee2e2"
      entry.style.border = f"2px solid {'#86efac' if correct else '#fecaca'}"

      entry.innerHTML = f"""
      <div style='font-weight:700;font-size:15px;'>
          üìù Attempt #{len(self.freestyle_attempts)} - {'‚úÖ Correct' if correct else '‚ùå Incorrect'}
      </div>
      <div style='margin-top:8px;padding:10px;background:#fff;border-radius:6px;'>
          \\({latex}\\)
      </div>
      """

      history.appendChild(entry)

      # Render MathJax
      if hasattr(window, 'MathJax'):
          window.MathJax.typesetPromise([entry])
  def __init__(self):
    self.problem_set = []
    self.problem_states = {}
    self.current_problem_index = None
    self.current_problem_set_uuid = None
    self.math_parser = MathParser()
    self.MQ = None
    self.current_page = "problems"
    # Freestyle problem state
    self.freestyle_problem = None
    self.freestyle_problem_mf = None
    self.freestyle_answer_mf = None
    self.freestyle_attempts = []
    self.freestyle_correct = False
    self.freestyle_finalized = False
    # Import re at class level
    import re
    self.re = re
    # Global history for current problem
    self.global_attempt_history = []
    # ‚úÖ NEW: Store global history HTML per problem
    self.problem_global_histories = {}

  def init(self):
      # Initialize MathQuill
      if hasattr(window, 'MathQuill'):
          self.MQ = window.MathQuill.getInterface(2)

      # Setup event listeners
      self.setup_events()

      # Initialize freestyle page
      self.init_freestyle_page()

      # Load saved data
      self.load_from_storage()

      # Hide loading
      overlay = document.querySelector("#loadingOverlay")
      if overlay:
          overlay.style.opacity = "0"
          window.setTimeout(create_proxy(lambda: overlay.remove()), 400)

  def load_json(self, event):
      """Load problems from pasted JSON text"""
      textarea = document.querySelector("#pasteJson")
      if not textarea:
          window.alert("Paste area not found")
          return

      content = textarea.value.strip()
      if not content:
          window.alert("Please paste some data first")
          return

      try:
          base64_data = self.extract_base64(content)
          if base64_data:
              self.decode_and_load(base64_data)
              textarea.value = ""  # Clear after successful load
              self.show_indicator("üìã Data loaded successfully", "#10b981")
          else:
              window.alert("‚ùå No valid base64 data found. Please ensure you've pasted exported problem data.")
      except Exception as e:
          window.console.error(f"Error loading pasted data: {e}")
          window.alert(f"‚ùå Error loading data: {e}")

  def setup_events(self):
    # Navigation
    nav_items = document.querySelectorAll(".nav-item")
    window.console.log(f"Found {nav_items.length} navigation items")

    for i in range(nav_items.length):
        item = nav_items[i]
        page = item.getAttribute("data-page")
        window.console.log(f"Setting up nav for page: {page}")

        def make_nav_handler(p):
            def handler(e):
                window.console.log(f"Navigation clicked: {p}")
                self.show_page(p)
            return handler

        item.addEventListener("click", create_proxy(make_nav_handler(page)))

    # Mobile menu - KEEP THIS!
    menu_btn = document.querySelector("#menuBtn")
    if menu_btn:
        menu_btn.addEventListener("click", create_proxy(lambda e: self.toggle_sidebar(e)))
        window.console.log("‚úÖ Menu button event listener added")
    else:
        window.console.error("‚ùå Menu button not found")

    overlay = document.querySelector("#sidebarOverlay")
    if overlay:
        overlay.addEventListener("click", create_proxy(lambda e: self.close_sidebar(e)))

    # Load buttons - File upload should auto-process
    upload = document.querySelector("#uploadFile")
    if upload:
        upload.addEventListener("change", create_proxy(lambda e: self.handle_file_upload(e)))

    # Load JSON button for pasted text
    load_json_btn = document.querySelector("#loadJsonBtn")
    if load_json_btn:
        load_json_btn.addEventListener("click", create_proxy(lambda e: self.load_json(e)))
    else:
        window.console.error("Load JSON button not found")

    export_btn = document.querySelector("#exportProgressBtn")
    if export_btn:
        export_btn.addEventListener("click", create_proxy(lambda e: self.export_progress(e)))
    else:
        window.console.error("Submit progress button not found")
        
    whatsapp_btn = document.querySelector("#shareWhatsappProgressBtn")
    if whatsapp_btn:
        whatsapp_btn.addEventListener("click", create_proxy(lambda e: self.share_whatsapp_progress(e)))
    else:
        window.console.error("WhatsApp share button not found")

    telegram_btn = document.querySelector("#exportTelegramBtn")
    if telegram_btn:
        telegram_btn.addEventListener("click", create_proxy(lambda e: self.export_telegram(e)))
    else:
        window.console.error("Submit in Small Chunk button not found")

    clear_btn = document.querySelector("#clearStorageBtn")
    if clear_btn:
        clear_btn.addEventListener("click", create_proxy(lambda e: self.clear_all(e)))
    else:
        window.console.error("Clear storage button not found")
  def show_page(self, page_name):
      window.console.log(f"show_page called with: {page_name}")

      # Hide all pages
      pages = document.querySelectorAll(".page")
      window.console.log(f"Found {pages.length} pages")
      for i in range(pages.length):
          pages[i].classList.remove("active")

      # Show selected page
      target_id = f"{page_name}Page"
      target = document.querySelector(f"#{target_id}")
      window.console.log(f"Looking for: #{target_id}, found: {target}")

      if target:
          target.classList.add("active")
          #target.style.display = "block"
          window.console.log(f"Activated page: {page_name}")
          window.console.log(f"Page display style: {target.style.display}")
          window.console.log(f"Page classList: {target.classList}")

          # NEW: Debug the page content
          window.console.log(f"Page innerHTML length: {len(target.innerHTML)}")
          window.console.log(f"Page children count: {target.children.length}")

          # Check if specific elements exist
          if page_name == "load":
              upload_input = target.querySelector("#uploadFile")
              paste_textarea = target.querySelector("#pasteJson")
              load_btn = target.querySelector("#loadJsonBtn")

              window.console.log(f"Upload input found: {upload_input}")
              window.console.log(f"Paste textarea found: {paste_textarea}")
              window.console.log(f"Load button found: {load_btn}")

              # Check if the panel div exists
              panel = target.querySelector(".panel")
              window.console.log(f"Panel div found: {panel}")
              if panel:
                  window.console.log(f"Panel innerHTML: {panel.innerHTML[:200]}...")
      else:
          window.console.error(f"Page not found: #{target_id}")

      # Update nav
      nav_items = document.querySelectorAll(".nav-item")
      for i in range(nav_items.length):
          nav_items[i].classList.remove("active")

      active_nav = document.querySelector(f".nav-item[data-page='{page_name}']")
      if active_nav:
          active_nav.classList.add("active")
          window.console.log(f"Activated nav item for: {page_name}")

      self.current_page = page_name
      self.close_sidebar(None)
  def toggle_sidebar(self, event):
        window.console.log("üîß toggle_sidebar called")

        sidebar = document.querySelector("#sidebar")
        overlay = document.querySelector("#sidebarOverlay")

        window.console.log(f"Sidebar found: {sidebar is not None}")
        window.console.log(f"Overlay found: {overlay is not None}")

        if not sidebar:
            window.console.error("‚ùå Sidebar element not found!")
            return

        is_open = sidebar.classList.contains("open")
        window.console.log(f"Current state - is_open: {is_open}")

        if is_open:
            window.console.log("Closing sidebar...")
            sidebar.classList.remove("open")
            if overlay:
                overlay.classList.remove("show")
        else:
            window.console.log("Opening sidebar...")
            sidebar.classList.add("open")
            if overlay:
                overlay.classList.add("show")

        window.console.log("‚úÖ Toggle complete")
  def close_sidebar(self, event):
      sidebar = document.querySelector("#sidebar")
      overlay = document.querySelector("#sidebarOverlay")
      if sidebar:
          sidebar.classList.remove("open")
      if overlay:
          overlay.classList.remove("show")

  def extract_base64(self, text):
      # FIXED: Use self.re instead of importing re
      text = str(text).strip()

      # Check if it's an export format
      if "=== STUDENT PROGRESS EXPORT ===" in text:
          pattern = r"===.*?EXPORT.*?===(.*?)(?:===|$)"
          matches = self.re.findall(pattern, text, self.re.DOTALL)
          if matches:
              extracted = self.re.sub(r"[\s\r\n]+", "", "".join(matches))
              # Validate base64
              if self.is_valid_base64(extracted):
                  return extracted

      # Check if it's plain base64
      cleaned = self.re.sub(r"[\s\r\n]+", "", text)
      if self.is_valid_base64(cleaned):
          return cleaned

      return None

  def is_valid_base64(self, s):
      """Check if string is valid base64"""
      if not s:
          return False

      # Base64 should only contain these characters
      base64_pattern = r'^[A-Za-z0-9+/]*={0,2}$'
      if not self.re.match(base64_pattern, s):
          return False

      # Length should be divisible by 4
      if len(s) % 4 != 0:
          return False

      return True

  def handle_file_upload(self, event):
      # FIXED: This should automatically process the file
      files = event.target.files
      if files and files.length > 0:
          file = files.item(0)
          from js import FileReader
          reader = FileReader.new()
          def on_load(e):
              try:
                  content = e.target.result
                  window.console.log(f"File content length: {len(content)}")
                  window.console.log(f"File content preview: {content[:200]}...")

                  base64 = self.extract_base64(content)
                  if base64:
                      window.console.log(f"Extracted base64 length: {len(base64)}")
                      self.decode_and_load(base64)
                      # Clear the file input after successful upload
                      event.target.value = ""
                      # Show success message
                      self.show_indicator("üìÅ File uploaded successfully", "#10b981")
                  else:
                      window.alert("‚ùå No valid base64 data found in file. Please ensure the file contains exported problem data.")
              except Exception as ex:
                  window.console.error(f"Error processing file: {ex}")
                  window.alert(f"‚ùå Error processing file: {ex}")
          reader.onload = create_proxy(on_load)
          reader.readAsText(file)

  def get_power_svg(self, size="24", color="currentColor"):
    """
    SVG: Grey-filled box with superscripted white-filled box (for exponent/power)
    """
    return f"""<svg width="{size}" height="{size}" viewBox="0 0 24 24" fill="none"
        xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
      <!-- Main grey-filled box (larger, lower) -->
      <rect x="2" y="10" width="10" height="10" rx="1" 
            stroke="{color}" stroke-width="2" 
            fill="#9ca3af"/>
      <!-- Superscript white-filled box (smaller, upper right) -->
      <rect x="13" y="4" width="8" height="8" rx="1" 
            stroke="{color}" stroke-width="1.5" 
            fill="#ffffff"/>
    </svg>"""

  def get_subscript_svg(self, size="24", color="currentColor"):
    """
    SVG: Grey-filled box with subscripted white-filled box (for subscript)
    """
    return f"""<svg width="{size}" height="{size}" viewBox="0 0 24 24" fill="none"
        xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
      <!-- Main grey-filled box (larger, upper) -->
      <rect x="2" y="4" width="10" height="10" rx="1" 
            stroke="{color}" stroke-width="2" 
            fill="#9ca3af"/>
      <!-- Subscript white-filled box (smaller, lower right) -->
      <rect x="13" y="12" width="8" height="8" rx="1" 
            stroke="{color}" stroke-width="1.5" 
            fill="#ffffff"/>
    </svg>"""

  def get_select_left_svg(self, size="24", stroke_width=2, color="currentColor"):
      """
      SVG: box followed by a left-pointing arrow (select left).
      Box on the left, arrow to the right pointing back toward the box.
      """
      return f"""<svg width="{size}" height="{size}" viewBox="0 0 24 24" fill="none"
          xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
        <!-- box -->
        <rect x="3" y="6" width="8" height="12" rx="2" stroke="{color}" stroke-width="{stroke_width}" fill="none"/>
        <!-- arrow (to the left, pointing at the box) -->
        <path d="M21 12 H11" stroke="{color}" stroke-width="{stroke_width}" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
        <path d="M15 8 L11 12 L15 16" stroke="{color}" stroke-width="{stroke_width}" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
      </svg>"""

  def get_select_right_svg(self, size="24", stroke_width=2, color="currentColor"):
      """
      SVG: right-pointing arrow followed by a box (select right).
      Arrow on the left pointing toward the box on the right.
      """
      return f"""<svg width="{size}" height="{size}" viewBox="0 0 24 24" fill="none"
          xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
        <!-- arrow (to the right, pointing at the box) -->
        <path d="M3 12 H13" stroke="{color}" stroke-width="{stroke_width}" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
        <path d="M9 8 L13 12 L9 16" stroke="{color}" stroke-width="{stroke_width}" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
        <!-- box -->
        <rect x="13.5" y="6" width="7" height="12" rx="2" stroke="{color}" stroke-width="{stroke_width}" fill="none"/>
      </svg>"""

  def get_move_left_svg(self, size="24", stroke_width=2, color="currentColor"):
      """
      SVG: left-pointing arrow (move left).
      """
      return f"""<svg width="{size}" height="{size}" viewBox="0 0 24 24" fill="none"
          xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
        <!-- arrow (to the left, pointing at the box) -->
        <path d="M21 12 H11" stroke="{color}" stroke-width="{stroke_width}" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
        <path d="M15 8 L11 12 L15 16" stroke="{color}" stroke-width="{stroke_width}" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
      </svg>"""

  def get_move_right_svg(self, size="24", stroke_width=2, color="currentColor"):
      """
      SVG: right-pointing arrow (move right).
      """
      return f"""<svg width="{size}" height="{size}" viewBox="0 0 24 24" fill="none"
          xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
        <!-- arrow (to the right, pointing at the box) -->
        <path d="M3 12 H13" stroke="{color}" stroke-width="{stroke_width}" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
        <path d="M9 8 L13 12 L9 16" stroke="{color}" stroke-width="{stroke_width}" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
      </svg>"""


  def get_keyboard_svg(self, size="24"):
    """Generate SVG keyboard icon"""
    return f"""<svg width="{size}" height="{size}" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <rect x="2" y="5" width="20" height="14" rx="2" stroke="currentColor" stroke-width="2"/>
        <rect x="5" y="8" width="2" height="2" fill="currentColor"/>
        <rect x="9" y="8" width="2" height="2" fill="currentColor"/>
        <rect x="13" y="8" width="2" height="2" fill="currentColor"/>
        <rect x="17" y="8" width="2" height="2" fill="currentColor"/>
        <rect x="5" y="12" width="2" height="2" fill="currentColor"/>
        <rect x="9" y="12" width="2" height="2" fill="currentColor"/>
        <rect x="13" y="12" width="2" height="2" fill="currentColor"/>
        <rect x="17" y="12" width="2" height="2" fill="currentColor"/>
        <rect x="7" y="16" width="10" height="2" rx="1" fill="currentColor"/>
    </svg>"""

  def get_lock_svg(self, size="24"):
    """Generate SVG keyboard icon with cross mark on top"""
    return f"""<svg width="{size}" height="{size}" viewBox="0 0 24 24" fill="none"
      xmlns="http://www.w3.org/2000/svg">
      <!-- Keyboard outline -->
      <rect x="2" y="5" width="20" height="14" rx="2"
            stroke="currentColor" stroke-width="2"/>
      <rect x="5" y="8" width="2" height="2" fill="currentColor"/>
      <rect x="9" y="8" width="2" height="2" fill="currentColor"/>
      <rect x="13" y="8" width="2" height="2" fill="currentColor"/>
      <rect x="17" y="8" width="2" height="2" fill="currentColor"/>
      <rect x="5" y="12" width="2" height="2" fill="currentColor"/>
      <rect x="9" y="12" width="2" height="2" fill="currentColor"/>
      <rect x="13" y="12" width="2" height="2" fill="currentColor"/>
      <rect x="17" y="12" width="2" height="2" fill="currentColor"/>
      <rect x="7" y="16" width="10" height="2" rx="1" fill="currentColor"/>

      <!-- Large red cross centered -->
      <line x1="6" y1="6" x2="18" y2="18"
            stroke="red" stroke-width="3" stroke-linecap="round"/>
      <line x1="18" y1="6" x2="6" y2="18"
            stroke="red" stroke-width="3" stroke-linecap="round"/>
  </svg>"""

  def generate_minimal_buttons_support_svg(self, step_data):
      """Generate minimal button set based on expression and expected structure"""

      # Parse expression to extract symbols
      expression_latex = step_data.get("expression", "")
      expected_struct = step_data.get("expected_structure", {})

      buttons = set()

      # Extract operands from expected structure
      expected_operands = expected_struct.get("operands", {})
      expected_operators = expected_struct.get("operators", {})

      # DEBUG: Log structure to see what we're working with
      window.console.log(f"Expected operands: {expected_operands}")
      window.console.log(f"Expected operators: {expected_operators}")
      window.console.log(f"Expression: {expression_latex}")

      # Add ONLY the specific digits needed from operands, plus limited distractors
      required_digits = set()
      has_decimal = False
      has_negative = False

      # Extract digits and detect features
      for operand in expected_operands.keys():
          operand_str = str(operand)

          # Extract individual digits from the number
          num_str = operand_str.replace("-", "").replace(".", "").replace("(", "").replace(")", "").replace(" ", "")
          for digit in num_str:
              if digit.isdigit():
                  required_digits.add(digit)

          # Check if decimal point is needed
          if "." in operand_str:
              has_decimal = True

      # ‚úÖ Use comprehensive negative detection
      has_negative = self._contains_negative(expected_operands, expected_operators)
      window.console.log(f"Comprehensive negative detection result: {has_negative}")

      # Add required digits
      for digit in required_digits:
          buttons.add(("digit", digit, digit))

      # Add 2-3 distractor digits (digits NOT in the answer)
      all_digits = set("0123456789")
      available_distractors = list(all_digits - required_digits)

      if available_distractors:
          import random
          random.seed(hash(expression_latex))  # Consistent distractors per step
          num_distractors = min(3, len(available_distractors))
          distractors = random.sample(available_distractors, num_distractors)
          for digit in distractors:
              buttons.add(("digit", digit, digit))

      # Add decimal point if needed
      if has_decimal:
          buttons.add(("special", ".", "."))

      # Add 2-3 distractor digits (digits NOT in the answer)
      all_digits = set("0123456789")
      available_distractors = list(all_digits - required_digits)

      if available_distractors:
          import random
          random.seed(hash(expression_latex))  # Consistent distractors per step
          num_distractors = min(3, len(available_distractors))
          distractors = random.sample(available_distractors, num_distractors)
          for digit in distractors:
              buttons.add(("digit", digit, digit))

      # Add decimal point if needed
      if has_decimal:
          buttons.add(("special", ".", "."))

      # Add negative sign if needed (but not if subtraction operator already present)
      if has_negative and "Add" not in expected_operators:
          buttons.add(("operator", "‚àí", "-"))

      # Add variables/symbols from operands
      for operand in expected_operands.keys():
          if not self._is_numeric(operand) and operand != "-1":
              # Clean symbol name (remove backslashes)
              clean_sym = operand.replace("\\", "")
              if len(clean_sym) <= 3:  # Only add short symbols as buttons
                  buttons.add(("symbol", clean_sym, clean_sym))

      # Add operators based on expected structure
      operator_map = {
          "Add": ("+", "+"),
          "Mul": ("√ó", "\\times"),
          "Derivative": ("d/dx", "SEQ:d,/,d,x"),
          "sin": ("sin", "\\sin"),
          "cos": ("cos", "\\cos"),
          "tan": ("tan", "\\tan"),
          "cot": ("cot", "\\cot"),
          "sec": ("sec", "\\sec"),
          "csc": ("csc", "\\csc"),
          "log": ("log", "\\log"),
          "ln": ("ln", "\\ln"),
          "exp": ("exp", "\\exp"),
          "sqrt": ("‚àö", "\\sqrt"),
          "Abs": ("|x|", "\\left|"),
          "factorial": ("!", "!"),
      }

      for op in expected_operators.keys():
          if op in operator_map:
              label, latex = operator_map[op]
              buttons.add(("operator", label, latex))

      # Additional operator detection from expression itself
      # Check for derivative notation
      if "\\frac{d}{dx}" in expression_latex or "\\frac{d}{d" in expression_latex or "Derivative" in str(expected_operators):
          buttons.add(("operator", "d/dx", "SEQ:d,/,d,x"))
          window.console.log("Added derivative button")

      # Check for multiplication symbols
      if "\\cdot" in expression_latex or "\\times" in expression_latex or "¬∑" in expression_latex or "*" in expression_latex or "Mul" in expected_operators:
          if ("operator", "√ó", "\\times") not in buttons:
              buttons.add(("operator", "√ó", "\\times"))
              window.console.log("Added multiplication button")

      # Check for division symbols
      if "/" in expression_latex or "\\div" in expression_latex or "√∑" in expression_latex:
          buttons.add(("operator", "√∑", "/"))
          window.console.log("Added division button from expression")

      # Check if division is also needed (represented as Mul with Pow(-1))
      if "Mul" in expected_operators and "Pow" in expected_operators:
          buttons.add(("operator", "√∑", "/"))

      # Check for subtraction (represented as Add with Mul(-1))
      if "Add" in expected_operators:
          buttons.add(("operator", "‚àí", "-"))

      # ‚úÖ ALWAYS add parentheses (required for all problems)
      buttons.add(("special", "(", "("))
      buttons.add(("special", ")", ")"))

      # Add power and subscript if there are operators or multiple operands
      if expected_operators or len(required_digits) > 1 or len(expected_operands) > 1:
          # Get SVG icons
          power_svg = self.get_power_svg("24")
          subscript_svg = self.get_subscript_svg("24")

          buttons.add(("special", f"SVG:{power_svg}", "^"))
          buttons.add(("special", f"SVG:{subscript_svg}", "_"))
      # Check if matrix notation is needed - IMPROVED DETECTION
      needs_matrix = False

      # Check operators for matrix operations
      matrix_operators = ["MatMul", "MatAdd", "Transpose", "Inverse", "Determinant"]
      if any(op in expected_operators for op in matrix_operators):
          needs_matrix = True
          window.console.log("Matrix detected from operators")

      # Check operands for matrix notation
      if not needs_matrix:
          for operand in expected_operands.keys():
              operand_str = str(operand)
              if "Matrix" in operand_str or "[" in operand_str or "," in operand_str:
                  needs_matrix = True
                  window.console.log(f"Matrix detected from operand: {operand_str}")
                  break

      # Check expression itself for matrix notation
      if not needs_matrix and "[" in expression_latex:
          needs_matrix = True
          window.console.log("Matrix detected from expression")

      # Add matrix buttons if needed
      if needs_matrix:
          window.console.log("Adding matrix brackets and comma")
          buttons.add(("special", "[", "["))
          buttons.add(("special", "]", "]"))
          buttons.add(("special", ",", ","))

      # Check if fraction notation is needed
      if "Mul" in expected_operators and "Pow" in expected_operators:
          buttons.add(("special", "√∑", "\\frac"))

      # Add navigation buttons for MathQuill field
      move_left_svg = self.get_move_left_svg("32")
      move_right_svg = self.get_move_right_svg("32")
      buttons.add(("navigation", f"MOVE_LEFT_SVG:{move_left_svg}", "MOVE_LEFT"))
      buttons.add(("navigation", f"MOVE_RIGHT_SVG:{move_right_svg}", "MOVE_RIGHT"))
      #buttons.add(("navigation", "‚óÑ", "MOVE_LEFT"))
      #buttons.add(("navigation", "‚ñ∫", "MOVE_RIGHT"))
      select_left_svg = self.get_select_left_svg("32")
      select_right_svg = self.get_select_right_svg("32")
      buttons.add(("navigation", f"SELECT_LEFT_SVG:{select_left_svg}", "SELECT_LEFT"))
      buttons.add(("navigation", f"SELECT_RIGHT_SVG:{select_right_svg}", "SELECT_RIGHT"))
      #buttons.add(("navigation", "‚á§", "SELECT_LEFT"))
      #buttons.add(("navigation", "‚á•", "SELECT_LEFT"))


      # Always add backspace and clear
      buttons.add(("delete", "‚å´", "BACKSPACE"))
      buttons.add(("delete", "Clear", "CLEAR"))
      # Add keyboard activation button
      #buttons.add(("navigation", "‚å®Ô∏è", "ACTIVATE_KEYBOARD"))
      #buttons.add(("navigation", "üîí", "DEACTIVATE_KEYBOARD"))

      # Sort buttons by type and label
      sorted_buttons = sorted(buttons, key=lambda x: (
          0 if x[0] == "digit" else
          1 if x[0] == "symbol" else
          2 if x[0] == "operator" else
          3 if x[0] == "special" else
          4 if x[0] == "navigation" else
          5 if x[0] == "delete" else 6,
          x[1]
      ))

      #html_parts = []
      #for btn_type, label, action in sorted_buttons:
      #    safe_label = html.escape(label)
      #    html_parts.append(
      #        f"<button class='input-btn {btn_type}' data-action='{action}'>{safe_label}</button>"
      #    )
      html_parts = []
      for btn_type, label, action in sorted_buttons:
          # Check if this is an SVG button
          if label.startswith("SELECT_LEFT_SVG:"):
              svg_content = label.replace("SELECT_LEFT_SVG:", "")
              html_parts.append(
                  f"<button class='input-btn {btn_type}' data-action='{action}' >{svg_content}</button>"
              )
          elif label.startswith("SELECT_RIGHT_SVG:"):
              svg_content = label.replace("SELECT_RIGHT_SVG:", "")
              html_parts.append(
                  f"<button class='input-btn {btn_type}' data-action='{action}'>{svg_content}</button>"
              )
          elif label.startswith("MOVE_LEFT_SVG:"):
              svg_content = label.replace("MOVE_LEFT_SVG:", "")
              html_parts.append(
                  f"<button class='input-btn {btn_type}' data-action='{action}'>{svg_content}</button>"
              )
          elif label.startswith("MOVE_RIGHT_SVG:"):
              svg_content = label.replace("MOVE_RIGHT_SVG:", "")
              html_parts.append(
                  f"<button class='input-btn {btn_type}' data-action='{action}'>{svg_content}</button>"
              )
          else:
              safe_label = html.escape(label)
              html_parts.append(
                  f"<button class='input-btn {btn_type}' data-action='{action}'>{safe_label}</button>"
              )

      return "\n".join(html_parts)

  def get_select_left_svg(self, size="24", stroke_width=2, color="currentColor"):
      """
      SVG: left-pointing arrow followed by a box (select left).
      Arrow on the left pointing toward the box on the right.
      """
      return f"""<svg width="{size}" height="{size}" viewBox="0 0 24 24" fill="none"
          xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
        <!-- arrow pointing left -->
        <path d="M19 12 H9" stroke="{color}" stroke-width="{stroke_width}" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
        <path d="M13 8 L9 12 L13 16" stroke="{color}" stroke-width="{stroke_width}" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
        <!-- box on left -->
        <rect x="3" y="6" width="6" height="12" rx="2" stroke="{color}" stroke-width="{stroke_width}" fill="none"/>
      </svg>"""

  def get_select_right_svg(self, size="24", stroke_width=2, color="currentColor"):
      """
      SVG: box followed by right-pointing arrow (select right).
      Box on the left, arrow pointing right toward the box on the right.
      """
      return f"""<svg width="{size}" height="{size}" viewBox="0 0 24 24" fill="none"
          xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
        <!-- box on right -->
        <rect x="15" y="6" width="6" height="12" rx="2" stroke="{color}" stroke-width="{stroke_width}" fill="none"/>
        <!-- arrow pointing right -->
        <path d="M5 12 H15" stroke="{color}" stroke-width="{stroke_width}" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
        <path d="M11 8 L15 12 L11 16" stroke="{color}" stroke-width="{stroke_width}" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
      </svg>"""

  def get_move_left_svg(self, size="24", stroke_width=2, color="currentColor"):
      """
      SVG: left-pointing arrow (move left).
      """
      return f"""<svg width="{size}" height="{size}" viewBox="0 0 24 24" fill="none"
          xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
        <path d="M19 12 H5" stroke="{color}" stroke-width="{stroke_width}" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
        <path d="M9 8 L5 12 L9 16" stroke="{color}" stroke-width="{stroke_width}" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
      </svg>"""

  def get_move_right_svg(self, size="24", stroke_width=2, color="currentColor"):
      """
      SVG: right-pointing arrow (move right).
      """
      return f"""<svg width="{size}" height="{size}" viewBox="0 0 24 24" fill="none"
          xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
        <path d="M5 12 H19" stroke="{color}" stroke-width="{stroke_width}" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
        <path d="M15 8 L19 12 L15 16" stroke="{color}" stroke-width="{stroke_width}" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
      </svg>"""

  def generate_minimal_buttons(self, step_data):
    """Generate minimal button set based on expression and expected structure"""

    # Parse expression to extract symbols
    expression_latex = step_data.get("expression", "")
    expected_struct = step_data.get("expected_structure", {})

    buttons = set()

    # Extract operands from expected structure
    expected_operands = expected_struct.get("operands", {})
    expected_operators = expected_struct.get("operators", {})
    expected_matrix_ops = expected_struct.get("matrix_ops", [])

    # DEBUG: Log structure to see what we're working with
    window.console.log(f"Expected operands: {expected_operands}")
    window.console.log(f"Expected operators: {expected_operators}")
    window.console.log(f"Expected matrix_ops: {expected_matrix_ops}")
    window.console.log(f"Expression: {expression_latex}")

    # Add ONLY the specific digits needed from operands, plus limited distractors
    required_digits = set()
    has_decimal = False
    has_negative = False

    # Extract digits and detect features from operands
    for operand in expected_operands.keys():
        operand_str = str(operand)

        # Check for negative
        if operand_str.startswith("-"):
            has_negative = True
            window.console.log(f"Detected negative operand: {operand_str}")

        # Extract individual digits from the number
        num_str = operand_str.replace("-", "").replace(".", "").replace("(", "").replace(")", "").replace(" ", "")
        for digit in num_str:
            if digit.isdigit():
                required_digits.add(digit)

        # Check if decimal point is needed
        if "." in operand_str:
            has_decimal = True

    # ‚úÖ NEW: Extract digits from matrix operations
    needs_row_operations = False
    if expected_matrix_ops and len(expected_matrix_ops) > 0:
        needs_row_operations = True
        window.console.log(f"Matrix row operations detected: {len(expected_matrix_ops)} operation(s)")
        
        # Extract all numeric values from matrix operations
        for matrix_op in expected_matrix_ops:
            operations = matrix_op.get("operations", [])
            for op in operations:
                details = op.get("details", [])
                
                # Recursively extract numbers from details
                def extract_numbers(obj):
                    nonlocal has_negative, has_decimal
                    
                    if isinstance(obj, (list, tuple)):
                        for item in obj:
                            extract_numbers(item)
                    elif self._is_numeric(obj):
                        obj_str = str(obj)
                        
                        # Check for negative
                        if obj_str.startswith('-'):
                            has_negative = True
                            window.console.log(f"Detected negative in matrix op: {obj_str}")
                        
                        # Check for decimal
                        if '.' in obj_str:
                            has_decimal = True
                            window.console.log(f"Detected decimal in matrix op: {obj_str}")
                        
                        # Extract digits
                        # Handle fractions like "0.5" or "1/2"
                        if '/' in obj_str:
                            parts = obj_str.split('/')
                            for part in parts:
                                clean_part = part.replace('.', '').replace('-', '').replace('(', '').replace(')', '').strip()
                                for digit in clean_part:
                                    if digit.isdigit():
                                        required_digits.add(digit)
                                        window.console.log(f"Added digit from fraction: {digit}")
                        else:
                            clean_str = obj_str.replace('.', '').replace('-', '').replace('(', '').replace(')', '').strip()
                            for digit in clean_str:
                                if digit.isdigit():
                                    required_digits.add(digit)
                                    window.console.log(f"Added digit from matrix op: {digit}")
                
                extract_numbers(details)

    window.console.log(f"Required digits after extraction: {required_digits}")
    window.console.log(f"Has negative: {has_negative}")
    window.console.log(f"Has decimal: {has_decimal}")
    window.console.log(f"Needs row operations: {needs_row_operations}")

    # Add required digits
    for digit in required_digits:
        buttons.add(("digit", digit, digit))

    # Add 2-3 distractor digits (digits NOT in the answer)
    all_digits = set("0123456789")
    available_distractors = list(all_digits - required_digits)

    if available_distractors:
        import random
        random.seed(hash(expression_latex))  # Consistent distractors per step
        num_distractors = min(3, len(available_distractors))
        distractors = random.sample(available_distractors, num_distractors)
        for digit in distractors:
            buttons.add(("digit", digit, digit))

    # Add decimal point if needed
    if has_decimal:
        buttons.add(("special", ".", "."))

    # Add variables/symbols from operands
    for operand in expected_operands.keys():
        operand_str = str(operand)
        # Remove negative sign for symbol extraction
        clean_operand = operand_str.lstrip("-")
        if not self._is_numeric(clean_operand) and clean_operand != "1":
            # Clean symbol name (remove backslashes)
            clean_sym = clean_operand.replace("\\", "")
            if len(clean_sym) <= 3:  # Only add short symbols as buttons
                buttons.add(("symbol", clean_sym, clean_sym))

    # Add operators based on expected structure
    operator_map = {
        "Derivative": ("d/dx", "SEQ:d,/,d,x"),
        "Limit": ("lim", "\\lim"),
        "sin": ("sin", "\\sin"),
        "cos": ("cos", "\\cos"),
        "tan": ("tan", "\\tan"),
        "cot": ("cot", "\\cot"),
        "sec": ("sec", "\\sec"),
        "csc": ("csc", "\\csc"),
        "log": ("log", "\\log"),
        "ln": ("ln", "\\ln"),
        "exp": ("exp", "\\exp"),
        "sqrt": ("‚àö", "\\sqrt"),
        "Abs": ("|x|", "\\left|"),
        "factorial": ("!", "!"),
    }

    for op in expected_operators.keys():
        if op in operator_map:
            label, latex = operator_map[op]
            buttons.add(("operator", label, latex))

    # ‚úÖ Add BOTH + and - when Add is present
    if "Add" in expected_operators:
        buttons.add(("operator", "+", "+"))
        buttons.add(("operator", "‚àí", "-"))
        window.console.log("Added + and - buttons for Add operator")
    # ‚úÖ Add - button if there are negative operands (even if no Add operator)
    elif has_negative:
        buttons.add(("operator", "‚àí", "-"))
        window.console.log("Added - button for negative operands")
    # ‚úÖ NEW: Add +/- for row operations even without Add
    elif needs_row_operations:
        buttons.add(("operator", "+", "+"))
        buttons.add(("operator", "‚àí", "-"))
        window.console.log("Added +/- buttons for row operations")

    # ‚úÖ Add BOTH √ó and √∑ when Mul is present
    if "Mul" in expected_operators:
        buttons.add(("operator", "√ó", "\\times"))
        buttons.add(("operator", "√∑", "\\frac"))
        window.console.log("Added √ó and √∑ buttons for Mul operator")

    # Additional operator detection from expression itself
    # Check for derivative notation
    if "\\frac{d}{dx}" in expression_latex or "\\frac{d}{d" in expression_latex or "Derivative" in str(expected_operators):
        if ("operator", "d/dx", "SEQ:d,/,d,x") not in buttons:
            buttons.add(("operator", "d/dx", "SEQ:d,/,d,x"))
            window.console.log("Added derivative button from expression")

    # ‚úÖ ADD: If Limit is detected, also add the full limit sequence and related symbols
    if "Limit" in expected_operators:
        buttons.add(("operator", "lim‚Üí", "SEQ:\\lim,_,x,\\to,0,{Right},{Right}"))
        buttons.add(("operator", "‚Üí", "\\to"))
        buttons.add(("operator", "‚àû", "\\infty"))
        window.console.log("Added limit buttons")

    # Check for multiplication symbols in expression
    if "\\cdot" in expression_latex or "\\times" in expression_latex or "¬∑" in expression_latex or "*" in expression_latex:
        if ("operator", "√ó", "\\times") not in buttons:
            buttons.add(("operator", "√ó", "\\times"))
            window.console.log("Added multiplication button from expression")

    # Check for division symbols in expression
    if "/" in expression_latex or "\\div" in expression_latex or "√∑" in expression_latex:
        if ("operator", "√∑", "\\frac") not in buttons:
            buttons.add(("operator", "√∑", "\\frac"))
            window.console.log("Added division button from expression")

    # ‚úÖ ALWAYS add parentheses (required for all problems)
    buttons.add(("special", "(", "("))
    buttons.add(("special", ")", ")"))

    # Add power and subscript if there are operators or multiple operands
    if expected_operators or len(required_digits) > 1 or len(expected_operands) > 1 or needs_row_operations:
        # Get SVG icons
        power_svg = self.get_power_svg("24")
        subscript_svg = self.get_subscript_svg("24")

        buttons.add(("special", f"SVG:{power_svg}", "^"))
        buttons.add(("special", f"SVG:{subscript_svg}", "_"))

    # Check if matrix notation is needed
    needs_matrix = False

    # Check operators for matrix operations
    matrix_operators = ["MatMul", "MatAdd", "Transpose", "Inverse", "Determinant"]
    if any(op in expected_operators for op in matrix_operators):
        needs_matrix = True
        window.console.log("Matrix detected from operators")

    # Check operands for matrix notation
    if not needs_matrix:
        for operand in expected_operands.keys():
            operand_str = str(operand)
            if "Matrix" in operand_str or "[" in operand_str or "," in operand_str:
                needs_matrix = True
                window.console.log(f"Matrix detected from operand: {operand_str}")
                break

    # Check expression itself for matrix notation
    if not needs_matrix and "[" in expression_latex:
        needs_matrix = True
        window.console.log("Matrix detected from expression")

    # Check if matrix_ops field exists and has operations
    if expected_matrix_ops and len(expected_matrix_ops) > 0:
        needs_matrix = True
        window.console.log("Matrix operations field detected")

    # ‚úÖ Add matrix buttons if needed
    if needs_matrix:
        window.console.log("Adding matrix brackets and comma")
        buttons.add(("special", "[", "["))
        buttons.add(("special", "]", "]"))
        buttons.add(("special", ",", ","))

    # ‚úÖ NEW: Add row operation buttons if needed
    if needs_row_operations:
        window.console.log("Adding row operation buttons")
        
        # R for row notation (R_1, R_2, etc.)
        buttons.add(("symbol", "R", "R"))
        
        # Arrow for row operations (R_1 ‚Üí 2R_1)
        buttons.add(("operator", "‚Üí", "\\to"))
        
        # Pipe for separator between matrix and operations
        buttons.add(("special", "|", "|"))
        
        # Division operator (for fractions like 1/2 in row operations)
        if ("operator", "√∑", "/") not in buttons:
            buttons.add(("operator", "√∑", "/"))
        
        # Fraction notation (for \frac{1}{2})
        if ("special", "√∑(fr)", "\\frac") not in buttons:
            buttons.add(("special", "√∑(fr)", "\\frac"))
        
        # Left arrow for bidirectional operations
        buttons.add(("operator", "‚Üê", "\\leftarrow"))
        
        # Double arrow for swap operations
        buttons.add(("operator", "‚Üî", "\\leftrightarrow"))
        
        window.console.log("‚úÖ Added all row operation buttons (R, ‚Üí, ‚Üê, ‚Üî, |, /, √∑(fr))")

    # Check if fraction notation is needed (besides division)
    if "Mul" in expected_operators and "Pow" in expected_operators:
        # This combination often means fractions
        if ("special", "√∑(fr)", "\\frac") not in buttons:
            buttons.add(("special", "√∑(fr)", "\\frac"))

    # Add navigation buttons for MathQuill field with SVG icons
    move_left_svg = self.get_move_left_svg("24")
    move_right_svg = self.get_move_right_svg("24")
    select_left_svg = self.get_select_left_svg("24")
    select_right_svg = self.get_select_right_svg("24")

    buttons.add(("navigation", f"SVG:{move_left_svg}", "MOVE_LEFT"))
    buttons.add(("navigation", f"SVG:{move_right_svg}", "MOVE_RIGHT"))
    buttons.add(("navigation", f"SVG:{select_left_svg}", "SELECT_LEFT"))
    buttons.add(("navigation", f"SVG:{select_right_svg}", "SELECT_RIGHT"))

    # Always add backspace and clear
    buttons.add(("delete", "‚å´", "BACKSPACE"))
    buttons.add(("delete", "Clear", "CLEAR"))

    # Sort buttons by type and label
    sorted_buttons = sorted(buttons, key=lambda x: (
        0 if x[0] == "digit" else
        1 if x[0] == "symbol" else
        2 if x[0] == "operator" else
        3 if x[0] == "special" else
        4 if x[0] == "navigation" else
        5 if x[0] == "delete" else 6,
        x[1]
    ))

    html_parts = []
    for btn_type, label, action in sorted_buttons:
        # Check if this is an SVG button
        if label.startswith("SVG:"):
            svg_content = label.replace("SVG:", "")
            html_parts.append(
                f"<button class='input-btn {btn_type}' data-action='{action}'>{svg_content}</button>"
            )
        else:
            safe_label = html.escape(label)
            html_parts.append(
                f"<button class='input-btn {btn_type}' data-action='{action}'>{safe_label}</button>"
            )

    return "\n".join(html_parts)

  def _contains_negative(self, operands_dict, operators_dict):
    """
    Comprehensive check for negative values in expression.
    Checks operands, Mul(-1, x) patterns, and negative coefficients.
    """
    import sympy as sp
    
    # Check 1: Direct negative operands
    for operand in operands_dict.keys():
        operand_str = str(operand).strip()
        if operand_str.startswith("-"):
            window.console.log(f"Found negative operand: {operand_str}")
            return True
    
    # Check 2: Mul with -1 (indicates negation or subtraction)
    if "Mul" in operators_dict:
        if "-1" in operands_dict:
            window.console.log("Found Mul with -1 (negation pattern)")
            return True
    
    # Check 3: Add operator often involves subtraction (Add with negative terms)
    if "Add" in operators_dict:
        window.console.log("Found Add operator - may need minus button")
        return True
    
    return False
  
  def _is_numeric(self, s):
      """Check if string represents a number"""
      try:
          float(str(s))
          return True
      except (ValueError, TypeError):
          return False

  def handle_input_button(self, step_idx, action, answer_field):
      """Handle minimal button clicks to input into MathQuill field"""
      # Get the correct answer field from solve_state using step_idx
      if not hasattr(self, 'solve_state') or step_idx >= len(self.solve_state):
          window.console.error(f"Invalid step_idx: {step_idx}")
          return

      # Always get the field from solve_state to ensure we have the right one
      step = self.solve_state[step_idx]
      answer_field = step.get("answer_mf")

      if not answer_field:
          window.console.error(f"No answer field for step {step_idx}")
          return

      # ‚úÖ Use the common KeyboardInputHandler
      KeyboardInputHandler.handle_action(answer_field, action)

  def handle_input_button_old(self, step_idx, action, answer_field):
      """Handle minimal button clicks to input into MathQuill field"""
      # Get the correct answer field from solve_state using step_idx
      if not hasattr(self, 'solve_state') or step_idx >= len(self.solve_state):
          window.console.error(f"Invalid step_idx: {step_idx}")
          return

      # Always get the field from solve_state to ensure we have the right one
      step = self.solve_state[step_idx]
      answer_field = step.get("answer_mf")

      if not answer_field:
          window.console.error(f"No answer field for step {step_idx}")
          return

      if action == "BACKSPACE":
          answer_field.keystroke("Backspace")
      elif action == "CLEAR":
          answer_field.latex("")
      elif action == "MOVE_LEFT":
          answer_field.keystroke("Left")
      elif action == "MOVE_RIGHT":
          answer_field.keystroke("Right")
      elif action == "SELECT_LEFT":
          answer_field.keystroke("Shift-Left")
      elif action == "SELECT_RIGHT":
          answer_field.keystroke("Shift-Right")
      elif action == "ACTIVATE_KEYBOARD":
          # Enable keyboard input by focusing the field
          try:
              el = answer_field.el()
              textarea = el.querySelector('textarea')
              if textarea:
                  textarea.style.width = f"{el.offsetWidth}px"
                  textarea.style.height = f"{el.offsetHeight}px"
                  textarea.style.overflow = "hidden"
                  textarea.style.resize = "none"
                  textarea.style.boxSizing = "border-box"
                  if textarea:

                  # Temporarily enable the textarea
                      textarea.removeAttribute('readonly')
                      textarea.removeAttribute('disabled')
                      textarea.style.pointerEvents = 'auto'
                      textarea.style.opacity = '1'
                      textarea.style.position = 'absolute'  # optional
                      textarea.style.left = '0'
                      textarea.style.width = f"{el.offsetWidth}px"
                      textarea.style.height = f"{el.offsetHeight}px"
                      textarea.style.overflow = 'hidden'
                      textarea.style.resize = 'none'
                      textarea.focus()
                  # Focus it to show keyboard
                  textarea.focus()
                  window.console.log(f"‚úÖ Keyboard activated for step {step_idx}")
          except Exception as e:
              window.console.error(f"Failed to activate keyboard for step {step_idx}: {e}")
      elif action == "DEACTIVATE_KEYBOARD":
          # Disable keyboard input by blurring and hiding the field
          try:
              el = answer_field.el()
              textarea = el.querySelector('textarea')
              if textarea:
                  textarea.blur()
                  textarea.setAttribute('readonly', 'readonly')
                  textarea.setAttribute('disabled', 'disabled')
                  textarea.style.pointerEvents = 'none'
                  textarea.style.opacity = '0'
                  textarea.style.position = 'absolute'
                  textarea.style.left = '-9999px'
                  window.console.log(f"‚úÖ Keyboard deactivated for step {step_idx}")
          except Exception as e:
              window.console.error(f"Failed to deactivate keyboard for step {step_idx}: {e}")
      elif action == "^":
          # Power button - use cmd for exponent
          answer_field.cmd("^")
      elif action == "_":
          # Subscript button - use cmd for subscript
          answer_field.cmd("_")
      elif action.startswith("SEQ:"):
          # Handle key sequences (e.g., SEQ:d,/,d,x)
          sequence = action[4:]  # Remove "SEQ:" prefix
          keys = sequence.split(",")
          for key in keys:
              key = key.strip()
              if key == "/":
                  answer_field.cmd("/")
              elif key.startswith("\\"):
                  answer_field.cmd(key)
              elif key.startswith("~"):
                  answer_field.keystroke(key.replace("~",""))
              else:
                  answer_field.write(key)
      else:
          # Insert the LaTeX command or character
          if action.startswith("\\"):
              answer_field.cmd(action)
          else:
              answer_field.write(action)

  def validate_problem_set(self, problems):
      """
      Validate that all problems have expected_structure.
      Returns (is_valid, error_messages)
      """
      errors = []

      for p_idx, problem in enumerate(problems, start=1):
          steps = problem.get("steps", [])
          if not steps:
              errors.append(f"Problem {p_idx}: No steps found")
              continue

          for s_idx, step in enumerate(steps, start=1):
              # Check if expected_structure exists
              expected_struct = step.get("expected_structure")

              if expected_struct is None:
                  errors.append(f"Problem {p_idx}, Step {s_idx}: Missing expected_structure")
                  continue

              # Validate structure has required fields
              if not isinstance(expected_struct, dict):
                  errors.append(f"Problem {p_idx}, Step {s_idx}: expected_structure is not a dictionary")
                  continue

              if "operators" not in expected_struct or "operands" not in expected_struct:
                  errors.append(f"Problem {p_idx}, Step {s_idx}: expected_structure missing operators or operands")
                  continue

              # Warn if structure is empty (might be intentional for simple answers)
              if not expected_struct.get("operators") and not expected_struct.get("operands"):
                  window.console.log(f"Warning: Problem {p_idx}, Step {s_idx} has empty structure")

      return (len(errors) == 0, errors)

  def _show_validation_error_popup(self, message):
      """Display detailed validation error popup"""
      safe_msg = str(message).replace("`", "'").replace("\\", "\\\\").replace("\n", "\\n")
      js_code = f"""
          (function(){{
              let existing = document.querySelector('#validationErrorPopup');
              if(existing) existing.remove();

              let popup = document.createElement('div');
              popup.id = 'validationErrorPopup';
              popup.style.cssText = `
                  position:fixed;
                  top:50%;
                  left:50%;
                  transform:translate(-50%, -50%);
                  background:#fef2f2;
                  color:#991b1b;
                  font-family:system-ui, -apple-system, sans-serif;
                  padding:24px 24px 16px 24px;
                  border:3px solid #dc2626;
                  border-radius:12px;
                  box-shadow:0 12px 40px rgba(220, 38, 38, 0.3);
                  white-space:pre-wrap;
                  z-index:9999;
                  max-width:700px;
                  max-height:80vh;
                  overflow:auto;
              `;

              let btn = document.createElement('button');
              btn.textContent = '‚úñ';
              btn.title = 'Close';
              btn.style.cssText = `
                  position:absolute;
                  top:8px;
                  right:10px;
                  border:none;
                  background:transparent;
                  color:#dc2626;
                  font-size:20px;
                  font-weight:bold;
                  cursor:pointer;
                  line-height:1;
              `;
              btn.onclick = () => popup.remove();

              let title = document.createElement('h3');
              title.textContent = '‚ùå Problem Set Validation Failed';
              title.style.cssText = 'margin:0 0 16px 0;color:#991b1b;font-size:18px;';

              let content = document.createElement('div');
              content.textContent = `{safe_msg}`;
              content.style.cssText = 'font-family:monospace;font-size:13px;line-height:1.6;';

              let note = document.createElement('div');
              note.innerHTML = '<br><strong>Note:</strong> This problem set is missing required structure data. Please ensure it was exported from a compatible version of the Problem Creator app.';
              note.style.cssText = 'margin-top:16px;padding:12px;background:#fee2e2;border-radius:6px;font-size:13px;';

              popup.appendChild(btn);
              popup.appendChild(title);
              popup.appendChild(content);
              popup.appendChild(note);
              document.body.appendChild(popup);
          }})();
      """
      window.eval(js_code)

  def decode_and_load(self, base64text):
          try:
              window.console.log("üîÑ Attempting to decode base64...")

              # Validate base64 before decoding
              if not self.is_valid_base64(base64text):
                  raise ValueError("Invalid base64 format")

              # Try to decode base64
              try:
                  import brotli, base64
                  compressed = base64.b64decode(base64text)
                  window.console.log(f"‚úÖ Successfully decoded base64, compressed size: {len(compressed)} bytes")

                  # Try to decompress
                  try:
                      json_text = brotli.decompress(compressed).decode("utf-8")
                      window.console.log(f"‚úÖ Successfully decompressed, JSON length: {len(json_text)}")
                  except Exception as decompress_error:
                      window.console.error(f"Brotli decompression failed: {decompress_error}")
                      # Try without brotli (maybe it's just plain JSON)
                      try:
                          json_text = compressed.decode("utf-8")
                          window.console.log("Using plain JSON (no compression)")
                      except Exception as plain_error:
                          raise ValueError(f"Neither brotli nor plain JSON worked: {plain_error}")

              except Exception as decode_error:
                  window.console.error(f"Base64 decode failed: {decode_error}")
                  raise ValueError(f"Base64 decode failed: {decode_error}")

              # Parse JSON
              try:
                  data = json.loads(json_text)
                  window.console.log(f"‚úÖ Successfully parsed JSON, type: {type(data)}")
              except json.JSONDecodeError as json_error:
                  window.console.error(f"JSON parse error: {json_error}")
                  window.console.error(f"JSON content preview: {json_text[:500]}...")
                  raise ValueError(f"Invalid JSON format: {json_error}")

              # Handle different formats
              if isinstance(data, dict) and "problems" in data:
                  problems = data["problems"]
                  self.current_problem_set_uuid = data.get("problem_set_id", str(uuid.uuid4()))
                  description = data.get("problem_set_description", "")
              else:
                  problems = data if isinstance(data, list) else []
                  self.current_problem_set_uuid = str(uuid.uuid4())
                  description = ""

              if not problems:
                  raise ValueError("No problems found in data")

              # Validate problem set structure
              is_valid, errors = self.validate_problem_set(problems)
              if not is_valid:
                  error_msg = "‚ùå Invalid problem set format:\n\n" + "\n".join(errors[:15])
                  if len(errors) > 15:
                      error_msg += f"\n\n...and {len(errors) - 15} more errors"

                  # Show detailed error popup
                  self._show_validation_error_popup(error_msg)
                  raise ValueError(f"Problem set validation failed: {len(errors)} error(s)")

              # ‚úÖ CRITICAL: Clear ALL state completely
              window.console.log("üîÑ Clearing ALL current state...")
              self.problem_set = []
              self.problem_states = {}
              self.problem_global_histories = {}
              self.current_problem_index = None
              if hasattr(self, 'solve_state'):
                  self.solve_state = []

              # ‚úÖ Clear any existing accordions from DOM
              container = document.querySelector("#solveProblemsContainer")
              if container:
                  container.innerHTML = ""
                  window.console.log("‚úÖ Cleared accordion container")

              # ‚úÖ Set new data
              window.console.log("üîÑ Loading new problem set...")
              self.problem_set = problems

              # Update UI
              self.update_problem_set_info(description)

              # ‚úÖ Render problems (this will auto-open problem 0)
              window.console.log("üîÑ Rendering problems...")
              self.render_problems()

              window.console.log(f"‚úÖ Successfully loaded {len(problems)} problems")
              window.alert(f"‚úÖ Loaded {len(problems)} problems")
              self.show_page("problems")

              # ‚úÖ Save after everything is loaded and opened
              def delayed_save():
                  window.console.log("üíæ Saving loaded problem set to storage...")
                  self.save_to_storage()
              window.setTimeout(create_proxy(delayed_save), 500)

          except ValueError as ve:
              window.console.error(f"ValueError: {ve}")
              window.alert(f"‚ùå Invalid data format: {ve}")
          except Exception as e:
              window.console.error(f"General error: {e}")
              import traceback
              window.console.error(traceback.format_exc())
              window.alert(f"‚ùå Failed to load: {e}")

  def update_problem_set_info(self, description):
      info_panel = document.querySelector("#problemSetInfo")
      desc_el = document.querySelector("#currentProblemSetDescription")
      uuid_el = document.querySelector("#currentProblemSetUuid")

      if self.problem_set:
          info_panel.style.display = "block"
          desc_el.textContent = description or "No description"
          uuid_el.textContent = self.current_problem_set_uuid
      else:
          info_panel.style.display = "none"

  def render_problems(self):
          container = document.querySelector("#solveProblemsContainer")
          if not container:
              return
          container.innerHTML = ""

          # Hide initial panel
          initial_panel = document.querySelector("#initialLoadPanel")
          if initial_panel:
              initial_panel.style.display = "none"

          for idx, prob in enumerate(self.problem_set):
              title = prob.get("title", f"Problem {idx+1}")
              steps = prob.get("steps", [])
              total = len(steps)

              prob_state = self.problem_states.get(idx, [])
              finalized = sum(1 for s in prob_state if s.get("finalized", False))
              is_done = finalized == total and total > 0

              accordion = document.createElement("div")
              accordion.className = "accordion-problem"
              accordion.setAttribute("data-index", idx)

              if is_done:
                  accordion.classList.add("finished")

              header = document.createElement("div")
              header.className = "accordion-header"
              progress_color = "#059669" if is_done else "#6b7280"
              header.innerHTML = f"<span>{idx+1}. {title}</span><span class='progress-summary' style='color:{progress_color}'>‚úÖ {finalized}/{total} completed</span>"

              body = document.createElement("div")
              body.className = "accordion-body"
              body.id = f"problemBody{idx}"
              # ‚úÖ Ensure data-loaded is NOT set initially
              body.removeAttribute("data-loaded")

              accordion.appendChild(header)
              accordion.appendChild(body)
              container.appendChild(accordion)

              def make_toggle_handler(i):
                  def handler(e):
                      self.toggle_problem(i)
                  return handler

              header.addEventListener("click", create_proxy(make_toggle_handler(idx)))

          # ‚úÖ Reset current_problem_index before auto-opening
          self.current_problem_index = None
          window.console.log(f"üìã render_problems: Reset current_problem_index to None")

          # ‚úÖ Auto-open first problem immediately after DOM is ready
          open_idx = 0
          if open_idx < len(self.problem_set):
              window.console.log(f"üìã render_problems: Will auto-open problem {open_idx}")

              def auto_open():
                  window.console.log(f"üìã Auto-opening problem {open_idx} now")
                  # Force a clean open
                  acc = document.querySelector(f".accordion-problem[data-index='{open_idx}']")
                  if acc:
                      body = acc.querySelector(".accordion-body")
                      if body:
                          body.removeAttribute("data-loaded")  # Ensure clean load
                  self.toggle_problem(open_idx)

              # Small delay to ensure DOM is settled
              window.setTimeout(create_proxy(auto_open), 100)

  def debug_global_history(self):
    """Debug method to inspect global history state"""
    window.console.log("=== DEBUG GLOBAL HISTORY STATE ===")
    window.console.log(f"Current problem index: {self.current_problem_index}")
    window.console.log(f"Saved histories for problems: {list(self.problem_global_histories.keys())}")

    for prob_idx in self.problem_global_histories.keys():
        state = self.problem_global_histories[prob_idx]
        window.console.log(f"\nProblem {prob_idx}:")
        window.console.log(f"  - HTML length: {len(state['html'])}")
        window.console.log(f"  - Visible: {state['visible']}")
        # Count attempts in saved HTML
        temp_div = document.createElement("div")
        temp_div.innerHTML = state['html']
        attempts = temp_div.querySelectorAll(".attempt-entry-wrapper")
        window.console.log(f"  - Attempts in saved HTML: {attempts.length}")

    # Check current DOM
    all_global = document.querySelectorAll("[id^='globalHistory_']")
    window.console.log(f"\nGlobal history elements in DOM: {all_global.length}")
    for i in range(all_global.length):
        elem = all_global[i]
        attempts = elem.querySelectorAll(".attempt-entry-wrapper")
        window.console.log(f"  - {elem.id}: {attempts.length} attempts, visible={elem.style.display != 'none'}")

  def toggle_problem(self, index):
          """Toggle accordion and switch active problem with proper state management"""

          window.console.log(f"=== Toggle problem called: index={index}, current={self.current_problem_index} ===")

          # Get the accordion element
          acc = document.querySelector(f".accordion-problem[data-index='{index}']")
          if not acc:
              window.console.error(f"Accordion {index} not found")
              return

          # Check if clicking on an already open accordion - close it
          if acc.classList.contains("open"):
              window.console.log(f"Accordion {index} is already open, closing it (will preserve state)")

              # Save global history before closing
              if self.current_problem_index is not None:
                  window.console.log(f"Saving global history for problem {self.current_problem_index} before closing")
                  self.save_global_history_state(self.current_problem_index)

              acc.classList.remove("open")
              # DON'T set current_problem_index to None - keep it so we know which problem was open
              return

          # ‚úÖ Determine if this is a switch or reopen
          is_switching = (self.current_problem_index is not None and self.current_problem_index != index)
          is_reopening = (self.current_problem_index == index)
          is_first_open = (self.current_problem_index is None)

          window.console.log(f"is_switching: {is_switching}, is_reopening: {is_reopening}, is_first_open: {is_first_open}")

          # ‚úÖ STEP 1: Save current problem state if switching away (but not on first open)
          if is_switching:
              window.console.log(f"=== SWITCHING from problem {self.current_problem_index} to problem {index} ===")

              # Save global history FIRST (while DOM still exists)
              window.console.log(f"Saving global history for problem {self.current_problem_index}")
              self.save_global_history_state(self.current_problem_index)

              # Then save solve state if it exists
              if hasattr(self, 'solve_state'):
                  window.console.log(f"Saving solve_state for problem {self.current_problem_index}")

                  serializable_state = []
                  for step in self.solve_state:
                      step_data = {
                          "step": step.get("step", {}),
                          "attempts": step.get("attempts", 0),
                          "attempt_history": step.get("attempt_history", []),
                          "correct": step.get("correct", False),
                          "finalize_attempts": step.get("finalize_attempts", 0),
                          "finalize_history": step.get("finalize_history", []),
                          "structure_correct": step.get("structure_correct", False),
                          "finalized": step.get("finalized", False),
                          "step_start_time": step.get("step_start_time", window.Date.now())
                      }
                      serializable_state.append(step_data)

                  self.problem_states[self.current_problem_index] = serializable_state
                  window.console.log(f"‚úÖ Saved {len(serializable_state)} steps for problem {self.current_problem_index}")

          # ‚úÖ STEP 2: Close all accordions
          accordions = document.querySelectorAll(".accordion-problem")
          for i in range(accordions.length):
              accordions[i].classList.remove("open")

          # ‚úÖ STEP 3: Open selected accordion
          acc.classList.add("open")
          body = acc.querySelector(".accordion-body")

          if not body:
              window.console.error(f"Accordion body {index} not found")
              return

          # ‚úÖ STEP 4: Load or restore based on situation
          if is_reopening:
              # Just reopening the same problem - restore history without reloading
              window.console.log(f"=== REOPENING problem {index} - restoring history without reload ===")
              restored = self.restore_global_history_state(index)
              if restored:
                  window.console.log(f"‚úÖ Successfully restored history for reopened problem {index}")
              else:
                  window.console.log(f"‚ÑπÔ∏è No history to restore for problem {index}")

              # Re-render MathJax for the existing content
              def render_mathjax():
                  if hasattr(window, 'MathJax'):
                      window.MathJax.typesetPromise([body])
                      window.console.log(f"‚úÖ MathJax re-rendered for reopened problem {index}")
              window.setTimeout(create_proxy(render_mathjax), 100)

          else:
              # Switching to a different problem OR first time opening - do full reload
              if is_first_open:
                  window.console.log(f"=== FIRST OPEN of problem {index} ===")
              else:
                  window.console.log(f"=== SWITCHING to problem {index} ===")

              # ‚úÖ Force clean load by removing data-loaded attribute
              body.removeAttribute("data-loaded")
              self.load_problem(index, body)
              body.setAttribute("data-loaded", "true")

              # Re-render MathJax for all content including restored history
              def render_mathjax():
                  if hasattr(window, 'MathJax'):
                      window.MathJax.typesetPromise([body])
                      window.console.log(f"‚úÖ MathJax re-rendered for problem {index}")
              window.setTimeout(create_proxy(render_mathjax), 200)

          # ‚úÖ STEP 5: Verify state is correct
          window.console.log(f"=== Final state: current_problem_index={self.current_problem_index}, solve_state length={len(self.solve_state) if hasattr(self, 'solve_state') else 0} ===")

  def format_latex_for_display(self, latex_str):
    """
    Format LaTeX string for proper display, especially handling matrices.
    Converts Python list notation [[1,2],[3,4]] to LaTeX matrix notation.
    """
    if not latex_str:
        return latex_str

    import re

    # Check if it contains matrix notation in various forms
    latex_str = str(latex_str).strip()

    # Pattern 1: Direct Python list notation [[...]]
    if latex_str.startswith('[[') and latex_str.endswith(']]'):
        try:
            import json
            matrix_data = json.loads(latex_str)
            rows = []
            for row in matrix_data:
                if isinstance(row, (list, tuple)):
                    rows.append(" & ".join(str(x) for x in row))
                else:
                    rows.append(str(row))
            return r"\begin{bmatrix}" + r" \\ ".join(rows) + r"\end{bmatrix}"
        except:
            pass

    # Pattern 2: LaTeX with \left[ and \right] wrappers containing [[...]]
    if r"\left[" in latex_str and r"\right]" in latex_str:
        # Remove \left[ and \right] wrappers
        cleaned = latex_str.replace(r"\left[", "[").replace(r"\right]", "]")

        # Try to find [[...]] pattern
        matrix_match = re.search(r'\[\[.*?\]\]', cleaned)
        if matrix_match:
            matrix_str = matrix_match.group(0)
            try:
                import json
                matrix_data = json.loads(matrix_str)
                rows = []
                for row in matrix_data:
                    if isinstance(row, (list, tuple)):
                        rows.append(" & ".join(str(x) for x in row))
                    else:
                        rows.append(str(row))
                latex_matrix = r"\begin{bmatrix}" + r" \\ ".join(rows) + r"\end{bmatrix}"

                # Replace the matrix part and keep any remaining content
                remaining = cleaned.replace(matrix_str, "", 1)
                return latex_matrix + remaining
            except:
                pass

    # Pattern 3: Already proper LaTeX matrix notation
    if r"\begin{bmatrix}" in latex_str or r"\begin{pmatrix}" in latex_str or r"\begin{matrix}" in latex_str:
        return latex_str

    # Pattern 4: MathQuill matrix notation with \left[\begin{matrix}...\end{matrix}\right]
    # This is already valid LaTeX, just return it
    if r"\begin{matrix}" in latex_str:
        return latex_str

    # No matrix detected or already in correct format
    return latex_str

  def save_global_history_state(self, prob_idx):
          """Save the current global history state for a problem"""
          window.console.log(f"üü° === SAVING global history for problem {prob_idx} ===")
          try:
              global_history = document.querySelector(f"#globalHistory_{prob_idx}")
              if not global_history:
                  window.console.error(f"‚ùå No global history element found for problem {prob_idx}")
                  # List all available
                  all_global = document.querySelectorAll("[id^='globalHistory_']")
                  window.console.log(f"   Available global history elements: {all_global.length}")
                  for i in range(all_global.length):
                      window.console.log(f"     - {all_global[i].id}")
                  return

              # Save the innerHTML (preserves all attempts and formatting)
              history_html = global_history.innerHTML
              is_visible = global_history.style.display != "none"

              # Count actual attempt entries (not just the header)
              attempt_divs = global_history.querySelectorAll(".attempt-entry-wrapper")
              num_attempts = attempt_divs.length

              self.problem_global_histories[prob_idx] = {
                  "html": history_html,
                  "visible": is_visible
              }

              window.console.log(f"‚úÖ SAVED global history for problem {prob_idx}:")
              window.console.log(f"   - Visible: {is_visible}")
              window.console.log(f"   - Attempts: {num_attempts}")
              window.console.log(f"   - HTML length: {len(history_html)}")
              window.console.log(f"   - First 300 chars: {history_html[:300]}")

              # Also log the dictionary status
              window.console.log(f"   - Total problems with saved history: {len(self.problem_global_histories)}")

          except Exception as e:
              window.console.error(f"‚ùå Failed to save global history state for problem {prob_idx}: {e}")
              import traceback
              window.console.error(traceback.format_exc())

  def restore_global_history_state(self, prob_idx):
    """Restore the saved global history state for a problem"""
    window.console.log(f"üü¢ === RESTORING global history for problem {prob_idx} ===")
    try:
        window.console.log(f"   - Checking if problem {prob_idx} has saved history...")
        window.console.log(f"   - Keys in problem_global_histories: {list(self.problem_global_histories.keys())}")

        if prob_idx not in self.problem_global_histories:
            window.console.warn(f"‚ö†Ô∏è No saved global history for problem {prob_idx}")
            return False

        saved_state = self.problem_global_histories[prob_idx]
        window.console.log(f"   - Found saved state, HTML length: {len(saved_state['html'])}")
        window.console.log(f"   - First 300 chars: {saved_state['html'][:300]}")

        global_history = document.querySelector(f"#globalHistory_{prob_idx}")
        if not global_history:
            window.console.error(f"‚ùå No global history element found for problem {prob_idx}")
            # List all available
            all_global = document.querySelectorAll("[id^='globalHistory_']")
            window.console.log(f"   Available global history elements: {all_global.length}")
            for i in range(all_global.length):
                window.console.log(f"     - {all_global[i].id}")
            return False

        window.console.log(f"   - Found global history element: #globalHistory_{prob_idx}")
        window.console.log(f"   - Current HTML length before restore: {len(global_history.innerHTML)}")

        # Restore the HTML content
        global_history.innerHTML = saved_state["html"]
        window.console.log(f"   - Set innerHTML, new length: {len(global_history.innerHTML)}")

        # Restore visibility
        if saved_state["visible"]:
            global_history.style.display = "block"
        else:
            global_history.style.display = "none"

        # Count restored attempts
        attempt_divs = global_history.querySelectorAll(".attempt-entry-wrapper")
        num_attempts = attempt_divs.length

        window.console.log(f"‚úÖ RESTORED global history for problem {prob_idx}:")
        window.console.log(f"   - Visible: {saved_state['visible']}")
        window.console.log(f"   - Attempts restored: {num_attempts}")

        return True

    except Exception as e:
        window.console.error(f"‚ùå Failed to restore global history for problem {prob_idx}: {e}")
        import traceback
        window.console.error(traceback.format_exc())
        return False

  def clear_global_history(self, prob_idx):
    """Clear the global history display for a problem"""
    try:
        global_history = document.querySelector(f"#globalHistory_{prob_idx}")
        if global_history:
            # Keep the header, clear all entries
            global_history.innerHTML = "<div style='font-weight:700;margin-bottom:10px;font-size:16px;'>üìù All Attempts History:</div>"
            global_history.style.display = "none"
            window.console.log(f"‚úÖ Cleared global history for problem {prob_idx}")

        # Clear the in-memory history array
        self.global_attempt_history = []

        # Also clear the saved state
        if prob_idx in self.problem_global_histories:
            del self.problem_global_histories[prob_idx]
            window.console.log(f"‚úÖ Removed saved global history state for problem {prob_idx}")
    except Exception as e:
        window.console.error(f"Failed to clear global history: {e}")

  def load_problem(self, index, container):
    """Load a problem and restore its state"""

    # SET CURRENT INDEX IMMEDIATELY
    window.console.log(f"üìÇ === LOAD_PROBLEM called for index {index} ===")
    window.console.log(f"   - Previous current_problem_index: {self.current_problem_index}")
    self.current_problem_index = index
    window.console.log(f"   - New current_problem_index: {self.current_problem_index}")

    prob = self.problem_set[index]
    steps = prob.get("steps", [])

    container.innerHTML = ""

    # Description - display both title and description content at problem level
    desc_div = document.createElement("div")
    desc_div.className = "problem-description"
    desc_div.style.cssText = "background:#f0f9ff;padding:16px;border-radius:8px;margin-bottom:16px;"

    # Add title
    title_html = f"<h4 style='margin:0 0 12px 0;'>{html.escape(prob.get('title', 'Problem'))}</h4>"

    # Add problem description content if it exists
    prob_desc_content = prob.get("description", "")
    prob_desc_html = ""

    if prob_desc_content:
        window.console.log(f"Problem description type: {type(prob_desc_content)}")
        # Check if description is a list of blocks (like step descriptions)
        if isinstance(prob_desc_content, (list, tuple)):
            for blk in prob_desc_content:
                if isinstance(blk, dict):
                    if blk.get("type") == "text":
                        # Handle text with newlines
                        text_value = blk.get("value", "")
                        prob_desc_html += text_value.replace('\n', '<br>')
                    elif blk.get("type") == "line_break":
                        # Handle explicit line breaks from exported content
                        prob_desc_html += "<br>"
                    elif blk.get("type") == "image":
                        # Handle images with size preservation
                        image_src = blk.get("src", "")
                        if image_src:
                            # Get image metadata
                            alt_text = blk.get("alt", "")
                            size_class = blk.get("size_class", "medium")
                            
                            # Size-specific styling
                            size_styles = {
                                "small": "max-width: 80px; max-height: 60px;",
                                "medium": "max-width: 160px; max-height: 120px;",
                                "large": "max-width: 240px; max-height: 180px;",
                                "xlarge": "max-width: 320px; max-height: 240px;",
                                "full": "max-width: 100%; height: auto;"
                            }
                            
                            size_style = size_styles.get(size_class, size_styles["medium"])
                            
                            window.console.log(f"üìè Problem desc - rendering image with size class: {size_class}")
                            
                            # Create image HTML with proper styling and size preservation
                            img_style = f"display: inline-block; margin: 4px; vertical-align: middle; border-radius: 4px; object-fit: contain; {size_style}"
                            
                            prob_desc_html += f'''
                            <img src="{html.escape(image_src)}" 
                                 class="img-inline size-{size_class}"
                                 alt="{html.escape(alt_text)}" 
                                 style="{img_style}"
                                 loading="lazy"
                                 onerror="this.style.display='none'; this.nextElementSibling.style.display='inline';">
                            <span style="display:none; color:#ef4444; font-size:12px;">
                                üì∑ Image failed to load
                            </span>
                            '''
                        else:
                            prob_desc_html += '<span style="color:#6b7280; font-style:italic;">[Image placeholder]</span>'
                    elif blk.get("type") == "math":
                        latex_content = blk.get('latex', '')
                        window.console.log(f"Problem desc: Raw latex_content = {latex_content}, type = {type(latex_content)}")
                        
                        # Check if it's a Python list (direct list object)
                        if isinstance(latex_content, (list, tuple)):
                            window.console.log(f"Problem desc: Direct list matrix")
                            rows = []
                            for row in latex_content:
                                if isinstance(row, (list, tuple)):
                                    rows.append(" & ".join(str(x) for x in row))
                                else:
                                    rows.append(str(row))
                            latex_matrix = r"\begin{bmatrix}" + r" \\ ".join(rows) + r"\end{bmatrix}"
                            prob_desc_html += f"$${latex_matrix}$$"
                        
                        # Check if string contains matrix pattern with \left[ wrappers
                        elif isinstance(latex_content, str) and r"\left[" in latex_content and r"\right]" in latex_content:
                            window.console.log(f"Problem desc: String with LaTeX matrix wrappers")
                            import re
                            # Remove \left[ and \right] and extract the content
                            cleaned = latex_content.replace(r"\left[", "[").replace(r"\right]", "]")
                            window.console.log(f"Problem desc: Cleaned = {cleaned}")
                            
                            # Try to find [[...]] pattern
                            matrix_match = re.search(r'\[\[.*?\]\]', cleaned)
                            if matrix_match:
                                matrix_str = matrix_match.group(0)
                                window.console.log(f"Problem desc: Found matrix string = {matrix_str}")
                                try:
                                    import json
                                    matrix_data = json.loads(matrix_str)
                                    rows = []
                                    for row in matrix_data:
                                        if isinstance(row, (list, tuple)):
                                            rows.append(" & ".join(str(x) for x in row))
                                        else:
                                            rows.append(str(row))
                                    latex_matrix = r"\begin{bmatrix}" + r" \\ ".join(rows) + r"\end{bmatrix}"
                                    window.console.log(f"Problem desc: Converted to LaTeX = {latex_matrix}")
                                    
                                    # Check if there's additional content after the matrix
                                    remaining = cleaned.replace(matrix_str, "", 1)
                                    prob_desc_html += f"$${latex_matrix}{remaining}$$"
                                except Exception as e:
                                    window.console.error(f"Problem desc: JSON parse failed: {e}")
                                    prob_desc_html += f"\\({latex_content}\\)"
                            else:
                                # No matrix pattern found, use as-is
                                prob_desc_html += f"\\({latex_content}\\)"
                        
                        # Check if plain string starts with [[
                        elif isinstance(latex_content, str) and latex_content.strip().startswith('[['):
                            window.console.log(f"Problem desc: Plain JSON matrix string")
                            try:
                                import json
                                matrix_data = json.loads(latex_content)
                                rows = []
                                for row in matrix_data:
                                    rows.append(" & ".join(str(x) for x in row))
                                latex_matrix = r"\begin{bmatrix}" + r" \\ ".join(rows) + r"\end{bmatrix}"
                                prob_desc_html += f"$${latex_matrix}$$"
                            except Exception as e:
                                window.console.error(f"Problem desc: matrix parse error: {e}")
                                prob_desc_html += f"\\({latex_content}\\)"
                        
                        else:
                            # Regular LaTeX string
                            window.console.log(f"Problem desc: Regular LaTeX")
                            prob_desc_html += f"\\({latex_content}\\)"
        elif isinstance(prob_desc_content, str):
            # Plain string description
            # Handle multiple lines in description
            prob_desc_html = prob_desc_content.replace('\n', '<br>')
    
    desc_div.innerHTML = title_html + prob_desc_html
    container.appendChild(desc_div)

    # Global attempt history container - create it
    window.console.log(f"üìÇ Creating global history container for problem {index}")
    global_history_div = document.createElement("div")
    global_history_div.id = f"globalHistory_{index}"
    global_history_div.className = "panel"
    global_history_div.style.cssText = "background:#f8fafc;margin-bottom:16px;display:none;"

    # Check if we have saved history state for this problem
    window.console.log(f"üìÇ Checking for saved history for problem {index}")
    window.console.log(f"   - Available saved histories: {list(self.problem_global_histories.keys())}")

    if index in self.problem_global_histories:
        # Restore saved state immediately
        saved_state = self.problem_global_histories[index]
        window.console.log(f"‚úÖ Found saved history for problem {index}!")
        window.console.log(f"   - HTML length: {len(saved_state.get('html', ''))}")
        window.console.log(f"   - Visible: {saved_state.get('visible', False)}")

        global_history_div.innerHTML = saved_state.get("html", "<div style='font-weight:700;margin-bottom:10px;font-size:16px;'>üìù All Attempts History:</div>")

        if saved_state.get("visible", False):
            global_history_div.style.display = "block"
            window.console.log(f"   - Set to visible")

        # Count attempts in restored HTML
        temp_count_div = document.createElement("div")
        temp_count_div.innerHTML = saved_state.get("html", "")
        restored_attempts = temp_count_div.querySelectorAll(".attempt-entry-wrapper")
        window.console.log(f"‚úÖ Restored {restored_attempts.length} attempts for problem {index}")
    else:
        # No saved state, create fresh
        window.console.log(f"‚ÑπÔ∏è No saved history for problem {index}, creating fresh")
        global_history_div.innerHTML = "<div style='font-weight:700;margin-bottom:10px;font-size:16px;'>üìù All Attempts History:</div>"

    container.appendChild(global_history_div)
    window.console.log(f"üìÇ Appended global history div to container")

    # Verify it was added to DOM
    verification = document.querySelector(f"#globalHistory_{index}")
    if verification:
        verify_attempts = verification.querySelectorAll(".attempt-entry-wrapper")
        window.console.log(f"‚úÖ Verified global history in DOM: {verify_attempts.length} attempts")
    else:
        window.console.error(f"‚ùå Global history div NOT found in DOM after appendChild!")

    # Clear global history for this problem
    self.global_attempt_history = []

    self.solve_state = []

    # ... rest of the method continues with step loading ...
    for step_idx, step_data in enumerate(steps):
        step_div = document.createElement("div")
        step_div.className = "panel step"
        step_div.style.display = "none"

        step_desc = step_data.get("description", [])
        desc_html = ""
        for blk in step_desc:
            if blk["type"] == "text":
                # Handle multiple lines in step text blocks
                text_value = blk["value"]
                desc_html += text_value.replace('\n', '<br>')
            elif blk["type"] == "image":
                # Handle images in step descriptions with size preservation
                image_src = blk.get("src", "")
                if image_src:
                    # Get image metadata if available
                    alt_text = blk.get("alt", "")
                    is_embedded = blk.get("is_embedded", False)
                    
                    # Get preserved size class
                    size_class = blk.get("size_class", "medium")
                    
                    # Apply size-specific styling
                    size_styles = {
                        "small": "max-width: 80px; max-height: 60px;",
                        "medium": "max-width: 160px; max-height: 120px;",
                        "large": "max-width: 240px; max-height: 180px;",
                        "xlarge": "max-width: 320px; max-height: 240px;",
                        "full": "max-width: 100%; height: auto;"
                    }
                    
                    size_style = size_styles.get(size_class, size_styles["medium"])
                    
                    # Create image HTML with proper styling and size preservation
                    img_style = f"display: inline-block; margin: 4px; vertical-align: middle; border-radius: 4px; object-fit: contain; {size_style}"
                    
                    window.console.log(f"üìè Rendering step image with size class: {size_class}")
                    
                    desc_html += f'''
                    <img src="{html.escape(image_src)}" 
                         class="img-inline size-{size_class}"
                         alt="{html.escape(alt_text)}" 
                         style="{img_style}"
                         loading="lazy"
                         onerror="this.style.display='none'; this.nextElementSibling.style.display='inline';">
                    <span style="display:none; color:#ef4444; font-size:12px;">
                        üì∑ Image failed to load
                    </span>
                    '''
                else:
                    desc_html += '<span style="color:#6b7280; font-style:italic;">[Image placeholder]</span>'
            elif blk["type"] == "line_break":
                # Handle line breaks in step descriptions
                desc_html += "<br>"
            elif blk["type"] == "math":
                latex_content = blk.get('latex', '')

                window.console.log(f"Step {step_idx}: Raw latex_content = {latex_content}, type = {type(latex_content)}")

                # Matrix handling code...
                if isinstance(latex_content, (list, tuple)):
                    rows = []
                    for row in latex_content:
                        if isinstance(row, (list, tuple)):
                            rows.append(" & ".join(str(x) for x in row))
                        else:
                            rows.append(str(row))
                    latex_matrix = r"\begin{bmatrix}" + r" \\ ".join(rows) + r"\end{bmatrix}"
                    desc_html += f"$${latex_matrix}$$"
                elif isinstance(latex_content, str) and r"\left[" in latex_content and r"\right]" in latex_content:
                    import re
                    cleaned = latex_content.replace(r"\left[", "[").replace(r"\right]", "]")
                    matrix_match = re.search(r'\[\[.*?\]\]', cleaned)
                    if matrix_match:
                        matrix_str = matrix_match.group(0)
                        try:
                            import json
                            matrix_data = json.loads(matrix_str)
                            rows = []
                            for row in matrix_data:
                                if isinstance(row, (list, tuple)):
                                    rows.append(" & ".join(str(x) for x in row))
                                else:
                                    rows.append(str(row))
                            latex_matrix = r"\begin{bmatrix}" + r" \\ ".join(rows) + r"\end{bmatrix}"
                            remaining = cleaned.replace(matrix_str, "", 1)
                            desc_html += f"$${latex_matrix}{remaining}$$"
                        except Exception as e:
                            window.console.error(f"Step {step_idx}: JSON parse failed: {e}")
                            desc_html += f"\\({latex_content}\\)"
                    else:
                        desc_html += f"\\({latex_content}\\)"
                elif isinstance(latex_content, str) and latex_content.strip().startswith('[['):
                    try:
                        import json
                        matrix_data = json.loads(latex_content)
                        rows = []
                        for row in matrix_data:
                            rows.append(" & ".join(str(x) for x in row))
                        latex_matrix = r"\begin{bmatrix}" + r" \\ ".join(rows) + r"\end{bmatrix}"
                        desc_html += f"$${latex_matrix}$$"
                    except Exception as e:
                        window.console.error(f"Step {step_idx}: matrix parse error: {e}")
                        desc_html += f"\\({latex_content}\\)"
                else:
                    window.console.log(f"Step {step_idx}: Regular LaTeX")
                    desc_html += f"\\({latex_content}\\)"

        window.console.log(f"Step {step_idx} final desc_html: {desc_html}")

        # Generate minimal buttons
        button_html = self.generate_minimal_buttons(step_data)

        # Generate SVG icons for keyboard buttons
        keyboard_svg = self.get_keyboard_svg("32")
        lock_svg = self.get_lock_svg("32")

        step_div.innerHTML = f"""
        <div style='font-weight:700;margin-bottom:6px;'>Step {step_idx+1} of {len(steps)}</div>
        <div class='step-description'>{desc_html}</div>
        <div style='margin-top:8px;'>
          <div style='font-weight:700;margin-bottom:4px;'>Your Answer:</div>
          <div style='overflow-x:auto;overflow-y:hidden;max-width:100%;-webkit-overflow-scrolling:touch;border:2px solid #e6eef8;border-radius:8px;padding:10px;background:#fff;'>
            <div class='math-input step-answer'></div>
          </div>
          <div style='margin-top:8px;'>
            <div style='font-weight:600;margin-bottom:4px;font-size:13px;'>Input Buttons:</div>
            <div class='button-grid' style='display:grid;grid-template-columns:repeat(5,1fr);gap:3px;margin:0;padding:0;'>
              <button class='input-btn keyboard-activate' data-action='ACTIVATE_KEYBOARD' title='Activate Keyboard' style='grid-column:span 3;'>{keyboard_svg}<span style='font-size:11px;margin-top:2px;'>Keyboard</span></button>
              <button class='input-btn keyboard-lock' data-action='DEACTIVATE_KEYBOARD' title='Lock Keyboard' style='grid-column:span 2;'>{lock_svg}<span style='font-size:11px;margin-top:2px;'>Lock</span></button>
              {button_html}
            </div>
          </div>
          <div style='display:flex;flex-direction:column;gap:6px;margin-top:8px;'>
            <button class='btn submitAnswer'>Submit Answer</button>
            <button class='btn ghost finalizeStep' disabled>Finalize Step</button>
            <button class='btn nextStep' style='display:none;background:#10b981;'>Next Step ‚Üí</button>
          </div>
        </div>
        <div class='step-feedback'></div>
        <div class='attempts-history' style='display:none;'></div>
        """
        container.appendChild(step_div)

        # Initialize MathQuill
        if self.MQ:
            answer_field = self.MQ.MathField(step_div.querySelector(".step-answer"))
        else:
            answer_field = None

        step_obj = {
            "step": step_data,
            "container": step_div,
            "answer_mf": answer_field,
            "attempts": 0,
            "attempt_history": [],
            "correct": False,
            "finalized": False,
            "step_start_time": window.Date.now()
        }

        # Restore state if exists
        if index in self.problem_states and step_idx < len(self.problem_states[index]):
            saved = self.problem_states[index][step_idx]
            step_obj.update(saved)
            if saved.get("correct") and saved.get("attempt_history") and answer_field:
                for attempt in reversed(saved["attempt_history"]):
                    if attempt.get("correct"):
                        answer_field.latex(attempt.get("answer_latex", ""))
                        break

        self.solve_state.append(step_obj)

        # Add event listeners
        submit_btn = step_div.querySelector(".submitAnswer")
        finalize_btn = step_div.querySelector(".finalizeStep")
        next_btn = step_div.querySelector(".nextStep")

        if submit_btn:
            submit_btn.addEventListener("click", create_proxy(lambda e, i=step_idx: self.submit_answer(e, i)))
        if finalize_btn:
            finalize_btn.addEventListener("click", create_proxy(lambda e, i=step_idx: self.finalize_step(e, i)))
        if next_btn:
            next_btn.addEventListener("click", create_proxy(lambda e, i=step_idx: self.next_step(e, i)))

        # ADD INPUT BUTTON LISTENERS
        input_btns = step_div.querySelectorAll(".input-btn")
        for btn_idx in range(input_btns.length):
            btn = input_btns[btn_idx]
            action = btn.getAttribute("data-action")

            def make_input_handler(s_idx, act):
                def handler(e):
                    self.handle_input_button(s_idx, act, None)
                return handler

            btn.addEventListener("click", create_proxy(make_input_handler(step_idx, action)))

    # Show first unfinished step
    for i, step in enumerate(self.solve_state):
        if not step.get("finalized", False):
            self.show_step(i)
            break
    else:
        self.show_step(0)

    # RENDER MATHJAX FOR ALL DESCRIPTIONS
    def render_mathjax():
        if hasattr(window, 'MathJax'):
            try:
                if hasattr(window.MathJax, 'typesetPromise'):
                    window.MathJax.typesetPromise([container])
                    window.console.log("‚úÖ MathJax typesetPromise called")
                elif hasattr(window.MathJax, 'typeset'):
                    window.MathJax.typeset([container])
                    window.console.log("‚úÖ MathJax typeset called")
            except Exception as e:
                window.console.error(f"‚ùå MathJax error: {e}")
        else:
            window.console.error("‚ùå MathJax not available")

    window.setTimeout(create_proxy(render_mathjax), 200)

    self.save_to_storage()

    window.console.log(f"üìÇ === LOAD_PROBLEM completed for problem {index} ===")
    
  def show_step(self, idx):
      """Show a step by index"""
      if idx >= len(self.solve_state):
          return

      step = self.solve_state[idx]

      # ‚úÖ Check if container exists (it's a DOM element, not serializable)
      if "container" in step and step["container"]:
          step["container"].style.display = "block"
          step["step_start_time"] = window.Date.now()
      else:
          window.console.error(f"Step {idx} has no container element")

  def submit_answer(self, event, step_idx):
    """Submit validates correctness - keeps button active until finalize"""
    step = self.solve_state[step_idx]
    
    user_latex = step["answer_mf"].latex().strip() if step.get("answer_mf") else ""
    if not user_latex:
        self.show_feedback(step_idx, "‚ö†Ô∏è Please enter an answer", "#92400e")
        return

    window.console.log(f"Submit answer: problem {self.current_problem_index}, step {step_idx}")
    
    # ‚úÖ Parse user answer (preserves metadata)
    parsed_user = self.math_parser.parse(user_latex)
    
    if parsed_user is None:
        self.show_feedback(step_idx, "‚ùå Could not parse your answer", "#b91c1c")
        return
    
    # ‚úÖ CRITICAL: Store the parsed (unnormalized) result for structure checking later
    step["parsed_user_answer"] = parsed_user
    window.console.log(f"‚úÖ Stored parsed_user_answer for structure checking")
    
    # Get expected answer
    expected_latex = step["step"].get("expression", "")
    parsed_expected = self.math_parser.parse(expected_latex)
    
    if parsed_expected is None:
        self.show_feedback(step_idx, "‚ùå Error with expected answer", "#b91c1c")
        return
    
    # ‚úÖ Normalize for correctness checking
    try:
        import sympy as sp
        
        # Normalize using simplify
        if isinstance(parsed_user, sp.Matrix):
            normalized_user = parsed_user.applyfunc(sp.simplify)
        else:
            normalized_user = sp.simplify(parsed_user)
            
        if isinstance(parsed_expected, sp.Matrix):
            normalized_expected = parsed_expected.applyfunc(sp.simplify)
        else:
            normalized_expected = sp.simplify(parsed_expected)
        
        window.console.log(f"‚úÖ Normalized user: {normalized_user}")
        window.console.log(f"‚úÖ Normalized expected: {normalized_expected}")
        
    except Exception as e:
        window.console.error(f"Normalization error: {e}")
        # Use parsed values if normalization fails
        normalized_user = parsed_user
        normalized_expected = parsed_expected
    
    # ‚úÖ Check equality
    try:
        import sympy as sp
        
        is_correct = False
        
        if isinstance(normalized_user, sp.MatrixBase) and isinstance(normalized_expected, sp.MatrixBase):
            # Matrix comparison
            if normalized_user.shape != normalized_expected.shape:
                is_correct = False
            else:
                is_correct = True
                for i in range(normalized_user.rows):
                    for j in range(normalized_user.cols):
                        diff = sp.simplify(normalized_user[i, j] - normalized_expected[i, j])
                        if diff != 0:
                            is_correct = False
                            break
                    if not is_correct:
                        break
        else:
            # Scalar comparison
            diff = sp.simplify(normalized_user - normalized_expected)
            is_correct = (diff == 0)
        
        window.console.log(f"‚úÖ Equality check result: {is_correct}")
        
    except Exception as e:
        window.console.error(f"Equality check error: {e}")
        import traceback
        window.console.error(traceback.format_exc())
        is_correct = False
    
    if is_correct:
        step["correct"] = True
        step["last_correct_answer"] = user_latex
        
        # Enable finalize button
        finalize_btn = step["container"].querySelector(".finalizeStep")
        if finalize_btn:
            finalize_btn.disabled = False
            finalize_btn.style.opacity = "1"
            finalize_btn.style.cursor = "pointer"
        
        msg = "‚úÖ Correct! Now click Finalize to check your method."
        color = "#059669"
        
        self.add_to_global_history(step_idx, user_latex, True, 0, "submit")
    else:
        step["correct"] = False
        msg = "‚ùå Incorrect. Try again."
        color = "#b91c1c"
        
        self.add_to_global_history(step_idx, user_latex, False, 0, "submit")
    
    self.show_feedback(step_idx, msg, color)
    self.save_to_storage()

  def _compare_matrix_operations(self, user_ops, expected_ops):
    """
    Compare matrix operations semantically (ignoring list/tuple and float/fraction differences)
    """
    import sympy as sp
    
    if len(user_ops) != len(expected_ops):
        return False
    
    for user_op, exp_op in zip(user_ops, expected_ops):
        # Compare operation type
        if user_op.get("type") != exp_op.get("type"):
            return False
        
        # Compare operation details
        user_operations = user_op.get("operations", [])
        exp_operations = exp_op.get("operations", [])
        
        if len(user_operations) != len(exp_operations):
            return False
        
        for user_step, exp_step in zip(user_operations, exp_operations):
            # Compare step type
            if user_step.get("type") != exp_step.get("type"):
                return False
            
            # Compare details (normalize list/tuple and numeric values)
            user_details = user_step.get("details", [])
            exp_details = exp_step.get("details", [])
            
            if not self._compare_operation_details(user_details, exp_details):
                return False
    
    return True

    def _is_numeric(self, val):
      """Check if value is numeric (including SymPy numeric types)"""
      import sympy as sp

      # Check Python built-in numeric types
      if isinstance(val, (int, float, complex)):
          return True

      # Check SymPy numeric types
      try:
          if isinstance(val, sp.Basic):
              if hasattr(val, 'is_number'):
                  if val.is_number:
                      return True
              if isinstance(val, (sp.Number, sp.Integer, sp.Float, sp.Rational)):
                  return True
      except Exception:
          pass

      # For strings, be very explicit
      if isinstance(val, str):
          val_stripped = val.strip()

          # Try simple float
          try:
              float(val_stripped)
              return True
          except:
              pass

          # Try fraction - be very explicit about parsing
          if '/' in val_stripped:
              try:
                  parts = val_stripped.split('/')
                  if len(parts) == 2:
                      numerator = float(parts[0].strip())
                      denominator = float(parts[1].strip())
                      if denominator != 0:
                          return True
              except:
                  pass

      # Last resort: try sympify
      try:
          import sympy as sp
          sym_val = sp.sympify(val)
          if hasattr(sym_val, 'is_number') and sym_val.is_number:
              return True
      except:
          pass

      return False

  def _compare_numeric_values(self, val1, val2, tolerance=1e-9):
      """
      Compare two numeric values semantically (0.5 == 1/2)
      """
      import sympy as sp

      def to_float(val):
          """Convert any numeric representation to float"""
          # Already a float
          if isinstance(val, float):
              return val

          # Integer
          if isinstance(val, int):
              return float(val)

          # SymPy object
          if isinstance(val, sp.Basic):
              try:
                  return float(val.evalf())
              except:
                  pass

          # String
          if isinstance(val, str):
              val_stripped = val.strip()

              # Try direct float conversion
              try:
                  return float(val_stripped)
              except:
                  pass

              # Try fraction
              if '/' in val_stripped:
                  try:
                      parts = val_stripped.split('/')
                      if len(parts) == 2:
                          num = float(parts[0].strip())
                          denom = float(parts[1].strip())
                          if denom != 0:
                              return num / denom
                  except:
                      pass

          # Last resort: sympify
          try:
              sym_val = sp.sympify(val)
              return float(sym_val.evalf())
          except:
              pass

          raise ValueError(f"Cannot convert {val} (type: {type(val)}) to float")

      try:
          num1 = to_float(val1)
          num2 = to_float(val2)

          result = abs(num1 - num2) < tolerance

          # Debug logging
          window.console.log(f"  üî¢ Comparing: {val1} ({num1}) vs {val2} ({num2}) ‚Üí {result}")

          return result

      except Exception as e:
          window.console.error(f"‚ùå Numeric comparison error: {e}")
          window.console.error(f"   val1={val1} (type={type(val1).__name__})")
          window.console.error(f"   val2={val2} (type={type(val2).__name__})")

          # Absolute fallback: string comparison
          return str(val1) == str(val2)

  def _compare_operation_details(self, user_details, exp_details):
      """
      Compare operation details element by element, handling nested structures
      """
      import sympy as sp

      # Convert to lists if needed (handle tuple vs list)
      user_list = list(user_details) if isinstance(user_details, (list, tuple)) else [user_details]
      exp_list = list(exp_details) if isinstance(exp_details, (list, tuple)) else [exp_details]

      if len(user_list) != len(exp_list):
          window.console.log(f"‚ùå Length mismatch: {len(user_list)} != {len(exp_list)}")
          return False

      for idx, (user_elem, exp_elem) in enumerate(zip(user_list, exp_list)):
          # Handle nested tuples/lists (e.g., ('scale', 1, 0.5))
          if isinstance(user_elem, (list, tuple)) and isinstance(exp_elem, (list, tuple)):
              if not self._compare_operation_details(user_elem, exp_elem):
                  window.console.log(f"‚ùå Nested comparison failed at index {idx}")
                  return False

          # Handle numeric comparisons
          elif self._is_numeric(user_elem) and self._is_numeric(exp_elem):
              if not self._compare_numeric_values(user_elem, exp_elem):
                  window.console.log(f"‚ùå Numeric comparison failed at index {idx}: {user_elem} != {exp_elem}")
                  return False
              else:
                  window.console.log(f"‚úÖ Numeric match at index {idx}: {user_elem} == {exp_elem}")

          # Handle string/other comparisons
          else:
              if user_elem != exp_elem:
                  window.console.log(f"‚ùå Direct comparison failed at index {idx}: {user_elem} != {exp_elem}")
                  return False
              else:
                  window.console.log(f"‚úÖ Direct match at index {idx}: {user_elem}")

      return True
  
  def finalize_step(self, event, step_idx):
      """
      Finalize validates structure - keeps button active if structure wrong.
      Now handles matrix operations properly with semantic comparison.
      """

      window.console.log(f"üîç Finalize step: problem {self.current_problem_index}, step {step_idx}")

      # Verify state
      if not hasattr(self, 'solve_state') or step_idx >= len(self.solve_state):
          window.console.error(f"‚ùå Invalid state")
          window.alert("Error: Invalid step state. Please reload the problem.")
          return

      step = self.solve_state[step_idx]

      if not step.get("correct"):
          self.show_feedback(step_idx, "‚ùå Submit correct answer first", "#b91c1c")
          return

      # ‚úÖ CRITICAL: Use the parsed (unnormalized) result stored during submit
      parsed_user = step.get("parsed_user_answer")

      if parsed_user is None:
          # Fallback: try to parse again
          user_latex = step["answer_mf"].latex().strip() if step.get("answer_mf") else ""
          if not user_latex:
              self.show_feedback(step_idx, "‚ùå No answer to finalize", "#b91c1c")
              return

          try:
              parsed_user = self.math_parser.parse(user_latex)
          except Exception as e:
              window.console.error(f"‚ùå Parse error: {e}")
              parsed_user = None

      if parsed_user is None:
          self.show_feedback(step_idx,
              "‚ö†Ô∏è Could not parse your answer. Finalized (no structure check).",
              "#92400e")
          step["finalized"] = True
          self._finalize_step_ui(step_idx)
          self.update_step_progress_display(self.current_problem_index)
          self.save_to_storage()
          return

      # Get expected structure
      expected_struct = step["step"].get("expected_structure")
      if not expected_struct:
          window.console.error("‚ùå ERROR: Missing expected_structure")
          self.show_feedback(step_idx, "‚ùå ERROR: Missing expected_structure in problem data.", "#dc2626")
          step["finalized"] = True
          self._finalize_step_ui(step_idx)
          self.update_step_progress_display(self.current_problem_index)
          self.save_to_storage()
          return

      # Ensure expected structure has matrix_ops field
      if "matrix_ops" not in expected_struct:
          window.console.warn(f"‚ö†Ô∏è Expected structure missing matrix_ops field, adding empty list")
          expected_struct["matrix_ops"] = []

      # ‚úÖ Extract user structure BEFORE normalization (from the stored parsed result)
      try:
          user_struct = self.math_parser.extract_structure(parsed_user)

          window.console.log("=" * 60)
          window.console.log("üìä STRUCTURE COMPARISON")
          window.console.log("=" * 60)
          window.console.log(f"Expected structure:")
          window.console.log(f"  Operators: {expected_struct.get('operators', {})}")
          window.console.log(f"  Operands: {expected_struct.get('operands', {})}")
          window.console.log(f"  Matrix ops: {expected_struct.get('matrix_ops', [])}")
          window.console.log(f"User structure:")
          window.console.log(f"  Operators: {user_struct.get('operators', {})}")
          window.console.log(f"  Operands: {user_struct.get('operands', {})}")
          window.console.log(f"  Matrix ops: {user_struct.get('matrix_ops', [])}")
          window.console.log("=" * 60)

      except Exception as e:
          window.console.error(f"‚ùå Structure extraction error: {e}")
          import traceback
          window.console.error(traceback.format_exc())

          self.show_feedback(step_idx,
              "‚ö†Ô∏è Error analyzing structure. Finalized (no structure check).",
              "#92400e")
          step["finalized"] = True
          self._finalize_step_ui(step_idx)
          self.update_step_progress_display(self.current_problem_index)
          self.save_to_storage()
          return

      # ‚úÖ Check if expected answer has matrix operations
      expected_has_matrix_ops = len(expected_struct.get("matrix_ops", [])) > 0
      user_has_matrix_ops = len(user_struct.get("matrix_ops", [])) > 0

      window.console.log(f"üî¢ Expected has matrix ops: {expected_has_matrix_ops}")
      window.console.log(f"üî¢ User has matrix ops: {user_has_matrix_ops}")

      # Track finalize attempts
      if not step.get("finalize_attempts"):
          step["finalize_attempts"] = 0
      if not step.get("finalize_history"):
          step["finalize_history"] = []

      step["finalize_attempts"] += 1

      # ‚úÖ Determine if structure matches based on whether expected has matrix operations
      same_structure = False
      mismatch_reason = []

      if expected_has_matrix_ops:
          # ‚úÖ Expected has matrix ops - user MUST also have matrix ops
          window.console.log("üìã Expected answer requires matrix operations")

          if not user_has_matrix_ops:
              mismatch_reason.append("missing_matrix_ops")
              window.console.log("‚ùå User didn't use matrix operations but expected answer requires them")
          else:
              # Both have matrix ops - compare them
              same_matrix_ops = self._compare_matrix_operations(
                  user_struct.get("matrix_ops", []),
                  expected_struct.get("matrix_ops", [])
              )
              same_operators = user_struct.get("operators", {}) == expected_struct.get("operators", {})
              same_operands = user_struct.get("operands", {}) == expected_struct.get("operands", {})

              window.console.log(f"  Matrix ops match: {same_matrix_ops}")
              window.console.log(f"  Operators match: {same_operators}")
              window.console.log(f"  Operands match: {same_operands}")

              if not same_matrix_ops:
                  mismatch_reason.append("different_matrix_ops")
                  window.console.log("‚ùå Matrix operations don't match")
              if not same_operators:
                  mismatch_reason.append("different_operators")
              if not same_operands:
                  mismatch_reason.append("different_operands")

              # ‚úÖ CRITICAL: Actually set same_structure!
              same_structure = same_matrix_ops and same_operators and same_operands

      else:
          # ‚úÖ Expected does NOT have matrix ops - standard structure comparison
          window.console.log("üìã Expected answer does NOT require matrix operations")

          same_operators = user_struct.get("operators", {}) == expected_struct.get("operators", {})
          same_operands = user_struct.get("operands", {}) == expected_struct.get("operands", {})
          same_matrix_ops = user_struct.get("matrix_ops", []) == expected_struct.get("matrix_ops", [])

          window.console.log(f"  Operators match: {same_operators}")
          window.console.log(f"  Operands match: {same_operands}")
          window.console.log(f"  Matrix ops match: {same_matrix_ops}")

          if user_has_matrix_ops:
              mismatch_reason.append("unexpected_matrix_ops")
              window.console.log("‚ùå User used matrix operations but expected answer doesn't require them")
          if not same_operators:
              mismatch_reason.append("different_operators")
          if not same_operands:
              mismatch_reason.append("different_operands")

          # ‚úÖ CRITICAL: Set same_structure for non-matrix case too!
          same_structure = same_operators and same_operands and same_matrix_ops

      window.console.log(f"üéØ Structure match result: {same_structure}")
      if mismatch_reason:
          window.console.log(f"‚ö†Ô∏è Mismatch reasons: {mismatch_reason}")

      if same_structure:
          # ‚úÖ SUCCESS - finalize and proceed
          window.console.log("‚úÖ STRUCTURE MATCH - Finalizing step")

          step["finalized"] = True
          step["structure_correct"] = True

          step["finalize_history"].append({
              "attempt_number": step["finalize_attempts"],
              "structure_match": True,
              "user_structure": user_struct,
              "timestamp": window.Date.now()
          })

          # Disable buttons
          finalize_btn = step["container"].querySelector(".finalizeStep")
          if finalize_btn:
              finalize_btn.disabled = True
              finalize_btn.style.opacity = "0.5"
              finalize_btn.style.cursor = "not-allowed"

          submit_btn = step["container"].querySelector(".submitAnswer")
          if submit_btn:
              submit_btn.disabled = True
              submit_btn.style.opacity = "0.5"
              submit_btn.style.cursor = "not-allowed"

          # Show next step button
          if step_idx + 1 < len(self.solve_state):
              next_btn = step["container"].querySelector(".nextStep")
              if next_btn:
                  next_btn.style.display = "block"

          msg = "‚úÖ Finalized ‚Äî your solution method matches perfectly!"
          color = "#059669"

          # ‚úÖ UPDATE HEADER ON SUCCESS ONLY
          self.update_step_progress_display(self.current_problem_index)

      else:
          # ‚ùå FAILED - keep trying
          window.console.log("‚ùå STRUCTURE MISMATCH - Not finalizing")

          step["finalized"] = False
          step["structure_correct"] = False

          step["finalize_history"].append({
              "attempt_number": step["finalize_attempts"],
              "structure_match": False,
              "user_structure": user_struct,
              "expected_structure": expected_struct,
              "mismatch_reasons": mismatch_reason,
              "timestamp": window.Date.now()
          })

          # ‚úÖ Build detailed feedback message based on mismatch type
          msg_parts = [f"‚ùå Attempt {step['finalize_attempts']}: Structure mismatch.<br><br>"]

          if "missing_matrix_ops" in mismatch_reason:
              msg_parts.append(
                  "<strong>‚ö†Ô∏è You must use matrix row operations!</strong><br>"
                  "The expected answer requires matrix notation with row operations.<br><br>"
                  "<strong>Example format:</strong><br>"
                  "<code>[[1,2],[3,4]]|R_1‚Üí2R_1</code><br><br>"
                  "You entered the final result without showing the row operations.<br>"
              )
          elif "unexpected_matrix_ops" in mismatch_reason:
              msg_parts.append(
                  "<strong>‚ö†Ô∏è Don't use matrix row operations here.</strong><br>"
                  "The expected answer doesn't require row operations.<br>"
                  "Try solving without matrix notation.<br>"
              )
          elif "different_matrix_ops" in mismatch_reason:
              user_ops = user_struct.get("matrix_ops", [])
              expected_ops = expected_struct.get("matrix_ops", [])

              msg_parts.append("<strong>üî¢ Matrix operations differ:</strong><br>")

              # Show comparison
              if len(user_ops) != len(expected_ops):
                  msg_parts.append(
                      f"Expected: {len(expected_ops)} matrix operation(s)<br>"
                      f"You used: {len(user_ops)} matrix operation(s)<br><br>"
                  )
              else:
                  msg_parts.append("Same number of operations, but different row operations used<br><br>")

              # Show expected operations details
              if expected_ops:
                  msg_parts.append(f"<strong>Expected operations:</strong><br>")
                  for i, op in enumerate(expected_ops):
                      operations = op.get("operations", [])
                      msg_parts.append(f"&nbsp;&nbsp;<strong>Matrix op {i+1}:</strong> {len(operations)} row operation(s)<br>")
                      for j, row_op in enumerate(operations):
                          op_type = row_op.get("type", "unknown")
                          details = row_op.get("details", [])
                          msg_parts.append(f"&nbsp;&nbsp;&nbsp;&nbsp;‚Ä¢ Step {j+1}: <code>{op_type}</code> {details}<br>")
                  msg_parts.append("<br>")

              # Show user operations details
              if user_ops:
                  msg_parts.append(f"<strong>Your operations:</strong><br>")
                  for i, op in enumerate(user_ops):
                      operations = op.get("operations", [])
                      msg_parts.append(f"&nbsp;&nbsp;<strong>Matrix op {i+1}:</strong> {len(operations)} row operation(s)<br>")
                      for j, row_op in enumerate(operations):
                          op_type = row_op.get("type", "unknown")
                          details = row_op.get("details", [])
                          msg_parts.append(f"&nbsp;&nbsp;&nbsp;&nbsp;‚Ä¢ Step {j+1}: <code>{op_type}</code> {details}<br>")
                  msg_parts.append("<br>")
          else:
              # Standard operator/operand mismatch
              if "different_operators" in mismatch_reason and "different_operands" not in mismatch_reason:
                  msg_parts.append(
                      "<strong>Same values, different method.</strong><br>"
                      f"<small>Expected operators: {expected_struct.get('operators', {})}</small><br>"
                      f"<small>Your operators: {user_struct.get('operators', {})}</small><br><br>"
                  )
              elif "different_operands" in mismatch_reason and "different_operators" not in mismatch_reason:
                  msg_parts.append(
                      "<strong>Correct operations, different values.</strong><br>"
                      f"<small>Expected values: {expected_struct.get('operands', {})}</small><br>"
                      f"<small>Your values: {user_struct.get('operands', {})}</small><br><br>"
                  )
              else:
                  msg_parts.append(
                      "<strong>Both operations and values differ.</strong><br>"
                      f"<small>Expected: ops={expected_struct.get('operators', {})}, vals={expected_struct.get('operands', {})}</small><br>"
                      f"<small>Yours: ops={user_struct.get('operators', {})}, vals={user_struct.get('operands', {})}</small><br><br>"
                  )

          msg_parts.append("<strong>üí° Try a different approach and click Finalize again.</strong>")
          msg = "".join(msg_parts)
          color = "#dc2626"

          # Add to history display
          self.add_finalize_attempt_to_history(step_idx, user_struct, expected_struct, False)

          # ‚ùå DO NOT UPDATE HEADER ON FAILURE

      self.show_feedback(step_idx, msg, color)
      self.save_to_storage()

  def _finalize_step_ui(self, step_idx):
      """Helper method to update UI when step is finalized"""
      if not hasattr(self, 'solve_state') or step_idx >= len(self.solve_state):
          return

      step = self.solve_state[step_idx]

      # Disable buttons
      finalize_btn = step["container"].querySelector(".finalizeStep")
      if finalize_btn:
          finalize_btn.disabled = True
          finalize_btn.style.opacity = "0.5"
          finalize_btn.style.cursor = "not-allowed"

      submit_btn = step["container"].querySelector(".submitAnswer")
      if submit_btn:
          submit_btn.disabled = True
          submit_btn.style.opacity = "0.5"
          submit_btn.style.cursor = "not-allowed"

      # Show next step button if available
      if step_idx + 1 < len(self.solve_state):
          next_btn = step["container"].querySelector(".nextStep")
          if next_btn:
              next_btn.style.display = "block"
  def update_step_progress_display(self, prob_idx):
      """Update accordion header with current progress (only finalized steps count)"""
      acc = document.querySelector(f".accordion-problem[data-index='{prob_idx}']")
      if not acc:
          return

      header = acc.querySelector(".progress-summary")
      if not header:
          return

      # Get current state
      if self.current_problem_index == prob_idx and hasattr(self, 'solve_state'):
          prob_state = self.solve_state
      else:
          prob_state = self.problem_states.get(prob_idx, [])

      if not prob_state:
          return

      # Calculate stats - only count finalized steps
      total_steps = len(prob_state)
      finalized = sum(1 for s in prob_state if s.get("finalized", False))

      # ‚úÖ Build display with conditional styling
      if finalized == total_steps and total_steps > 0:
          # ‚úÖ ALL steps finalized - GREENISH background
          status = f"‚úÖ {finalized}/{total_steps} completed"
          text_color = "#059669"  # Green text
          bg_color = "#d1fae5"    # ‚úÖ Greenish background (emerald-100)
          acc.classList.add("finished")
      elif finalized > 0:
          # ‚ö†Ô∏è Some steps finalized - KEEP ORIGINAL blue background
          status = f"‚úÖ {finalized}/{total_steps} completed"
          text_color = "#059669"  # Green text (to show progress)
          bg_color = "#f0f4ff"    # ‚ùå Keep original light blue
          acc.classList.remove("finished")
      else:
          # No steps finalized yet - ORIGINAL blue background
          status = f"{finalized}/{total_steps} completed"
          text_color = "#6b7280"  # Gray text
          bg_color = "#f0f4ff"    # Original light blue
          acc.classList.remove("finished")

      # Update header text and colors
      header.innerHTML = status
      header.style.color = text_color

      # ‚úÖ Update header background color
      header_el = acc.querySelector(".accordion-header")
      if header_el:
          header_el.style.background = bg_color

  def add_finalize_attempt_to_history(self, step_idx, user_struct, expected_struct, success):
    """Add finalize attempt to history display"""
    step = self.solve_state[step_idx]
    history = step["container"].querySelector(".attempts-history")
    if history:
        history.style.display = "block"

        # ‚úÖ Create wrapper with horizontal scroll
        entry = document.createElement("div")
        entry.className = "attempt-entry-wrapper"

        if success:
            entry.style.background = "#dcfce7"
            entry.style.border = "2px solid #86efac"
            status_text = "‚úÖ Structure Match"
            status_emoji = "üéØ"
        else:
            entry.style.background = "#fef3c7"
            entry.style.border = "2px solid #fbbf24"
            status_text = "‚ö†Ô∏è Structure Mismatch"
            status_emoji = "üîç"

        # Label as "Finalize Attempt"
        entry.innerHTML = f"""
        <div style='font-weight:700;font-size:15px;white-space:nowrap;'>
            {status_emoji} Finalize Attempt #{step.get('finalize_attempts', 0)} - {status_text}
        </div>
        <div style='margin-top:6px;padding:8px;background:#fff;border-radius:6px;overflow-x:auto;'>
            <strong>Your structure:</strong><br>
            Operations: {user_struct.get('operators', {})}<br>
            Values: {user_struct.get('operands', {})}
        </div>
        """

        if not success:
            expected_info = document.createElement("div")
            expected_info.style.cssText = "margin-top:6px;padding:8px;background:#fff;border-radius:6px;overflow-x:auto;"
            expected_info.innerHTML = f"""
            <strong>Expected structure:</strong><br>
            Operations: {expected_struct.get('operators', {})}<br>
            Values: {expected_struct.get('operands', {})}
            """
            entry.appendChild(expected_info)

        history.appendChild(entry)

        # Also add to global history
        user_latex = step["answer_mf"].latex() if step.get("answer_mf") else ""
        time_taken = 0  # Finalize doesn't track time separately
        self.add_to_global_history(step_idx, user_latex, success, time_taken, "finalize")

  def next_step(self, event, step_idx):
      self.solve_state[step_idx]["container"].style.display = "none"
      if step_idx + 1 < len(self.solve_state):
          self.show_step(step_idx + 1)
      self.save_to_storage()

  def show_feedback(self, step_idx, message, color):
      step = self.solve_state[step_idx]
      feedback = step["container"].querySelector(".step-feedback")
      if feedback:
          feedback.innerHTML = f"<div style='color:{color};background:{color}20;padding:10px;border-radius:6px;'>{message}</div>"

  def add_attempt_to_history(self, step_idx, latex, correct, time_taken):
    """Add submit answer attempt to both step-level and global history display"""
    step = self.solve_state[step_idx]

    # Format latex for proper display
    formatted_latex = self.format_latex_for_display(latex)

    # Add to step-level history
    history = step["container"].querySelector(".attempts-history")
    if history:
        history.style.display = "block"

        # Create wrapper with horizontal scroll
        entry = document.createElement("div")
        entry.className = "attempt-entry-wrapper"
        entry.style.background = "#dcfce7" if correct else "#fee2e2"
        entry.style.border = f"2px solid {'#86efac' if correct else '#fecaca'}"

        entry.innerHTML = f"""
        <div style='font-weight:700;font-size:15px;white-space:nowrap;'>
            üìù Submit Attempt #{step['attempts']} ({time_taken}s) - {'‚úÖ Correct' if correct else '‚ùå Incorrect'}
        </div>
        <div style='margin-top:6px;padding:8px;background:#fff;border-radius:6px;'>
            $$\displaystyle {formatted_latex}$$
        </div>
        """

        history.appendChild(entry)

        # Re-render MathJax
        if hasattr(window, 'MathJax'):
            window.MathJax.typesetPromise([entry])

    # CRITICAL: Add to global history
    window.console.log(f"üîµ Calling add_to_global_history for step {step_idx}, correct={correct}")
    self.add_to_global_history(step_idx, latex, correct, time_taken, "submit")

  def add_to_global_history(self, step_idx, latex, correct, time_taken, attempt_type):
    """Add attempt to global history view"""
    window.console.log(f"üîµ add_to_global_history called:")
    window.console.log(f"   - step_idx: {step_idx}")
    window.console.log(f"   - current_problem_index: {self.current_problem_index}")
    window.console.log(f"   - attempt_type: {attempt_type}")
    window.console.log(f"   - correct: {correct}")

    if self.current_problem_index is None:
        window.console.error(f"‚ùå current_problem_index is None, cannot add to global history")
        return

    global_history_id = f"#globalHistory_{self.current_problem_index}"
    window.console.log(f"   - Looking for element: {global_history_id}")

    global_history = document.querySelector(global_history_id)
    if not global_history:
        window.console.error(f"‚ùå Global history element not found: {global_history_id}")
        # Try to list all global history elements
        all_global = document.querySelectorAll("[id^='globalHistory_']")
        window.console.log(f"   - Available global history elements: {all_global.length}")
        for i in range(all_global.length):
            window.console.log(f"     - {all_global[i].id}")
        return

    window.console.log(f"‚úÖ Found global history element")

    # Show the container
    global_history.style.display = "block"

    # Format latex for proper display
    formatted_latex = self.format_latex_for_display(latex)

    # Create wrapper with horizontal scroll
    entry = document.createElement("div")
    entry.className = "attempt-entry-wrapper"

    if attempt_type == "submit":
        entry.style.background = "#dcfce7" if correct else "#fee2e2"
        entry.style.border = f"2px solid {'#86efac' if correct else '#fecaca'}"
        status_text = '‚úÖ Correct' if correct else '‚ùå Incorrect'
        step_label = f"Step {step_idx + 1}"
    else:  # finalize
        entry.style.background = "#dcfce7" if correct else "#fef3c7"
        entry.style.border = f"2px solid {'#86efac' if correct else '#fbbf24'}"
        status_text = '‚úÖ Structure Match' if correct else '‚ö†Ô∏è Structure Mismatch'
        step_label = f"Step {step_idx + 1} - Finalize"

    entry.innerHTML = f"""
    <div style='font-weight:700;font-size:15px;white-space:nowrap;'>
        {step_label}: {status_text} ({time_taken if time_taken else 0}s)
    </div>
    <div style='margin-top:6px;padding:8px;background:#fff;border-radius:6px;'>
        $$\displaystyle {formatted_latex}$$
    </div>
    """

    global_history.appendChild(entry)
    window.console.log(f"‚úÖ Appended entry to global history")

    # Count total attempts now
    attempt_divs = global_history.querySelectorAll(".attempt-entry-wrapper")
    window.console.log(f"‚úÖ Total attempts in global history: {attempt_divs.length}")

    # Re-render MathJax
    if hasattr(window, 'MathJax'):
        window.MathJax.typesetPromise([entry])

    # Scroll to bottom of global history
    global_history.scrollTop = global_history.scrollHeight

  def update_progress(self, prob_idx):
        acc = document.querySelector(f".accordion-problem[data-index='{prob_idx}']")
        if not acc: return

        prob_state = self.problem_states.get(prob_idx, [])
        total = len(self.problem_set[prob_idx].get("steps", []))
        finalized = sum(1 for s in prob_state if s.get("finalized", False))

        header = acc.querySelector(".progress-summary")
        if finalized == total and total > 0:
            header.innerHTML = f"‚úÖ {finalized}/{total} completed"
            header.style.color = "#059669"
            acc.classList.add("finished")
        else:
            header.innerHTML = f"{finalized}/{total} completed"
            header.style.color = "#6b7280"

  #def reset_current(self, event):
  #    if self.current_problem_index is None:
  #        window.alert("No problem selected")
  #        return
#
  #    if not window.confirm("Reset current problem progress?"):
  #        return
#
  #    # Reset state
  #    for step in self.solve_state:
  #        step["attempts"] = 0
  #        step["attempt_history"] = []
  #        step["correct"] = False
  #        step["finalized"] = False
  #        if step.get("answer_mf"):
  #            step["answer_mf"].latex("")
#
  #        history = step["container"].querySelector(".attempts-history")
  #        if history:
  #            history.innerHTML = ""
  #            history.style.display = "none"
#
  #        submit_btn = step["container"].querySelector(".submitAnswer")
  #        if submit_btn:
  #            submit_btn.disabled = False
  #        finalize_btn = step["container"].querySelector(".finalizeStep")
  #        if finalize_btn:
  #            finalize_btn.disabled = True
  #        next_btn = step["container"].querySelector(".nextStep")
  #        if next_btn:
  #            next_btn.style.display = "none"
  #        feedback = step["container"].querySelector(".step-feedback")
  #        if feedback:
  #            feedback.innerHTML = ""
#
  #    # Save and refresh
  #    self.problem_states[self.current_problem_index] = self.solve_state
  #    self.save_to_storage()
  #    self.show_step(0)
  #    self.update_progress(self.current_problem_index)
#
  #    window.alert("Problem reset successfully")

  def export_progress(self, event):
      """Export student progress with complete problem states for all problems"""
      if not self.problem_set:
          window.alert("No problems to submit")
          return

      try:
          window.console.log("=== Starting progress submission ===")

          # Save current problem state first
          if self.current_problem_index is not None and hasattr(self, 'solve_state'):
              window.console.log(f"Saving current problem {self.current_problem_index} state")
              serializable_state = []
              for step in self.solve_state:
                  step_data = {
                      "step": step.get("step", {}),
                      "attempts": step.get("attempts", 0),
                      "attempt_history": step.get("attempt_history", []),
                      "correct": step.get("correct", False),
                      "finalize_attempts": step.get("finalize_attempts", 0),
                      "finalize_history": step.get("finalize_history", []),
                      "structure_correct": step.get("structure_correct", False),
                      "finalized": step.get("finalized", False),
                      "step_start_time": step.get("step_start_time", window.Date.now())
                  }
                  serializable_state.append(step_data)

              self.problem_states[self.current_problem_index] = serializable_state

          # NEW: Create complete problem states for ALL problems in the set
          window.console.log("Building complete problem states for all problems...")
          complete_problem_states = {}

          for prob_idx in range(len(self.problem_set)):
              if prob_idx in self.problem_states:
                  # Use existing state for worked problems
                  window.console.log(f"Problem {prob_idx}: Using existing state")
                  complete_problem_states[prob_idx] = self.problem_states[prob_idx]
              else:
                  # Create empty state for unworked problems
                  window.console.log(f"Problem {prob_idx}: Creating empty state (not worked)")
                  problem = self.problem_set[prob_idx]
                  steps = problem.get("steps", [])
                  empty_state = []

                  for step_idx, step_data in enumerate(steps):
                      empty_step = {
                          "step": step_data,
                          "attempts": 0,
                          "attempt_history": [],
                          "correct": False,
                          "finalize_attempts": 0,
                          "finalize_history": [],
                          "structure_correct": False,
                          "finalized": False,
                          "step_start_time": 0
                      }
                      empty_state.append(empty_step)

                  complete_problem_states[prob_idx] = empty_state

          # Build submission data with complete states
          window.console.log("Building submission data...")
          raw_export_data = {
              "problem_set_id": self.current_problem_set_uuid,
              "problem_set": self.problem_set,
              "problem_states": complete_problem_states,  # Now includes ALL problems
              "export_date": window.Date.new().toISOString()
          }

          # Convert all JsProxy objects to native Python types
          window.console.log("Converting to native types...")
          export_data = self._convert_to_native(raw_export_data)

          # Serialize to JSON
          window.console.log("Serializing to JSON...")
          json_str = json.dumps(export_data)
          window.console.log(f"JSON length: {len(json_str)}")

          # Compress
          window.console.log("Compressing...")
          import brotli
          compressed = brotli.compress(json_str.encode('utf-8'))
          window.console.log(f"Compressed length: {len(compressed)}")

          # Encode to base64
          b64_str = base64.b64encode(compressed).decode('utf-8')
          window.console.log(f"Base64 length: {len(b64_str)}")

          # Create export file content
          output = f"=== STUDENT PROGRESS EXPORT ===\n{b64_str}\n=== END EXPORT ==="

          # Download as file
          blob = window.Blob.new([output], {"type": "text/plain"})
          url = window.URL.createObjectURL(blob)
          a = document.createElement("a")
          a.href = url
          a.download = f"progress_{window.Date.new().toISOString().split('T')[0]}.txt"
          document.body.appendChild(a)
          a.click()
          a.remove()

          # Cleanup
          window.setTimeout(create_proxy(lambda: window.URL.revokeObjectURL(url)), 1000)

          # Log summary
          worked_problems = len(self.problem_states)
          total_problems = len(self.problem_set)
          window.console.log(f"Export complete: {worked_problems}/{total_problems} problems worked on")

          window.console.log("Progress submission successful!")
          window.alert(f"Progress submitted successfully!\nWorked on: {worked_problems}/{total_problems} problems")

      except Exception as e:
          window.console.error(f"Submit progress failed: {e}")
          import traceback
          window.console.error(traceback.format_exc())
          window.alert(f"Submit failed: {e}")

  def export_telegram(self, event):
      # Simplified telegram export
      window.alert("Submit in Multiple Chunks feature coming soon")

  def clear_all(self, event):
      if not window.confirm("Clear ALL data? This cannot be undone."):
          return

      window.localStorage.clear()
      self.problem_set = []
      self.problem_states = {}
      self.current_problem_index = None
      self.current_problem_set_uuid = None

      # Reset UI
      container = document.querySelector("#solveProblemsContainer")
      if container:
          container.innerHTML = ""
      initial_panel = document.querySelector("#initialLoadPanel")
      if initial_panel:
          initial_panel.style.display = "block"
      self.update_problem_set_info("")

      window.alert("All data cleared")

  def _convert_to_native(self, obj):
      """Recursively convert all JsProxy objects to native Python types"""
      from pyodide.ffi import JsProxy

      # Handle None
      if obj is None:
          return None

      # Already native Python basic types - return as-is
      if isinstance(obj, (str, int, float, bool)):
          return obj

      # Handle JsProxy (JavaScript objects)
      if isinstance(obj, JsProxy):
          try:
              # First attempt: Use JavaScript's JSON.stringify
              js_json_str = window.JSON.stringify(obj)
              # Convert JS string to Python string and parse
              python_str = str(js_json_str)
              return json.loads(python_str)
          except Exception as e1:
              window.console.log(f"JSON.stringify failed: {e1}, trying to_py()")
              try:
                  # Second attempt: Use to_py()
                  converted = obj.to_py()
                  # Recursively convert the result
                  return self._convert_to_native(converted)
              except Exception as e2:
                  window.console.log(f"to_py() failed: {e2}, using str()")
                  # Last resort: convert to string
                  return str(obj)

      # Handle Python dict - recursively convert all values
      if isinstance(obj, dict):
          result = {}
          for key, value in obj.items():
              # Ensure key is string
              str_key = str(key)
              # Recursively convert value
              result[str_key] = self._convert_to_native(value)
          return result

      # Handle Python list - recursively convert all items
      if isinstance(obj, (list, tuple)):
          return [self._convert_to_native(item) for item in obj]

      # Unknown type - log warning and convert to string
      window.console.log(f"Warning: Unknown type {type(obj)}, converting to string")
      try:
          return str(obj)
      except:
          return None

  def save_to_storage(self):
      """Save current state to localStorage with thorough JsProxy conversion"""
      try:
          window.console.log("=== Starting save ===")

          # ‚úÖ Step 1: Save current problem's global history first
          if self.current_problem_index is not None:
              self.save_global_history_state(self.current_problem_index)

          # ‚úÖ Step 2: Convert current solve_state to serializable format
          if self.current_problem_index is not None and hasattr(self, 'solve_state'):
              window.console.log(f"Converting solve_state for problem {self.current_problem_index}")

              serializable_state = []
              for i, step in enumerate(self.solve_state):
                  window.console.log(f"Processing step {i}")

                  # Extract and convert each field individually
                  step_data = {
                      "step": self._convert_to_native(step.get("step", {})),
                      "attempts": int(step.get("attempts", 0)),
                      "attempt_history": self._convert_to_native(step.get("attempt_history", [])),
                      "correct": bool(step.get("correct", False)),
                      "finalize_attempts": int(step.get("finalize_attempts", 0)),
                      "finalize_history": self._convert_to_native(step.get("finalize_history", [])),
                      "structure_correct": bool(step.get("structure_correct", False)),
                      "finalized": bool(step.get("finalized", False)),
                      "step_start_time": float(step.get("step_start_time", 0))
                  }

                  # Double-check conversion
                  step_data = self._convert_to_native(step_data)
                  serializable_state.append(step_data)

              # Store the converted state
              self.problem_states[self.current_problem_index] = serializable_state
              window.console.log("‚úÖ solve_state converted successfully")

          # ‚úÖ Step 3: Convert entire problem_states dict
          window.console.log("Converting problem_states...")
          converted_problem_states = {}
          for key, value in self.problem_states.items():
              # Ensure key is integer
              int_key = int(key) if key is not None else 0
              # Convert value (which is a list of step states)
              converted_problem_states[int_key] = self._convert_to_native(value)

          window.console.log("‚úÖ problem_states converted successfully")

          # ‚úÖ Step 4: Convert global history states
          window.console.log("Converting global history states...")
          converted_global_histories = {}
          for key, value in self.problem_global_histories.items():
              int_key = int(key) if key is not None else 0
              converted_global_histories[int_key] = self._convert_to_native(value)
          window.console.log("‚úÖ global_histories converted successfully")

          # ‚úÖ Step 5: Build final data structure with all conversions
          window.console.log("Building final data structure...")
          data = {
              "problem_set_id": str(self.current_problem_set_uuid) if self.current_problem_set_uuid else None,
              "problem_set": self._convert_to_native(self.problem_set),
              "problem_states": converted_problem_states,
              "problem_global_histories": converted_global_histories,  # ‚úÖ NEW
              "current_problem_index": int(self.current_problem_index) if self.current_problem_index is not None else None
          }

          # ‚úÖ Step 6: Final conversion pass on entire data structure
          window.console.log("Final conversion pass...")
          data = self._convert_to_native(data)

          window.console.log("‚úÖ All data converted to native types")

          # ‚úÖ Step 7: Serialize to JSON
          window.console.log("Serializing to JSON...")
          json_str = json.dumps(data)
          window.console.log(f"‚úÖ JSON created, length: {len(json_str)}")

          # ‚úÖ Step 8: Compress
          window.console.log("Compressing...")
          import brotli
          compressed = brotli.compress(json_str.encode('utf-8'))
          window.console.log(f"‚úÖ Compressed, length: {len(compressed)}")

          # ‚úÖ Step 9: Encode to base64
          window.console.log("Encoding to base64...")
          b64_str = base64.b64encode(compressed).decode('utf-8')
          window.console.log(f"‚úÖ Base64 encoded, length: {len(b64_str)}")

          # ‚úÖ Step 10: Save to localStorage
          window.console.log("Saving to localStorage...")
          window.localStorage.setItem("problem_solver_data", b64_str)

          window.console.log("‚úÖ‚úÖ‚úÖ Save completed successfully!")
          self.show_indicator("üíæ Saved", "#10b981")

      except Exception as e:
          window.console.error(f"‚ùå Save failed: {e}")
          import traceback
          tb = traceback.format_exc()
          window.console.error(tb)
          self.show_indicator("‚ùå Save Failed", "#dc2626")

  def load_from_storage(self):
    try:
        stored = window.localStorage.getItem("problem_solver_data")
        if not stored: return

        import brotli, base64
        compressed = base64.b64decode(stored)
        json_str = brotli.decompress(compressed).decode('utf-8')
        data = json.loads(json_str)

        self.current_problem_set_uuid = data.get("problem_set_id")
        self.problem_set = data.get("problem_set", [])
        self.problem_states = {int(k): v for k, v in data.get("problem_states", {}).items()}
        self.current_problem_index = data.get("current_problem_index")

        # ‚úÖ NEW: Load global history states
        if "problem_global_histories" in data:
            self.problem_global_histories = {int(k): v for k, v in data.get("problem_global_histories", {}).items()}
            window.console.log(f"‚úÖ Loaded {len(self.problem_global_histories)} global history states")
        else:
            self.problem_global_histories = {}
            window.console.log("No global history states found in storage")

        if self.problem_set:
            self.update_problem_set_info(data.get("description", ""))
            self.render_problems()
    except:
        pass

  def show_indicator(self, text, color):
      indicator = document.querySelector("#storageIndicator")
      if indicator:
          indicator.textContent = text
          indicator.style.background = color
          indicator.classList.add("show")
          window.setTimeout(create_proxy(lambda: indicator.classList.remove("show")), 2000)
app = ProblemSolverApp()

# Import required libraries
import sympy as sp
import brotli

# Start the application
window.setTimeout(create_proxy(app.init), 700)

</script>

    <!-- Settings Management -->
    <script>
      document.addEventListener('DOMContentLoaded', () => {
        // Clear cache button
        const clearCacheBtn = document.getElementById('clearCacheBtn');
        if (clearCacheBtn) {
          clearCacheBtn.addEventListener('click', async () => {
            if (confirm('Clear browser cache? Pyodide will be re-downloaded on next load.')) {
              if ('caches' in window) {
                const names = await caches.keys();
                await Promise.all(names.map(name => caches.delete(name)));
                alert('‚úÖ Cache cleared! Refresh page.');
                location.reload();
              } else {
                alert('Cache API not available');
              }
            }
          });
        }
        
        // Clear storage button
        const clearStorageBtn = document.getElementById('clearStorageBtn');
        if (clearStorageBtn) {
          clearStorageBtn.addEventListener('click', () => {
            if (confirm('Clear ALL data including problems and progress?')) {
              window.localStorage.clear();
              alert('‚úÖ All data cleared!');
              location.reload();
            }
          });
        }
      });
    </script>
    <script>
// Image Viewer Modal Controller
document.addEventListener('DOMContentLoaded', function() {
  const modal = document.getElementById('imageViewerModal');
  const viewerImg = document.getElementById('viewerImage');
  const viewerContent = document.getElementById('imageViewerContent');
  const closeBtn = document.getElementById('closeImageViewer');
  const resetBtn = document.getElementById('resetZoom');
  const zoomInBtn = document.getElementById('zoomIn');
  const zoomOutBtn = document.getElementById('zoomOut');
  const zoomSlider = document.getElementById('zoomSlider');
  const zoomLevel = document.getElementById('zoomLevel');

  // Check if all elements exist
  if (!modal || !viewerImg || !viewerContent || !closeBtn || !resetBtn || 
      !zoomInBtn || !zoomOutBtn || !zoomSlider || !zoomLevel) {
    console.error('Image viewer elements not found');
    return;
  }

  let currentZoom = 100;
  let isDragging = false;
  let startX, startY, scrollLeft, scrollTop;
  
  // Touch pinch zoom variables
  let initialDistance = 0;
  let initialZoom = 100;

  // Open image viewer
  window.openImageViewer = function(imgSrc, imgAlt) {
    viewerImg.src = imgSrc;
    viewerImg.alt = imgAlt || '';
    modal.classList.add('active');
    resetZoom();
    document.body.style.overflow = 'hidden'; // Prevent background scroll
  };

  // Close image viewer
  function closeViewer() {
    modal.classList.remove('active');
    document.body.style.overflow = ''; // Restore scroll
    setTimeout(() => {
      viewerImg.src = '';
      resetZoom();
    }, 300);
  }

  // Reset zoom
  function resetZoom() {
    currentZoom = 100;
    updateZoom();
    viewerContent.scrollLeft = 0;
    viewerContent.scrollTop = 0;
  }

  // Update zoom
  function updateZoom() {
    viewerImg.style.transform = `scale(${currentZoom / 100})`;
    zoomSlider.value = currentZoom;
    zoomLevel.textContent = `${currentZoom}%`;
  }

  // Zoom in
  function zoomIn() {
    currentZoom = Math.min(400, currentZoom + 25);
    updateZoom();
  }

  // Zoom out
  function zoomOut() {
    currentZoom = Math.max(50, currentZoom - 25);
    updateZoom();
  }

  // Mouse drag to pan
  viewerContent.addEventListener('mousedown', (e) => {
    if (e.target === viewerImg) {
      isDragging = true;
      startX = e.pageX - viewerContent.offsetLeft;
      startY = e.pageY - viewerContent.offsetTop;
      scrollLeft = viewerContent.scrollLeft;
      scrollTop = viewerContent.scrollTop;
    }
  });

  viewerContent.addEventListener('mousemove', (e) => {
    if (!isDragging) return;
    e.preventDefault();
    const x = e.pageX - viewerContent.offsetLeft;
    const y = e.pageY - viewerContent.offsetTop;
    const walkX = (x - startX) * 1.5;
    const walkY = (y - startY) * 1.5;
    viewerContent.scrollLeft = scrollLeft - walkX;
    viewerContent.scrollTop = scrollTop - walkY;
  });

  viewerContent.addEventListener('mouseup', () => {
    isDragging = false;
  });

  viewerContent.addEventListener('mouseleave', () => {
    isDragging = false;
  });

  // Touch drag to pan
  let touchStartX, touchStartY;
  viewerContent.addEventListener('touchstart', (e) => {
    if (e.touches.length === 1) {
      touchStartX = e.touches[0].pageX;
      touchStartY = e.touches[0].pageY;
      scrollLeft = viewerContent.scrollLeft;
      scrollTop = viewerContent.scrollTop;
    } else if (e.touches.length === 2) {
      // Pinch zoom start
      const touch1 = e.touches[0];
      const touch2 = e.touches[1];
      initialDistance = Math.hypot(
        touch2.pageX - touch1.pageX,
        touch2.pageY - touch1.pageY
      );
      initialZoom = currentZoom;
    }
  }, { passive: false });

  viewerContent.addEventListener('touchmove', (e) => {
    if (e.touches.length === 1) {
      // Single touch - pan
      e.preventDefault();
      const touchX = e.touches[0].pageX;
      const touchY = e.touches[0].pageY;
      const walkX = (touchStartX - touchX) * 1.5;
      const walkY = (touchStartY - touchY) * 1.5;
      viewerContent.scrollLeft = scrollLeft + walkX;
      viewerContent.scrollTop = scrollTop + walkY;
    } else if (e.touches.length === 2) {
      // Pinch zoom
      e.preventDefault();
      const touch1 = e.touches[0];
      const touch2 = e.touches[1];
      const currentDistance = Math.hypot(
        touch2.pageX - touch1.pageX,
        touch2.pageY - touch1.pageY
      );
      const scale = currentDistance / initialDistance;
      currentZoom = Math.max(50, Math.min(400, initialZoom * scale));
      updateZoom();
    }
  }, { passive: false });

  // Mouse wheel zoom
  viewerContent.addEventListener('wheel', (e) => {
    if (e.ctrlKey || e.metaKey) {
      e.preventDefault();
      const delta = e.deltaY > 0 ? -25 : 25;
      currentZoom = Math.max(50, Math.min(400, currentZoom + delta));
      updateZoom();
    }
  }, { passive: false });

  // Event listeners for buttons
  closeBtn.addEventListener('click', closeViewer);
  resetBtn.addEventListener('click', resetZoom);
  zoomInBtn.addEventListener('click', zoomIn);
  zoomOutBtn.addEventListener('click', zoomOut);
  
  zoomSlider.addEventListener('input', (e) => {
    currentZoom = parseInt(e.target.value);
    updateZoom();
  });

  // Close on escape key
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && modal.classList.contains('active')) {
      closeViewer();
    }
  });

  // Close on background click
  modal.addEventListener('click', (e) => {
    if (e.target === modal || e.target === viewerContent) {
      closeViewer();
    }
  });

  // Prevent default touch behaviors on the modal
  modal.addEventListener('touchmove', (e) => {
    if (e.target === modal) {
      e.preventDefault();
    }
  }, { passive: false });

  // Add click handlers to all images
  document.addEventListener('click', (e) => {
    if (e.target.classList.contains('img-inline')) {
      const imgSrc = e.target.src;
      const imgAlt = e.target.alt;
      window.openImageViewer(imgSrc, imgAlt);
    }
  });

  console.log('‚úÖ Image viewer initialized successfully');
});
</script>
    <!-- Image Viewer Modal -->
<div id="imageViewerModal">
  <div class="image-viewer-header">
    <div class="image-viewer-controls">
      <button class="image-viewer-btn" id="closeImageViewer">‚úñ Close</button>
      <button class="image-viewer-btn" id="resetZoom">‚Üª Reset</button>
      <button class="image-viewer-btn" id="zoomOut">‚àí Zoom Out</button>
      <button class="image-viewer-btn" id="zoomIn">+ Zoom In</button>
    </div>
    <div class="zoom-slider-container">
      <span style="color: white; font-size: 14px;">Zoom:</span>
      <input type="range" class="zoom-slider" id="zoomSlider" min="50" max="400" value="100" step="10">
      <span class="zoom-level" id="zoomLevel">100%</span>
    </div>
  </div>
  <div class="image-viewer-content" id="imageViewerContent">
    <img class="image-viewer-img" id="viewerImage" src="" alt="">
  </div>
</div>
  </body>
</html>