<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
    <title>NoNet-NoSet-NoChat - Problem Solver</title>

    <!-- External Libraries - Loaded dynamically with caching -->
    <script>
      // Load external libraries with caching before anything else
      (async function() {
        const CACHE_VERSION = 'problem-solver-v3-full-offline';
        const EXTERNAL_LIBS = {
          mathquillCSS: 'https://cdnjs.cloudflare.com/ajax/libs/mathquill/0.10.1/mathquill.min.css',
          jquery: 'https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js',
          mathquillJS: 'https://cdnjs.cloudflare.com/ajax/libs/mathquill/0.10.1/mathquill.min.js'
        };

        // Helper to load cached resource
        async function loadCached(url, type) {
          try {
            const cache = await caches.open(CACHE_VERSION);
            let response = await cache.match(url);

            if (!response) {
              console.log(`üì• Downloading ${type}: ${url.split('/').pop()}`);
              response = await fetch(url);
              await cache.put(url, response.clone());
              console.log(`‚úÖ ${type} cached`);
            } else {
              console.log(`‚ö° ${type} from cache: ${url.split('/').pop()}`);
            }

            return await response.text();
          } catch (e) {
            console.warn(`${type} cache error, using CDN:`, e);
            const response = await fetch(url);
            return await response.text();
          }
        }

        try {
          // Load MathQuill CSS
          const cssText = await loadCached(EXTERNAL_LIBS.mathquillCSS, 'CSS');
          const style = document.createElement('style');
          style.textContent = cssText;
          document.head.appendChild(style);

          // Load jQuery
          const jqueryText = await loadCached(EXTERNAL_LIBS.jquery, 'jQuery');
          const jqueryScript = document.createElement('script');
          jqueryScript.textContent = jqueryText;
          document.head.appendChild(jqueryScript);
          await new Promise(resolve => setTimeout(resolve, 50));

          // Load MathQuill JS
          const mathquillText = await loadCached(EXTERNAL_LIBS.mathquillJS, 'MathQuill');
          const mathquillScript = document.createElement('script');
          mathquillScript.textContent = mathquillText;
          document.head.appendChild(mathquillScript);

          console.log('‚úÖ All external libraries loaded and cached!');
        } catch (e) {
          console.error('Error loading external libraries:', e);
        }
      })();
    </script>

    <!-- ‚ö° Cache-First Pyodide Loading -->
    <script>
      const CACHE_VERSION = 'problem-solver-v3-full-offline';
      const PYODIDE_URL = 'https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js';

      // External library URLs for caching
      const EXTERNAL_LIBS = {
        mathquillCSS: 'https://cdnjs.cloudflare.com/ajax/libs/mathquill/0.10.1/mathquill.min.css',
        jquery: 'https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js',
        mathquillJS: 'https://cdnjs.cloudflare.com/ajax/libs/mathquill/0.10.1/mathquill.min.js'
      };

      function updateStatus(msg) {
        const el = document.getElementById('loadingStatus');
        if (el) el.innerHTML = `<div>${msg}</div>`;
        console.log(msg);
      }

      async function getCachedScript(url) {
        try {
          const cache = await caches.open(CACHE_VERSION);
          let response = await cache.match(url);
          
          if (!response) {
            updateStatus('üì• Downloading Pyodide (first time)...');
            response = await fetch(url);
            await cache.put(url, response.clone());
            updateStatus('‚úÖ Cached for next time!');
          } else {
            updateStatus('‚ö° Loading from cache...');
          }
          
          return await response.text();
        } catch (e) {
          updateStatus('‚ö†Ô∏è Cache unavailable, using CDN...');
          const response = await fetch(url);
          return await response.text();
        }
      }

      // Load and cache external CSS
      async function getCachedCSS(url) {
        try {
          const cache = await caches.open(CACHE_VERSION);
          let response = await cache.match(url);

          if (!response) {
            console.log(`üì• Downloading CSS: ${url}`);
            response = await fetch(url);
            await cache.put(url, response.clone());
            console.log('‚úÖ CSS cached');
          } else {
            console.log('‚ö° CSS loaded from cache');
          }

          return await response.text();
        } catch (e) {
          console.warn('CSS cache error, using CDN:', e);
          const response = await fetch(url);
          return await response.text();
        }
      }

      // Load and cache external JavaScript
      async function loadCachedExternalScript(url) {
        try {
          const cache = await caches.open(CACHE_VERSION);
          let response = await cache.match(url);

          if (!response) {
            console.log(`üì• Downloading script: ${url}`);
            response = await fetch(url);
            await cache.put(url, response.clone());
            console.log('‚úÖ Script cached');
          } else {
            console.log('‚ö° Script loaded from cache');
          }

          const scriptText = await response.text();
          const script = document.createElement('script');
          script.textContent = scriptText;
          document.head.appendChild(script);

          // Wait for script to execute
          await new Promise(resolve => setTimeout(resolve, 50));
        } catch (e) {
          console.error('Script loading error:', e);
          // Fallback to direct load
          const script = document.createElement('script');
          script.src = url;
          document.head.appendChild(script);
          await new Promise((resolve, reject) => {
            script.onload = resolve;
            script.onerror = reject;
          });
        }
      }

      // Cache packages for offline use
      async function cachePackagesForOffline() {
        try {
          // Micropip automatically caches packages in IndexedDB
          // This function confirms packages are cached for offline use
          // The packages (lark, sympy, Brotli) are stored by micropip
          console.log('üì¶ Packages cached in IndexedDB by micropip');
          return true;
        } catch (e) {
          console.warn('Package caching check:', e);
          return false;
        }
      }

      // Initialize Pyodide with caching
      async function initPyodide() {
        updateStatus('üîß Loading Pyodide...');
        
        const scriptText = await getCachedScript(PYODIDE_URL);
        const script = document.createElement('script');
        script.textContent = scriptText;
        document.head.appendChild(script);
        
        await new Promise(resolve => setTimeout(resolve, 100));
        
        window.pyodide = await loadPyodide({
          indexURL: 'https://cdn.jsdelivr.net/pyodide/v0.24.1/full/'
        });
        
        updateStatus('‚úÖ Pyodide ready!');
        updateStatus('üì¶ Loading packages (sympy, lark, brotli)...');
        
                await window.pyodide.loadPackage(['micropip']);

        // Configure package caching for offline use
        await window.pyodide.runPythonAsync(`
import micropip

# Install packages with caching enabled (default in Pyodide)
# These will be stored in IndexedDB and work offline after first load
try:
    await micropip.install([
        'sympy',
        'lark',      # Lark parser - cached for offline parsing
        'Brotli'     # Compression library
    ], keep_going=True)
    print("‚úÖ Packages installed and cached for offline use")
except Exception as e:
    print(f"‚ö†Ô∏è Package installation issue: {e}")
    # Try to continue - packages might already be cached
        `);

        updateStatus('‚úÖ All packages loaded and cached!');

        // Pre-cache for next offline use
        await cachePackagesForOffline();
        await setupPyScriptCompat();
        await executePyScripts();
      }

      async function setupPyScriptCompat() {
        updateStatus('üîß Setting up pyscript compatibility...');
        
        await window.pyodide.runPythonAsync(`
import sys
from types import ModuleType
from pyodide.ffi import to_js, create_proxy

pyscript = ModuleType('pyscript')
import js as _js
pyscript.document = _js.document
pyscript.window = _js.window
sys.modules['pyscript'] = pyscript

print("‚úÖ pyscript module created and registered")
        `);
        
        updateStatus('‚úÖ pyscript compatibility ready!');
      }

      async function executePyScripts() {
        updateStatus('üêç Running Python code...');
        
        const pyScripts = document.querySelectorAll('script[type="py"]');
        console.log(`Found ${pyScripts.length} Python scripts`);
        
        for (let i = 0; i < pyScripts.length; i++) {
          const script = pyScripts[i];
          const code = script.textContent;
          
          updateStatus(`üêç Executing Python script ${i + 1}/${pyScripts.length}...`);
          
          try {
            console.log('Executing Python code...');
            await window.pyodide.runPythonAsync(code);
            console.log('‚úÖ Python code executed successfully');
          } catch (e) {
            console.error('Python execution error:', e);
            updateStatus('‚ùå Python error: ' + e.message);
            alert('Python Error:\n' + e.message);
            throw e;
          }
        }
        
        updateStatus('‚úÖ Python app ready!');
        
        const overlay = document.getElementById('loadingOverlay');
        if (overlay) {
          overlay.style.opacity = '0';
          setTimeout(() => overlay.remove(), 400);
        }
      }

      window.addEventListener('load', async () => {
        try {
          await initPyodide();
        } catch (e) {
          updateStatus('‚ùå Error: ' + e.message);
          console.error('Initialization error:', e);
        }
      });
    </script>

    <!-- MathJax Configuration -->
    <script>
     window.MathJax = {
  tex: {
    inlineMath: [['\\(', '\\)'], ['$', '$']],
    displayMath: [['\\[', '\\]'], ['$$', '$$']]
  },
  asciimath: {
    delimiters: [['`', '`']]
  },
  loader: {
    load: ['input/tex', 'input/asciimath', 'output/chtml']
  },
  chtml: { 
    scale: 1.2 
  },
  startup: { 
    typeset: false,
    ready: () => {
      console.log('‚úÖ MathJax ready (LaTeX + AsciiMath)');
      MathJax.startup.defaultReady();
    }
  }
};
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script>

    <style>
/* ========================================
   MATHQUILL FIELD STYLING - PROMINENT BORDERS
   ======================================== */

/* Base MathQuill field styling */
.math-input {
  min-height: 60px;
  border: 2px solid #cbd5e1 !important;  /* Visible gray border */
  border-radius: 8px;
  padding: 12px !important;
  background: #ffffff !important;
  transition: all 0.2s ease;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

/* MathQuill field when focused */
.math-input:focus-within {
  border-color: #3b82f6 !important;  /* Blue when focused */
  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
  background: #ffffff !important;
}

/* MathQuill field on hover */
.math-input:hover {
  border-color: #94a3b8 !important;  /* Darker gray on hover */
}

/* The actual MathQuill span inside */
.math-input .mq-editable-field {
  border: none !important;
  min-height: 40px;
}

/* Make cursor more visible */
.math-input .mq-cursor {
  border-left: 2px solid #3b82f6 !important;
  animation: blink 1s step-end infinite;
}

@keyframes blink {
  0%, 50% { opacity: 1; }
  51%, 100% { opacity: 0; }
}

/* ========================================
   SPECIFIC FREESTYLE FIELD STYLING
   ======================================== */

/* Problem input field */
#freestyleProblemInput {
  min-height: 60px;
  border: 2px solid #cbd5e1 !important;
  border-radius: 8px;
  padding: 12px !important;
  background: #f8fafc !important;  /* Light gray background */
}

#freestyleProblemInput:focus-within {
  border-color: #8b5cf6 !important;  /* Purple when focused */
  box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.1);
  background: #ffffff !important;
}

/* Answer input field */
#freestyleAnswerInput {
  min-height: 60px;
  border: 2px solid #cbd5e1 !important;
  border-radius: 8px;
  padding: 12px !important;
  background: #fffbeb !important;  /* Light yellow background */
}

#freestyleAnswerInput:focus-within {
  border-color: #10b981 !important;  /* Green when focused */
  box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.1);
  background: #ffffff !important;
}

/* Mobile optimizations */
@media (max-width: 768px) {
  .math-input {
    min-height: 70px;
    padding: 14px !important;
    font-size: 18px;
  }
  
  #freestyleProblemInput,
  #freestyleAnswerInput {
    min-height: 70px;
    padding: 14px !important;
  }
}
/* Global History Styles */
.attempt-entry-wrapper {
  overflow-x: auto;
  overflow-y: hidden;
  max-width: 100%;
  -webkit-overflow-scrolling: touch;
  margin-bottom: 10px;
  padding: 10px;
  border-radius: 8px;
}

.attempt-entry-wrapper::-webkit-scrollbar {
  height: 6px;
  background: #f1f5f9;
  border-radius: 3px;
}

.attempt-entry-wrapper::-webkit-scrollbar-thumb {
  background: #cbd5e1;
  border-radius: 3px;
}

.attempt-entry-wrapper::-webkit-scrollbar-thumb:hover {
  background: #94a3b8;
}

@media (max-width: 768px) {
  .attempt-entry-wrapper::-webkit-scrollbar {
    height: 8px;
  }
}
    /* Base Styles */
    * { 
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body { 
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial; 
      margin: 0; 
      padding: 0;
      background: #f3f6fb; 
      color: #0b1020; 
      overflow-x: hidden;
    }

    #loadingOverlay { 
      position: fixed; 
      top: 0; 
      left: 0; 
      right: 0; 
      bottom: 0; 
      background: rgba(15,23,42,0.95); 
      z-index: 9999; 
      display: flex; 
      flex-direction: column; 
      align-items: center; 
      justify-content: center; 
      color: #fff; 
    }

    .spinner { 
      width: 60px; 
      height: 60px; 
      border: 4px solid rgba(59,130,246,0.3); 
      border-top-color: #3b82f6; 
      border-radius: 50%; 
      animation: spin 1s linear infinite; 
      margin-bottom: 20px; 
    }

    @keyframes spin { 
      to { transform: rotate(360deg); } 
    }

    .loading-text {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 12px;
    }

    #loadingStatus {
      font-size: 14px;
      color: #94a3b8;
      text-align: center;
      max-width: 80%;
    }

    .panel { 
      background: #fff; 
      padding: 16px;
      border-radius: 8px; 
      box-shadow: 0 6px 20px rgba(11,20,40,0.06); 
      margin-bottom: 12px;
    }

    .btn { 
      padding: 12px 20px; 
      border-radius: 8px; 
      border: none; 
      cursor: pointer; 
      background: #0b6efd; 
      color: #fff; 
      font-size: 16px; 
      font-weight: 500; 
      transition: all 0.2s ease;
      width: 100%;
      margin-bottom: 8px;
    }

    .btn:hover { 
      transform: translateY(-1px); 
      box-shadow: 0 4px 12px rgba(11,110,253,0.3); 
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .btn.ghost { 
      background: transparent; 
      color: #0b6efd; 
      border: 1px solid #dbe9ff; 
    }

    /* Layout */
    .app-container {
      display: flex;
      min-height: 100vh;
    }

    /* Sidebar */
    .sidebar {
      width: 320px;
      background: #fff;
      box-shadow: 4px 0 12px rgba(0,0,0,0.1);
      padding: 16px;
      padding-top: 85px;
      padding-bottom: 60px;
      overflow-y: auto;
      flex-shrink: 0;
      position: fixed;
      top: 0;
      left: 0;
      height: 100vh;
      z-index: 100;
      display: flex;
      flex-direction: column;
    }

    .nav-menu {
      margin-bottom: 20px;
    }

    .nav-item {
      display: flex;
      align-items: center;
      padding: 12px 16px;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      margin-bottom: 4px;
      font-weight: 500;
    }

    .nav-item:hover {
      background: #f0f4ff;
    }

    .nav-item.active {
      background: #dbeafe;
      color: #1d4ed8;
    }

    .nav-icon {
      margin-right: 12px;
      font-size: 18px;
    }

    /* Main Content */
    .main-content {
      flex: 1;
      padding: 16px;
      max-width: 100%;
      margin-left: 320px;
    }

    .page {
      display: none;
    }

    .page.active {
      display: block;
    }

    /* Accordion */
    .accordion-problem { 
      border: 2px solid #e2e8f0; 
      border-radius: 12px; 
      margin-bottom: 16px; 
      background: #ffffff; 
      box-shadow: 0 4px 12px rgba(0,0,0,0.08); 
      overflow: hidden; 
    }

    .accordion-problem.open { 
      border-color: #3b82f6; 
    }

    .accordion-problem.finished { 
      border-color: #10b981; 
      background: #f0fdf4; 
    }

    .accordion-header { 
      padding: 16px; 
      font-weight: 700; 
      cursor: pointer; 
      display: flex; 
      justify-content: space-between; 
      align-items: center; 
      background: #f0f4ff; 
      transition: background 0.2s ease;
      font-size: 16px;
      min-height: 60px;
    }

    .accordion-header:hover { 
      background: #dbeafe; 
    }

    .accordion-body { 
      max-height: 0; 
      overflow: hidden; 
      transition: max-height 0.3s ease-in-out; 
      padding: 0 16px; 
    }

    .accordion-problem.open .accordion-body { 
      max-height: 10000px; 
      padding: 16px; 
    }

    .progress-summary { 
      font-size: 14px; 
      color: #6b7280; 
      font-weight: 600; 
    }

    /* Step styling */
    .step {
      padding: 16px;
      font-size: 16px;
      display: none;
    }

    .step.active {
      display: block;
    }

    .step-description {
      background: #f0fdf4;
      padding: 16px;
      border-radius: 8px;
      margin-bottom: 12px;
      font-size: 16px;
      line-height: 1.6;
      overflow-x: auto;
    }

    .step-feedback {
      font-size: 15px;
      padding: 12px;
      border-radius: 6px;
      margin-top: 12px;
      font-weight: 600;
      overflow-x: auto;
    }

    /* Flashing animation for incorrect answers */
    @keyframes flashIncorrect {
      0%, 100% {
        opacity: 1;
        transform: scale(1);
      }
      50% {
        opacity: 0.7;
        transform: scale(1.02);
      }
    }

    .flash-incorrect {
      animation: flashIncorrect 0.5s ease-in-out 6;
      box-shadow: 0 0 20px rgba(239, 68, 68, 0.6) !important;
    }

    /* Multiple Choice Styles */
    .mc-option {
      display: block;
      padding: 12px 16px;
      margin-bottom: 8px;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      background: #fff;
    }

    .mc-option:hover {
      border-color: #3b82f6;
      background: #f0f9ff;
    }

    .mc-option input[type="radio"],
    .mc-option input[type="checkbox"] {
      margin-right: 12px;
      width: 18px;
      height: 18px;
      cursor: pointer;
    }

    .mc-option.selected {
      border-color: #3b82f6;
      background: #dbeafe;
    }

    .mc-option.correct {
      border-color: #10b981;
      background: #d1fae5;
    }

    .mc-option.incorrect {
      border-color: #ef4444;
      background: #fee2e2;
    }

    /* True/False Buttons */
    .tf-buttons {
      display: flex;
      gap: 12px;
      margin: 16px 0;
    }

    .tf-btn {
      flex: 1;
      padding: 16px;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      cursor: pointer;
      font-size: 18px;
      font-weight: 600;
      text-align: center;
      transition: all 0.2s ease;
      background: #fff;
    }

    .tf-btn:hover {
      border-color: #3b82f6;
      background: #f0f9ff;
    }

    .tf-btn.selected {
      border-color: #3b82f6;
      background: #dbeafe;
    }

    .tf-btn.correct {
      border-color: #10b981;
      background: #d1fae5;
    }

    .tf-btn.incorrect {
      border-color: #ef4444;
      background: #fee2e2;
    }

    /* Fill-in-the-Blank */
    .fill-blank-input {
      width: 100%;
      padding: 12px;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      font-size: 16px;
      margin-bottom: 12px;
    }

    .fill-blank-input:focus {
      outline: none;
      border-color: #3b82f6;
    }

    /* Storage Indicator */
    .storage-indicator { 
      position: fixed; 
      bottom: 16px; 
      right: 16px; 
      padding: 10px 14px; 
      background: #10b981; 
      color: #fff; 
      border-radius: 8px; 
      font-size: 13px; 
      opacity: 0; 
      transition: opacity 0.3s; 
      pointer-events: none; 
      z-index: 1000;
      font-weight: 600;
    }

    .storage-indicator.show { 
      opacity: 1; 
    }

    /* Mobile Responsive */
    @media (max-width: 768px) {
      .app-container {
        flex-direction: column;
      }
      
      .sidebar {
        position: fixed;
        left: -100%;
        top: 0;
        width: 85%;
        max-width: 400px;
        height: 100vh;
        z-index: 1000;
        transition: left 0.3s ease;
      }
      
      .sidebar.open {
        left: 0;
      }
      
      .main-content {
        margin-left: 0 !important;
        padding: 60px 8px 8px 8px;
        width: 100% !important;
      }
      
      .menu-btn {
        position: fixed;
        top: 8px;
        left: 8px;
        z-index: 1001;
        width: 50px;
        height: 50px;
        background: #0b6efd;
        color: #fff;
        border: none;
        border-radius: 12px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 26px;
        box-shadow: 0 4px 16px rgba(11,110,253,0.5);
        font-weight: bold;
      }
      
      .sidebar-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.6);
        z-index: 999;
        display: none;
      }
      
      .sidebar-overlay.show {
        display: block;
      }
    }

    @media (min-width: 769px) {
      .menu-btn,
      .sidebar-overlay {
        display: none !important;
      }
    }
/* Keyboard Accordion Styles */
.keyboard-accordion {
  border: 2px solid #e2e8f0;
  border-radius: 8px;
  overflow: hidden;
  background: #fff;
}

.keyboard-accordion-header {
  background: #f0f4ff;
  padding: 12px 14px;
  cursor: pointer;
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-weight: 500;
  font-size: 15px;
  user-select: none;
  transition: background 0.2s;
}

.keyboard-accordion-header:hover {
  background: #dbeafe;
}

.keyboard-accordion.open .keyboard-accordion-header {
  background: #dbeafe;
  border-bottom: 2px solid #e2e8f0;
}

.keyboard-accordion-body {
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.3s ease;
  background: #fafbfc;
}

.keyboard-accordion.open .keyboard-accordion-body {
  max-height: 500px;
}

.keyboard-accordion-icon {
  font-size: 14px;
  color: #6b7280;
  transition: transform 0.2s;
}

.keyboard-accordion.open .keyboard-accordion-icon {
  transform: rotate(180deg);
}

/* Input Button Styles */
.input-btn {
  padding: 10px;
  border: 1px solid #d1d5db;
  border-radius: 6px;
  background: #fff;
  font-size: 16px;
  cursor: pointer;
  transition: all 0.15s;
  font-family: system-ui, -apple-system, sans-serif;
}

/* SVG button content styling */
.input-btn svg {
  display: block;
  margin: auto;
  pointer-events: none; /* Prevent SVG from intercepting clicks */
}

/* Ensure SVG buttons maintain proper sizing */
.input-btn.navigation svg,
.input-btn.special svg {
  width: 20px;
  height: 20px;
}

/* Math variable styling - make variables prominent */
.math-var {
  font-family: 'Times New Roman', 'STIX Two Math', 'Latin Modern Math', serif;
  font-style: italic;
  font-size: 18px;
  font-weight: 500;
  color: #1e40af;
  pointer-events: none;
}

.input-btn:hover {
  background: #f3f4f6;
  transform: scale(1.05);
}

.input-btn:active {
  transform: scale(0.95);
  background: #e5e7eb;
}

.input-btn.digit {
  background: #eff6ff;
  border-color: #bfdbfe;
}

.input-btn.operator {
  background: #fef3c7;
  border-color: #fde68a;
}

.input-btn.special {
  background: #e0e7ff;
  border-color: #c7d2fe;
}

.input-btn.symbol {
  background: #ddd6fe;
  border-color: #c4b5fd;
}

.input-btn.delete {
  background: #fee2e2;
  border-color: #fecaca;
  color: #991b1b;
  font-weight: 600;
}

.input-btn.navigation {
  background: #f3f4f6;
  border-color: #d1d5db;
}

/* Mobile Optimizations */
@media (max-width: 768px) {
  .input-btn {
    padding: 12px 8px;
    font-size: 14px;
  }
  
  #freestyleProblemDisplay {
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
  }
}

/* Credit notification animation */
@keyframes slideInRight {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

    @keyframes slideIn {
      from {
        transform: translateY(-10px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }

    @keyframes slideInRight {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @keyframes slideOutRight {
      from {
        transform: translateX(0);
        opacity: 1;
      }
      to {
        transform: translateX(100%);
        opacity: 0;
      }
    }

    /* Step number counting animation */
    @keyframes countUp {
      0% {
        transform: scale(0.8);
        opacity: 0;
      }
      50% {
        transform: scale(1.2);
      }
      100% {
        transform: scale(1);
        opacity: 1;
      }
    }

    .step-number-animate {
      animation: countUp 0.4s ease-out;
      display: inline-block;
    }

    /* Hide problem area with fade out */
    @keyframes fadeOut {
      from {
        opacity: 1;
        max-height: 2000px;
      }
      to {
        opacity: 0;
        max-height: 0;
        overflow: hidden;
      }
    }

    .problem-area-hidden {
      animation: fadeOut 0.5s ease-out forwards;
      pointer-events: none;
    }

    /* Tab styles */
    .load-tabs {
      display: flex;
      gap: 8px;
      margin-bottom: 20px;
      border-bottom: 2px solid #e5e7eb;
      padding-bottom: 0;
    }

    .load-tab {
      padding: 12px 20px;
      background: transparent;
      border: none;
      border-bottom: 3px solid transparent;
      color: #6b7280;
      font-size: 15px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
      bottom: -2px;
    }

    .load-tab:hover {
      color: #374151;
      background: #f9fafb;
    }

    .load-tab.active {
      color: #2563eb;
      border-bottom-color: #2563eb;
      background: #eff6ff;
    }

    .load-tab-content {
      display: none;
      animation: fadeInTab 0.3s ease-in;
    }

    .load-tab-content.active {
      display: block;
    }

    @keyframes fadeInTab {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Button loading states */
    .btn.loading {
      position: relative;
      color: transparent !important;
      pointer-events: none;
    }

    .btn.loading::after {
      content: "";
      position: absolute;
      width: 16px;
      height: 16px;
      top: 50%;
      left: 50%;
      margin-left: -8px;
      margin-top: -8px;
      border: 2px solid #ffffff;
      border-radius: 50%;
      border-top-color: transparent;
      animation: spin 0.6s linear infinite;
    }

    /* Slot machine animation for step numbers */
    .step-number-slot {
      display: inline-block;
      position: relative;
      overflow: hidden;
      vertical-align: middle;
      height: 1.2em;
      min-width: 1.5em;
      text-align: center;
    }

    .step-number-slot-inner {
      display: inline-block;
      transition: transform 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }

    @keyframes slotRoll {
      0% { transform: translateY(0); }
      20% { transform: translateY(-100%); }
      40% { transform: translateY(-200%); }
      60% { transform: translateY(-300%); }
      80% { transform: translateY(-400%); }
      100% { transform: translateY(-500%); }
    }

    .step-number-rolling {
      animation: slotRoll 0.6s ease-in-out;
    }

    /* ============================================ */
    /* PROMINENT STEP TRANSITION ANIMATIONS */
    /* ============================================ */

    /* Step transition banner */
    .step-transition-banner {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0);
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 40px 60px;
      border-radius: 20px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.4);
      z-index: 10000;
      font-size: 32px;
      font-weight: bold;
      text-align: center;
      opacity: 0;
      pointer-events: none;
    }

    .step-transition-banner.show {
      animation: bannerPulse 1.5s ease-out forwards;
    }

    @keyframes bannerPulse {
      0% {
        transform: translate(-50%, -50%) scale(0);
        opacity: 0;
      }
      15% {
        transform: translate(-50%, -50%) scale(1.1);
        opacity: 1;
      }
      30% {
        transform: translate(-50%, -50%) scale(0.95);
        opacity: 1;
      }
      70% {
        transform: translate(-50%, -50%) scale(1);
        opacity: 1;
      }
      100% {
        transform: translate(-50%, -50%) scale(0.8);
        opacity: 0;
      }
    }

    .step-transition-banner .banner-icon {
      font-size: 48px;
      margin-bottom: 10px;
      animation: iconSpin 1.5s ease-out;
    }

    @keyframes iconSpin {
      0% {
        transform: rotate(0deg) scale(0);
      }
      50% {
        transform: rotate(180deg) scale(1.2);
      }
      100% {
        transform: rotate(360deg) scale(1);
      }
    }

    /* Step slide out animation */
    @keyframes stepSlideOut {
      0% {
        transform: translateX(0) scale(1);
        opacity: 1;
      }
      100% {
        transform: translateX(-100px) scale(0.95);
        opacity: 0;
      }
    }

    .step.sliding-out {
      animation: stepSlideOut 0.5s ease-in forwards;
    }

    /* Step slide in animation */
    @keyframes stepSlideIn {
      0% {
        transform: translateX(100px) scale(0.95);
        opacity: 0;
      }
      100% {
        transform: translateX(0) scale(1);
        opacity: 1;
      }
    }

    .step.sliding-in {
      animation: stepSlideIn 0.6s ease-out forwards;
    }

    /* Background overlay during transition */
    .transition-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.3);
      z-index: 9999;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }

    .transition-overlay.active {
      opacity: 1;
    }

    /* Progress indicator pulse */
    @keyframes progressPulse {
      0%, 100% {
        box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.7);
      }
      50% {
        box-shadow: 0 0 0 15px rgba(16, 185, 129, 0);
      }
    }

    .step.active {
      display: block;
      animation: progressPulse 2s ease-in-out;
    }

    </style>
  
  <!-- NoNet-NoSet-NoChat Branding Styles -->
  <style id="nonet-step-branding">
    .nonet-step-header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 12px 20px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-bottom: 3px solid #5568d3;
      transition: transform 0.3s ease-in-out;
    }

    .nonet-step-header.hidden {
      transform: translateY(-100%);
    }

    .nonet-step-logo {
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 24px;
      font-weight: bold;
      text-decoration: none;
      color: white;
    }

    

    .nonet-step-tagline {
      font-size: 11px;
      opacity: 0.9;
      font-weight: normal;
      margin-top: 2px;
      letter-spacing: 0.5px;
    }

    .nonet-step-badge {
      background: rgba(255,255,255,0.2);
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 600;
      border: 1px solid rgba(255,255,255,0.3);
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .nonet-step-badge::before {
      content: "‚ö°";
      font-size: 14px;
    }

    @media (max-width: 768px) {
      .nonet-step-header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 12px 20px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-bottom: 3px solid #5568d3;
      transition: transform 0.3s ease-in-out;
    }

    .nonet-step-header.hidden {
      transform: translateY(-100%);
    }
      .nonet-step-logo {
        font-size: 20px;
        padding-left: 60px;
      }
      .nonet-step-badge {
        font-size: 10px;
        padding: 4px 8px;
      }
    }
  </style>

</head>
  <body style="padding-top: 70px;">
  <!-- NoNet-NoSet-NoChat Branding Header -->
  <div class="nonet-step-header">
    <div class="nonet-step-logo">
      <div>
        <div style="font-size: 20px; font-weight: bold;">NoNet-NoSet-NoChat</div>
        <div class="nonet-step-tagline">Learn Properly, Understand Fully</div>
      </div>
    </div>
    <div class="nonet-step-badge">
      Offline Ready
    </div>
  </div>


    <!-- Loading Overlay -->
    <div id="loadingOverlay">
      <div class="spinner"></div>
      <div class="loading-text">‚ö° Loading Problem Solver...</div>
      <div id="loadingStatus">
        <div>‚è≥ Starting up...</div>
      </div>
    </div>

    <!-- Step Transition Banner -->
    <div id="stepTransitionBanner" class="step-transition-banner">
      <div class="banner-icon">üéØ</div>
      <div class="banner-text">Moving to Step <span id="bannerStepNumber">2</span></div>
    </div>

    <!-- Transition Overlay -->
    <div id="transitionOverlay" class="transition-overlay"></div>

    <!-- Mobile Menu Button -->
    <button class="menu-btn" id="menuBtn">‚ò∞</button>
    <div class="sidebar-overlay" id="sidebarOverlay"></div>

    <!-- Main App Container -->
    <div class="app-container">
      <!-- Sidebar -->
      <aside class="sidebar" id="sidebar">
        <div class="sidebar-header">
          <h3>üßÆ Problem Solver</h3>
        </div>

        <!-- Problem Set Info -->
        <div id="problemSetInfo" class="panel" style="display: none">
          <div style="font-size: 16px; font-weight: 700; margin-bottom: 8px">Problem Set</div>
          <div id="currentProblemSetDescription" style="font-size: 14px; color: #64748b; margin-bottom: 8px">
            No problem set loaded
          </div>
          <div id="currentProblemSetUuid" style="font-family: monospace; font-size: 12px; color: #0369a1; background: #f0f9ff; padding: 8px; border-radius: 6px;">
            No UUID
          </div>
        </div>

        <!-- Navigation -->
        <nav class="nav-menu">
          <div class="nav-item active" data-page="problems">
            <span class="nav-icon">üßÆ</span>
            <span>Work on Problems</span>
          </div>
          <div class="nav-item" data-page="freestyle">
            <span class="nav-icon">‚úèÔ∏è</span>
            <span class="nav-text">Freestyle Practice</span>
          </div>
          <div class="nav-item" data-page="load">
            <span class="nav-icon">üìÇ</span>
            <span>Load Problem Set</span>
          </div>
          <div class="nav-item" data-page="export">
            <span class="nav-icon">üì§</span>
            <span>Submit Progress</span>
          </div>
          <div class="nav-item" data-page="reset" style="border-top: 1px solid #e5e7eb; margin-top: 8px; padding-top: 8px;">
            <span class="nav-icon">üîÑ</span>
            <span>Reset Answers</span>
          </div>
        </nav>
          <!-- Attribution at Bottom of Sidebar -->
    <div style="padding: 15px; border-top: 1px solid #e0e0e0; margin-top: auto; background: #f9f9f9; text-align: center; font-size: 12px; position: absolute; bottom: 0; left: 0; right: 0; width: 100%;">
      <a href="attributions.html" target="_blank" style="color: #667eea; text-decoration: none; font-weight: 500;">
        üìú Open Source Attributions
      </a>
    </div>
  </aside>

      <!-- Main Content -->
      <main class="main-content">
        <!-- Problems Page -->
        <div id="problemsPage" class="page active">
          <div id="initialLoadPanel" class="panel">
            <h3>üìÇ Load Problem Set</h3>
            <p>No problems loaded. Use the sidebar to load a problem set.</p>
          </div>
          <div id="solveProblemsContainer"></div>
        </div>
        <!-- Freestyle Practice Page -->
        <div id="freestylePage" class="page">
          <div class="panel">
            <h3>‚úèÔ∏è Freestyle Practice</h3>
            <p style="color: #64748b; margin-bottom: 16px">
              Create and solve your own problem. Enter a mathematical expression, then try to solve it!
              <strong>Limit problems will be automatically validated.</strong>
            </p>

            <!-- Credit System Display -->
            <div id="creditDisplay" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 16px; border-radius: 12px; margin-bottom: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                <div style="font-size: 14px; font-weight: 600; opacity: 0.9;">üíé Give-Up Credits</div>
                <button id="showCreditHistory" class="btn ghost" style="padding: 4px 12px; font-size: 12px; background: rgba(255,255,255,0.2); color: white; border: 1px solid rgba(255,255,255,0.3);">
                  View History
                </button>
              </div>
              <div style="display: flex; align-items: baseline; gap: 12px;">
                <div style="font-size: 32px; font-weight: 700;" id="creditBalance">0</div>
                <div style="font-size: 14px; opacity: 0.8;">
                  <span id="creditEarned">0</span> earned ‚Ä¢ 
                  <span id="creditSpent">0</span> spent
                </div>
              </div>
              <div style="font-size: 12px; margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.2); opacity: 0.9;">
                ‚ÑπÔ∏è Earn credits by solving problems. Use them to reveal solutions when stuck!
              </div>
            </div>

            <!-- Credit History Modal (Hidden by default) -->
            <div id="creditHistoryModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 10000; align-items: center; justify-content: center;">
              <div style="background: white; border-radius: 12px; max-width: 600px; max-height: 80vh; overflow: hidden; display: flex; flex-direction: column; margin: 20px;">
                <div style="padding: 20px; border-bottom: 2px solid #e5e7eb;">
                  <div style="display: flex; justify-content: space-between; align-items: center;">
                    <h3 style="margin: 0;">üìä Credit History</h3>
                    <button id="closeCreditHistory" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #64748b;">√ó</button>
                  </div>
                </div>
                <div id="creditHistoryContent" style="padding: 20px; overflow-y: auto; flex: 1;">
                  <!-- History will be populated here -->
                </div>
              </div>
            </div>

            <div style="margin-bottom: 20px">
              <label>üìù Problem Expression</label>
              <div style="font-size: 13px; color: #64748b; margin-bottom: 8px;">
                Create any math problem: expressions (2x+6), equations (x=3), matrices ([[1,2],[3,4]]), etc.
              </div>
              <div
                style="
                  overflow-x: auto;
                  overflow-y: hidden;
                  max-width: 100%;
                  -webkit-overflow-scrolling: touch;
                  border: 2px solid #e6eef8;
                  border-radius: 8px;
                  padding: 10px;
                  background: #fff;
                ">
                <div
                  id="freestyleProblemInput"
                  class="math-input"
                  style="min-height: 60px; border: none; padding: 0"></div>
              </div>
              <button id="setFreestyleProblem" class="btn" style="margin-top: 10px">Set Problem</button>
            </div>

            <div id="freestyleSolveArea" style="display: none">
              <hr style="margin: 20px 0; border: none; border-top: 2px solid #e5e7eb" />

              <div style="background: #f0fdf4; padding: 16px; border-radius: 8px; margin-bottom: 16px">
                <div style="font-weight: 700; margin-bottom: 8px">Problem to Solve:</div>
                <div id="freestyleProblemDisplay" style="font-size: 20px"></div>
              </div>

              <div style="margin-bottom: 20px">
                <label>üéØ Your Solution</label>
                <div
                  style="
                    overflow-x: auto;
                    overflow-y: hidden;
                    max-width: 100%;
                    -webkit-overflow-scrolling: touch;
                    border: 2px solid #e6eef8;
                    border-radius: 8px;
                    padding: 10px;
                    background: #fff;
                  ">
                  <div
                    id="freestyleAnswerInput"
                    class="math-input"
                    style="min-height: 60px; border: none; padding: 0"></div>
                </div>

                <div style="display: flex; flex-direction: column; gap: 8px; margin-top: 12px">
                  <button id="freestyleSubmit" class="btn">Submit Attempt</button>
                  <button id="getStructureString" class="btn ghost" style="background: #3b82f6; color: #fff" title="Get structure string for Moodle submission">
                    üìã Get Structure String
                  </button>
                  <button id="freestyleGiveUp" class="btn ghost" style="background: #f59e0b; color: #fff">
                    Give Up (Show Solution)
                  </button>
                  <button id="freestyleFinalize" class="btn ghost" disabled>Check Simplest Form</button>
                  <button id="freestyleReset" class="btn ghost" style="background: #dc2626; color: #fff">
                    Reset Problem
                  </button>
                </div>

                <div id="freestyleFeedback" style="margin-top: 16px; min-height: 20px"></div>
                <div id="freestyleHistory" style="margin-top: 16px; min-height: 20px"></div>
              </div>
            </div>

            <!-- Comprehensive Keyboard for Freestyle -->
            <div id="freestyleKeyboard" style="margin-top: 16px">
              <div style="font-weight: 600; margin-bottom: 8px; font-size: 15px">‚å®Ô∏è Input Keyboard:</div>

              <!-- Numbers & Basic Accordion -->
              <div class="keyboard-accordion" style="margin-bottom: 6px">
                <div class="keyboard-accordion-header" data-target="numbersBody">
                  <span>üî¢ Numbers & Basic</span>
                  <span class="keyboard-accordion-icon">‚ñº</span>
                </div>
                <div id="numbersBody" class="keyboard-accordion-body">
                  <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 3px; padding: 8px">
                    <button class="input-btn digit" data-action="7">7</button>
                    <button class="input-btn digit" data-action="8">8</button>
                    <button class="input-btn digit" data-action="9">9</button>
                    <button class="input-btn special" data-action="^" id="freestylePower"></button>
                    <button class="input-btn special" data-action="_" id="freestyleSubscript"></button>
                    <button class="input-btn digit" data-action="4">4</button>
                    <button class="input-btn digit" data-action="5">5</button>
                    <button class="input-btn digit" data-action="6">6</button>
                    <button class="input-btn operator" data-action="/">√∑</button>
                    <button class="input-btn operator" data-action="\\times">√ó</button>
                    <button class="input-btn digit" data-action="1">1</button>
                    <button class="input-btn digit" data-action="2">2</button>
                    <button class="input-btn digit" data-action="3">3</button>
                    <button class="input-btn operator" data-action="-">‚àí</button>
                    <button class="input-btn operator" data-action="+">+</button>
                    <button class="input-btn special" data-action="(">(</button>
                    <button class="input-btn digit" data-action="0">0</button>
                    <button class="input-btn special" data-action=")">)</button>
                    <button class="input-btn special" data-action=".">.</button>
                    <button class="input-btn special" data-action="=">=</button>
                    <button class="input-btn special" data-action="[">[</button>
                    <button class="input-btn special" data-action=",">,</button>
                    <button class="input-btn special" data-action="]">]</button>
                    <button class="input-btn symbol" data-action="x"><span class="math-var">x</span></button>
                    <button class="input-btn navigation keyboard-toggle" data-action="TOGGLE_KEYBOARD" id="freestyleToggleKeyboard" title="Toggle Soft Keyboard"></button>
                    <button class="input-btn navigation" data-action="SELECT_LEFT" id="freestyleSelectLeft"></button>
                    <button class="input-btn navigation" data-action="MOVE_LEFT" id="freestyleMoveLeft"></button>
                    <button class="input-btn navigation" data-action="MOVE_RIGHT" id="freestyleMoveRight"></button>
                    <button class="input-btn delete" data-action="CLEAR">Clear</button>
                    <button class="input-btn delete" data-action="BACKSPACE">‚å´</button>
                  </div>
                </div>
              </div>

              <!-- Algebra Accordion -->
              <div class="keyboard-accordion" style="margin-bottom: 6px">
                <div class="keyboard-accordion-header" data-target="algebraBody">
                  <span>üî§ Algebra</span>
                  <span class="keyboard-accordion-icon">‚ñº</span>
                </div>
                <div id="algebraBody" class="keyboard-accordion-body">
                  <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 3px; padding: 8px">
                    <button class="input-btn symbol" data-action="x"><span class="math-var">x</span></button>
                    <button class="input-btn symbol" data-action="y"><span class="math-var">y</span></button>
                    <button class="input-btn symbol" data-action="z"><span class="math-var">z</span></button>
                    <button class="input-btn symbol" data-action="a"><span class="math-var">a</span></button>
                    <button class="input-btn symbol" data-action="b"><span class="math-var">b</span></button>
                    <button class="input-btn symbol" data-action="c"><span class="math-var">c</span></button>
                    <button class="input-btn symbol" data-action="n"><span class="math-var">n</span></button>
                    <button class="input-btn special" data-action="\\frac">√∑(fr)</button>
                    <button class="input-btn special" data-action="|">|x|</button>
                    <button class="input-btn special" data-action="\\sqrt">‚àö</button>
                  </div>
                </div>
              </div>

              <!-- Calculus Accordion -->
              <div class="keyboard-accordion" style="margin-bottom: 6px">
                <div class="keyboard-accordion-header" data-target="calculusBody">
                  <span>‚à´ Calculus</span>
                  <span class="keyboard-accordion-icon">‚ñº</span>
                </div>
                <div id="calculusBody" class="keyboard-accordion-body">
                  <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 3px; padding: 8px">
                    <button class="input-btn operator" data-action="SEQ:d,/,d,x">d/dx</button>
                    <button class="input-btn operator" data-action="\\int">‚à´</button>
                    <button class="input-btn operator" data-action="\\sum">Œ£</button>
                    <button class="input-btn operator" data-action="\\lim">lim</button>
                    <button class="input-btn operator" data-action="SEQ:\\lim,_,x,\\to,0,{Right},{Right}">lim‚Üí0</button>
                    <button class="input-btn operator" data-action="SEQ:\\lim,_,x,\\to,\\infty,{Right},{Right}">lim‚Üí‚àû</button>
                    <button class="input-btn operator" data-action="\\to">‚Üí</button>
                    <button class="input-btn operator" data-action="\\infty">‚àû</button>
                    <button class="input-btn operator" data-action="\\partial">‚àÇ</button>
                    <button class="input-btn operator" data-action="e">e</button>
                  </div>
                </div>
              </div>

              <!-- Trigonometry Accordion -->
              <div class="keyboard-accordion" style="margin-bottom: 6px">
                <div class="keyboard-accordion-header" data-target="trigBody">
                  <span>üìä Trigonometry</span>
                  <span class="keyboard-accordion-icon">‚ñº</span>
                </div>
                <div id="trigBody" class="keyboard-accordion-body">
                  <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 3px; padding: 8px">
                    <button class="input-btn operator" data-action="\\sin">sin</button>
                    <button class="input-btn operator" data-action="\\cos">cos</button>
                    <button class="input-btn operator" data-action="\\tan">tan</button>
                    <button class="input-btn operator" data-action="\\sec">sec</button>
                    <button class="input-btn operator" data-action="\\csc">csc</button>
                    <button class="input-btn operator" data-action="\\arcsin">asin</button>
                    <button class="input-btn operator" data-action="\\arccos">acos</button>
                    <button class="input-btn operator" data-action="\\arctan">atan</button>
                    <button class="input-btn symbol" data-action="\\pi"><span class="math-var">œÄ</span></button>
                    <button class="input-btn operator" data-action="\\ln">ln</button>
                    <button class="input-btn special" data-action="\\circ"><span style="font-size:13px;">deg¬∞</span></button>
                  </div>
                </div>
              </div>

              <!-- Matrix & Row Operations Accordion -->
              <div class="keyboard-accordion" style="margin-bottom: 6px">
                <div class="keyboard-accordion-header" data-target="matrixBody">
                  <span>‚¨ú Matrix & Row Operations</span>
                  <span class="keyboard-accordion-icon">‚ñº</span>
                </div>
                <div id="matrixBody" class="keyboard-accordion-body">
                  <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 3px; padding: 8px">
                    <!-- Basic Matrix Notation -->
                    <button class="input-btn special" data-action="[">[</button>
                    <button class="input-btn special" data-action="]">]</button>
                    <button class="input-btn special" data-action=",">,</button>
                    <button class="input-btn special" data-action="\\\\">\</button>
                    <button class="input-btn special" data-action="&">&</button>

                    <!-- Matrix Operations -->
                    <button class="input-btn operator" data-action="\\det">det</button>
                    <button class="input-btn special" data-action="^T">[&nbsp;]<sup><sup>T</sup></sup></button>
                    <button class="input-btn special" data-action="^{-1}">[&nbsp;]<sup><sup>-1</sup></sup></button>
                    <button class="input-btn operator" data-action="\\cdot">¬∑</button>
                    <button class="input-btn operator" data-action="\\times">√ó</button>

                    <!-- Row Operation Buttons -->
                    <button class="input-btn symbol" data-action="R"><span class="math-var">R</span></button>
                    <button class="input-btn special" data-action="_" id="freestyleSubscriptMatrix"></button>
                    <button class="input-btn special" data-action="|">|</button>
                    <button class="input-btn operator" data-action="\\to">‚Üí</button>
                    <button class="input-btn operator" data-action="\\leftarrow">‚Üê</button>
                    <button class="input-btn operator" data-action="\\leftrightarrow">‚Üî</button>

                    <!-- Division for Row Scaling -->
                    <button class="input-btn operator" data-action="/">√∑</button>
                    <button class="input-btn operator" data-action="+">+</button>
                    <button class="input-btn operator" data-action="-">‚àí</button>

                    <!-- Identity and Zero matrices -->
                    <button class="input-btn symbol" data-action="I"><span class="math-var">I</span></button>
                    <button class="input-btn symbol" data-action="O"><span class="math-var">O</span></button>
                    <button class="input-btn operator" data-action="\\text{rref}">rref</button>
                    <button class="input-btn operator" data-action="\\text{rank}">rank</button>
                    <button class="input-btn operator" data-action="\\text{tr}">tr</button>
                  </div>
                </div>
              </div>

              <!-- Greek Letters Accordion -->
              <div class="keyboard-accordion" style="margin-bottom: 6px">
                <div class="keyboard-accordion-header" data-target="greekBody">
                  <span>üá¨üá∑ Greek Letters</span>
                  <span class="keyboard-accordion-icon">‚ñº</span>
                </div>
                <div id="greekBody" class="keyboard-accordion-body">
                  <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 3px; padding: 8px">
                    <button class="input-btn symbol" data-action="\\alpha"><span class="math-var">Œ±</span></button>
                    <button class="input-btn symbol" data-action="\\beta"><span class="math-var">Œ≤</span></button>
                    <button class="input-btn symbol" data-action="\\gamma"><span class="math-var">Œ≥</span></button>
                    <button class="input-btn symbol" data-action="\\delta"><span class="math-var">Œ¥</span></button>
                    <button class="input-btn symbol" data-action="\\theta"><span class="math-var">Œ∏</span></button>
                    <button class="input-btn symbol" data-action="\\lambda"><span class="math-var">Œª</span></button>
                    <button class="input-btn symbol" data-action="\\sigma"><span class="math-var">œÉ</span></button>
                    <button class="input-btn symbol" data-action="\\phi"><span class="math-var">œÜ</span></button>
                    <button class="input-btn symbol" data-action="\\omega"><span class="math-var">œâ</span></button>
                    <button class="input-btn symbol" data-action="\\mu"><span class="math-var">Œº</span></button>
                    <button class="input-btn symbol" data-action="\\rho"><span class="math-var">œÅ</span></button>
                    <button class="input-btn symbol" data-action="\\tau"><span class="math-var">œÑ</span></button>
                  </div>
                </div>
              </div>

              <!-- Comparison & Logic Accordion -->
              <div class="keyboard-accordion" style="margin-bottom: 6px">
                <div class="keyboard-accordion-header" data-target="comparisonBody">
                  <span>‚öñÔ∏è Comparison & Logic</span>
                  <span class="keyboard-accordion-icon">‚ñº</span>
                </div>
                <div id="comparisonBody" class="keyboard-accordion-body">
                  <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 3px; padding: 8px">
                    <!-- Comparison operators -->
                    <button class="input-btn operator" data-action="=">=</button>
                    <button class="input-btn operator" data-action="\\neq">‚â†</button>
                    <button class="input-btn operator" data-action="\\lt">&lt;</button>
                    <button class="input-btn operator" data-action="\\gt">&gt;</button>
                    <button class="input-btn operator" data-action="\\leq">‚â§</button>

                    <button class="input-btn operator" data-action="\\geq">‚â•</button>
                    <button class="input-btn operator" data-action="\\approx">‚âà</button>
                    <button class="input-btn operator" data-action="\\equiv">‚â°</button>
                    <button class="input-btn operator" data-action="\\propto">‚àù</button>
                    <button class="input-btn operator" data-action="\\pm">¬±</button>

                    <!-- Set theory -->
                    <button class="input-btn operator" data-action="\\in">‚àà</button>
                    <button class="input-btn operator" data-action="\\notin">‚àâ</button>
                    <button class="input-btn operator" data-action="\\subset">‚äÇ</button>
                    <button class="input-btn operator" data-action="\\subseteq">‚äÜ</button>
                    <button class="input-btn operator" data-action="\\cup">‚à™</button>

                    <button class="input-btn operator" data-action="\\cap">‚à©</button>
                    <button class="input-btn operator" data-action="\\emptyset">‚àÖ</button>
                    <button class="input-btn operator" data-action="\\forall">‚àÄ</button>
                    <button class="input-btn operator" data-action="\\exists">‚àÉ</button>
                    <button class="input-btn operator" data-action="\\therefore">‚à¥</button>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
        <!-- Load Page -->
        <div id="loadPage" class="page">
          <div class="panel">
            <h3>üìÇ Load Problem Set</h3>

            <!-- Tabs Navigation -->
            <div class="load-tabs">
              <button class="load-tab active" data-tab="fileTab">üìÅ From File</button>
              <button class="load-tab" data-tab="jsonTab">üìã Paste JSON</button>
              <button class="load-tab" data-tab="exampleTab">üìù Example Format</button>
            </div>

            <!-- Tab 1: Load from File -->
            <div id="fileTab" class="load-tab-content active">
              <label>Load Problem Set From File</label>
              <input type="file" id="uploadFile" accept=".txt,text/plain" />
              <p style="margin-top: 12px; font-size: 13px; color: #6b7280;">
                üí° Select a .txt file containing base64-compressed problem set JSON
              </p>
            </div>

            <!-- Tab 2: Paste JSON -->
            <div id="jsonTab" class="load-tab-content">
              <label>üìã Paste Base64-Compressed JSON</label>
              <textarea id="pasteJson" placeholder="Paste base64-compressed JSON here..." style="width:100%;min-height:120px;padding:12px;border-radius:8px;border:1px solid #e2e8f0;font-family:monospace;font-size:12px;"></textarea>
              <button id="loadJsonBtn" class="btn" style="margin-top: 12px;">üìÇ Load Problem Set</button>
            </div>

            <!-- Tab 3: Example Format -->
            <div id="exampleTab" class="load-tab-content">
              <label>üìù Example Formatted Problem Set</label>
              <p style="margin: 12px 0; font-size: 13px; color: #6b7280;">
                This is an example of a properly formatted problem set. You can copy and modify this template.
              </p>
              <textarea id="exampleFormatText" readonly style="width:100%;min-height:300px;padding:12px;border-radius:8px;border:1px solid #e2e8f0;font-family:monospace;font-size:11px;background:#f9fafb;"></textarea>
              <button id="copyExampleBtn" class="btn" style="margin-top: 12px; background: #10b981;">
                üìã Copy Example to Clipboard
              </button>
              <button id="loadExampleBtn" class="btn" style="margin-top: 12px; margin-left: 8px;">
                üìÇ Load This Example
              </button>
            </div>
          </div>
        </div>

        <!-- Export Page -->
        <div id="exportPage" class="page">
          <div class="panel">
            <h3>üì§ Submit Progress</h3>
            <button id="exportProgressBtn" class="btn" style="background: #10b981">üì§ Export to File</button>

            <div style="margin-top: 20px; padding-top: 20px; border-top: 2px solid #e5e7eb;">
              <h4 style="margin-bottom: 12px; color: #374151;">üì± Share via Messaging App</h4>
              <div style="display: flex; gap: 12px; flex-wrap: wrap;">
                <button id="shareWhatsAppBtn" class="btn" style="background: #25D366; color: white; flex: 1; min-width: 150px; display: flex; align-items: center; justify-content: center; gap: 8px;">
                  <svg style='width:20px;height:20px;' viewBox="0 0 24 24" fill="white">
                    <path d="M17.472 14.382c-.297-.149-1.758-.867-2.03-.967-.273-.099-.471-.148-.67.15-.197.297-.767.966-.94 1.164-.173.199-.347.223-.644.075-.297-.15-1.255-.463-2.39-1.475-.883-.788-1.48-1.761-1.653-2.059-.173-.297-.018-.458.13-.606.134-.133.298-.347.446-.52.149-.174.198-.298.298-.497.099-.198.05-.371-.025-.52-.075-.149-.669-1.612-.916-2.207-.242-.579-.487-.5-.669-.51-.173-.008-.371-.01-.57-.01-.198 0-.52.074-.792.372-.272.297-1.04 1.016-1.04 2.479 0 1.462 1.065 2.875 1.213 3.074.149.198 2.096 3.2 5.077 4.487.709.306 1.262.489 1.694.625.712.227 1.36.195 1.871.118.571-.085 1.758-.719 2.006-1.413.248-.694.248-1.289.173-1.413-.074-.124-.272-.198-.57-.347m-5.421 7.403h-.004a9.87 9.87 0 01-5.031-1.378l-.361-.214-3.741.982.998-3.648-.235-.374a9.86 9.86 0 01-1.51-5.26c.001-5.45 4.436-9.884 9.888-9.884 2.64 0 5.122 1.03 6.988 2.898a9.825 9.825 0 012.893 6.994c-.003 5.45-4.437 9.884-9.885 9.884m8.413-18.297A11.815 11.815 0 0012.05 0C5.495 0 .16 5.335.157 11.892c0 2.096.547 4.142 1.588 5.945L.057 24l6.305-1.654a11.882 11.882 0 005.683 1.448h.005c6.554 0 11.89-5.335 11.893-11.893a11.821 11.821 0 00-3.48-8.413Z"/>
                  </svg>
                  <span>Share to WhatsApp</span>
                </button>

                <button id="shareTelegramBtn" class="btn" style="background: #0088cc; color: white; flex: 1; min-width: 150px; display: flex; align-items: center; justify-content: center; gap: 8px;">
                  <svg style='width:20px;height:20px;' viewBox="0 0 24 24" fill="white">
                    <path d="M11.944 0A12 12 0 0 0 0 12a12 12 0 0 0 12 12 12 12 0 0 0 12-12A12 12 0 0 0 12 0a12 12 0 0 0-.056 0zm4.962 7.224c.1-.002.321.023.465.14a.506.506 0 0 1 .171.325c.016.093.036.306.02.472-.18 1.898-.962 6.502-1.36 8.627-.168.9-.499 1.201-.82 1.23-.696.065-1.225-.46-1.9-.902-1.056-.693-1.653-1.124-2.678-1.8-1.185-.78-.417-1.21.258-1.91.177-.184 3.247-2.977 3.307-3.23.007-.032.014-.15-.056-.212s-.174-.041-.249-.024c-.106.024-1.793 1.14-5.061 3.345-.48.33-.913.49-1.302.48-.428-.008-1.252-.241-1.865-.44-.752-.245-1.349-.374-1.297-.789.027-.216.325-.437.893-.663 3.498-1.524 5.83-2.529 6.998-3.014 3.332-1.386 4.025-1.627 4.476-1.635z"/>
                  </svg>
                  <span>Share to Telegram</span>
                </button>
              </div>
              <p style="margin-top: 12px; font-size: 12px; color: #6b7280; text-align: center;">
                üí° Share your progress directly with your teacher via WhatsApp or Telegram
              </p>
            </div>
          </div>
        </div>
        <!-- Reset Page -->
        <div id="resetPage" class="page">
          <div class="panel">
            <h3>üîÑ Reset Answers</h3>
            <p style="margin-bottom: 16px; color: #6b7280;">
              This will clear all your saved answers and progress from the browser's local storage.
              <strong>This action cannot be undone.</strong>
            </p>

            <div style="background: #fef2f2; border: 2px solid #fca5a5; border-radius: 8px; padding: 16px; margin-bottom: 20px;">
              <h4 style="color: #dc2626; margin: 0 0 8px 0;">‚ö†Ô∏è Warning</h4>
              <p style="margin: 0; color: #991b1b; font-size: 14px;">
                Resetting will delete:
              </p>
              <ul style="margin: 8px 0 0 0; color: #991b1b; font-size: 14px;">
                <li>All problem answers</li>
                <li>All step completion status</li>
                <li>All attempt history and scores</li>
                <li>Timer data</li>
              </ul>
            </div>

            <div style="display: flex; gap: 12px; flex-direction: column;">
              <button id="resetAllBtn" class="btn" style="background: #dc2626; color: white; padding: 16px; font-size: 16px; font-weight: 600;">
                üóëÔ∏è Reset All Answers
              </button>

              <button id="resetCurrentProblemBtn" class="btn" style="background: #f59e0b; color: white; padding: 14px;">
                üîÑ Reset Current Problem Only
              </button>
            </div>

            <div style="margin-top: 20px; padding-top: 20px; border-top: 2px solid #e5e7eb;">
              <h4 style="margin-bottom: 12px; color: #374151;">üìä Current Storage Info</h4>
              <div id="storageInfo" style="background: #f9fafb; border-radius: 8px; padding: 16px; font-family: monospace; font-size: 13px; color: #374151;">
                Loading storage information...
              </div>
            </div>
          </div>
        </div>

      </main>
    </div>

    <!-- Storage Indicator -->
    <div id="storageIndicator" class="storage-indicator">üíæ Saved</div>

    <!-- Python Script -->
    <script type="py">

from pyscript import document, window
from pyodide.ffi import create_proxy
import json, html, base64, uuid

print("üîß Starting Problem Solver with Multi-Type Support...")

class MathParser:
    """Handles LaTeX parsing, structural comparison, and error popups"""

    GRAMMAR = r"""
start: equation
   | matrix_ops
   | expr

?equation: expr "=" expr    -> equation

?expr: sum

?sum: sum "+" product   -> add
  | sum "-" product   -> sub
  | product

?product: product ("*" | "\\cdot" | "\\times" | "\\ast") power   -> mul  # Changed: power instead of implicit
      | product "/" power                                        -> div   # Changed: power instead of implicit
      | scalar matrix                                            -> scalar_matrix_mul
      | scalar matrix_env                                        -> scalar_matrix_mul
      | implicit

?implicit: implicit power        -> implicit_mul
       | power

?power: "-" power                -> neg
    | atom_degree              -> atom_to_degree
    | atom "^" power           -> power
    | atom

?atom: NUMBER                    -> number
   | derivative_function
   | partial_derivative_function
   | trig_function
   | log_function
   | limit
   | integral
   | summation
   | product_notation
   | sqrt_function
   | fraction
   | abs_function
   | matrix_ops
   | matrix
   | matrix_env
   | "(" expr ")"              -> paren_expr
   | "{" expr "}"              -> braces_expr
   | PI                        -> pi_symbol
   | INFTY                     -> infty_symbol
   | SYMBOL                    -> symbol
   | row_op

scalar: NUMBER | SYMBOL

trig_function: TRIG_NAME "(" expr ")"    -> trig_func

log_function: "\\log" "_" "{" expr "}" expr     -> log_func_with_base
            | "\\log" "_" NUMBER expr               -> log_func_with_base_no_braces
            | LOG_NAME "(" expr ")"                 -> log_func

limit: "\\lim" "_" "{" SYMBOL "\\to" expr "}" expr -> limit_expr

integral: "\\int" "_" "{" expr "}" "^" "{" expr "}" expr -> integral_definite
        | "\\int" "_" NUMBER "^" NUMBER expr             -> integral_definite_no_braces
        | "\\int" "_" "{" "}" "^" "{" "}" expr           -> integral_indefinite
        | "\\int" expr                                    -> integral_indefinite_simple

summation: "\\sum" "_" "{" SYMBOL "=" expr "}" "^" "{" expr "}" expr -> sum_expr
         | "\\sum" "_" "{" SYMBOL "=" expr "}" "^" "{" expr "}"      -> sum_expr_no_body
         | "\\sum" "_" SYMBOL "=" NUMBER "^" NUMBER expr             -> sum_expr_no_braces
         | "\\sum" "_" SYMBOL "=" NUMBER "^" NUMBER                  -> sum_expr_no_braces_no_body

product_notation: "\\prod" "_" "{" SYMBOL "=" expr "}" "^" "{" expr "}" expr -> prod_expr
                | "\\prod" "_" "{" SYMBOL "=" expr "}" "^" "{" expr "}"      -> prod_expr_no_body
                | "\\prod" "_" SYMBOL "=" NUMBER "^" NUMBER expr             -> prod_expr_no_braces
                | "\\prod" "_" SYMBOL "=" NUMBER "^" NUMBER                  -> prod_expr_no_braces_no_body

sqrt_function: "\\sqrt" "{" expr "}"           -> sqrt_func
             | "\\sqrt" "[" expr "]" "{" expr "}" -> nthroot_func

derivative_function: "__derivative" "(" SYMBOL "," expr ")" -> derivative_func

partial_derivative_function: "__partial_derivative" "(" SYMBOL "," expr ")" -> partial_derivative_func

fraction: "\\frac" "{" expr "}" "{" expr "}" -> frac

abs_function: "\\left" "|" expr "\\right" "|"     -> abs_func
          | "|" expr "|"                          -> abs_func

atom_degree: atom "^" degree_expr

degree_expr: "{" CIRC "}"

matrix: "[" matrix_rows "]" -> matrix_rows
matrix_rows: row ("," row)* -> matrix_rows
row: "[" elements "]" -> row
elements: expr ("," expr)* -> elements

matrix_env: "\\begin" "{" /(bmatrix|pmatrix|matrix)/ "}" matrix_env_body "\\end" "{" /(bmatrix|pmatrix|matrix)/ "}" -> matrix_env

matrix_env_body: matrix_env_row ( "\\\\" matrix_env_row )*
matrix_env_row: expr ( "&" expr )*

matrix_ops: matrix ("|" row_op)+ -> matrix_apply_ops

row_op: "R_" INT arrow row_expr                 -> row_replace
    | "R_" INT swap_arrow "R_" INT            -> row_swap

arrow: "\\to" | "\\leftarrow"
swap_arrow: "\\leftrightarrow"

row_expr: "R_" INT                     -> row_reference
       | expr "R_" INT               -> row_scale
       | "R_" INT op expr "R_" INT   -> row_combine

op: "+" | "-"

TRIG_NAME.2: "\\sin" | "\\cos" | "\\tan" | "\\cot" | "\\sec" | "\\csc"
         | "\\arcsin" | "\\arccos" | "\\arctan"
LOG_NAME.2: "\\log" | "\\ln" | "\\exp"
LIM.2: "\\lim"
NUMBER: /[+-]?\d+(\.\d*)?|\.\d+/
INT: /\d+/
PI.2: "\\pi"
INFTY.2: "\\infty"
SYMBOL: /\\?(?!(?:sin|cos|tan|cot|sec|csc|arcsin|arccos|arctan|log|ln|exp|frac|left|right|begin|end|pi|infty|lim|lvert|rvert|sqrt|sum|prod|int)(?![a-zA-Z0-9]))[a-zA-Z][a-zA-Z0-9]*/
CIRC: "\\circ"

%import common.WS_INLINE
%ignore WS_INLINE
"""
    
    def __init__(self):
        from lark import Lark
        self.parser = Lark(self.GRAMMAR, parser="earley", start="start")
        self.transformer = self._create_transformer()

    def _preprocess_derivatives(self, latex_str):
        """
        Rewrites \frac{d}{dx}(...) and \frac{\partial}{\partial x}(...)
        patterns into unique function calls before parsing.
        """
        import re

        # 1. Handle total derivatives: \frac{d}{dx}(...)
        total_derivative_pattern = re.compile(r"\\frac\{d\}\{d([a-zA-Z]+)\}\(([^)]+)\)")
        total_replacement = r"__derivative(\1, \2)"
        processed_str = total_derivative_pattern.sub(total_replacement, latex_str)

        # 2. Handle partial derivatives: \frac{\partial}{\partial x}(...)
        # This regex is slightly different to handle the \partial command and optional space.
        partial_derivative_pattern = re.compile(r"\\frac\{\\partial\}\{\\partial\s*([a-zA-Z]+)\}\(([^)]+)\)")
        partial_replacement = r"__partial_derivative(\1, \2)"
        final_str = partial_derivative_pattern.sub(partial_replacement, processed_str)

        return final_str

    def _show_error_popup(self, message):
        """Display error popup with close button - optimized for mobile"""
        safe_msg = message.replace("`", "'").replace("\\", "\\\\").replace("\n", "\\n")
        js_code = f"""
            (function(){{
                let existing = document.querySelector('#parseErrorPopup');
                if(existing) existing.remove();

                let popup = document.createElement('div');
                popup.id = 'parseErrorPopup';

                // Detect if mobile/small screen
                let isMobile = window.innerWidth <= 768;

                if(isMobile) {{
                    // Mobile styles - fullscreen-like
                    popup.style.cssText = `
                        position:fixed;
                        top:0;
                        left:0;
                        right:0;
                        bottom:0;
                        background:#f8fafc;
                        color:#0f172a;
                        font-family:monospace;
                        padding:60px 16px 16px 16px;
                        border:none;
                        border-radius:0;
                        box-shadow:none;
                        white-space:pre-wrap;
                        z-index:9999;
                        overflow:auto;
                        -webkit-overflow-scrolling:touch;
                    `;
                }} else {{
                    // Desktop styles - centered dialog
                    popup.style.cssText = `
                        position:fixed;
                        top:50%;
                        left:50%;
                        transform:translate(-50%, -50%);
                        background:#f8fafc;
                        color:#0f172a;
                        font-family:monospace;
                        padding:24px 24px 16px 24px;
                        border:2px solid #ef4444;
                        border-radius:12px;
                        box-shadow:0 12px 40px rgba(0,0,0,0.2);
                        white-space:pre;
                        z-index:9999;
                        max-width:650px;
                        max-height:70vh;
                        overflow:auto;
                    `;
                }}

                let btn = document.createElement('button');
                btn.textContent = '‚úñ';
                btn.title = 'Close';

                if(isMobile) {{
                    // Mobile close button - larger and top-left
                    btn.style.cssText = `
                        position:fixed;
                        top:12px;
                        right:12px;
                        width:44px;
                        height:44px;
                        border:none;
                        background:#ef4444;
                        color:#fff;
                        font-size:24px;
                        font-weight:bold;
                        cursor:pointer;
                        line-height:1;
                        border-radius:8px;
                        box-shadow:0 4px 12px rgba(239,68,68,0.4);
                        z-index:10000;
                    `;
                }} else {{
                    // Desktop close button - small and subtle
                    btn.style.cssText = `
                        position:absolute;
                        top:8px;
                        right:10px;
                        border:none;
                        background:transparent;
                        color:#ef4444;
                        font-size:18px;
                        font-weight:bold;
                        cursor:pointer;
                        line-height:1;
                    `;
                }}
                btn.onclick = () => popup.remove();

                let title = document.createElement('div');
                title.textContent = '‚ö†Ô∏è Parse Error';

                if(isMobile) {{
                    title.style.cssText = `
                        font-size:22px;
                        font-weight:bold;
                        color:#ef4444;
                        margin-bottom:16px;
                        padding-right:50px;
                    `;
                }} else {{
                    title.style.cssText = `
                        font-size:18px;
                        font-weight:bold;
                        color:#ef4444;
                        margin-bottom:12px;
                    `;
                }}

                let content = document.createElement('div');
                content.textContent = `{safe_msg}`;

                if(isMobile) {{
                    content.style.cssText = `
                        font-size:14px;
                        line-height:1.6;
                        word-break:break-word;
                        padding-top:8px;
                    `;
                }} else {{
                    content.style.cssText = `
                        padding-top:8px;
                    `;
                }}

                popup.appendChild(btn);
                popup.appendChild(title);
                popup.appendChild(content);
                document.body.appendChild(popup);
            }})();
        """
        window.eval(js_code)

    def _show_info_popup(self, message):
        """Display auto-dismiss info toast for auto-corrections"""
        safe_msg = message.replace("`", "'").replace("\\", "\\\\").replace("\n", "\\n")
        js_code = f"""
            (function(){{
                let existing = document.querySelector('#autoFixToast');
                if(existing) existing.remove();

                let toast = document.createElement('div');
                toast.id = 'autoFixToast';
                toast.style.cssText = `
                    position:fixed;
                    top:20px;
                    left:50%;
                    transform:translateX(-50%);
                    background:#10b981;
                    color:white;
                    font-family:system-ui, -apple-system, sans-serif;
                    padding:12px 24px;
                    border-radius:8px;
                    box-shadow:0 4px 12px rgba(0,0,0,0.15);
                    z-index:10000;
                    font-size:14px;
                    font-weight:500;
                    max-width:90%;
                    text-align:center;
                    animation:slideDown 0.3s ease;
                `;

                // Add animation keyframes if not already present
                if(!document.querySelector('#toastAnimationStyle')){{
                    let style = document.createElement('style');
                    style.id = 'toastAnimationStyle';
                    style.textContent = `
                        @keyframes slideDown {{
                            from {{ transform:translateX(-50%) translateY(-20px); opacity:0; }}
                            to {{ transform:translateX(-50%) translateY(0); opacity:1; }}
                        }}
                        @keyframes slideUp {{
                            from {{ transform:translateX(-50%) translateY(0); opacity:1; }}
                            to {{ transform:translateX(-50%) translateY(-20px); opacity:0; }}
                        }}
                    `;
                    document.head.appendChild(style);
                }}

                toast.textContent = `{safe_msg}`;
                document.body.appendChild(toast);

                // Auto-dismiss after 3 seconds with fade-out animation
                setTimeout(() => {{
                    toast.style.animation = 'slideUp 0.3s ease';
                    setTimeout(() => toast.remove(), 300);
                }}, 3000);
            }})();
        """
        window.eval(js_code)

    def _show_enhanced_error_popup(self, latex_expr, error_pos, error_type, error_msg):
        """Display enhanced error popup with MathJax rendering and error highlighting"""
        # Escape strings for JavaScript
        safe_latex = latex_expr.replace("\\", "\\\\").replace("`", "'").replace('"', '\\"')
        safe_error_type = error_type.replace("\\", "\\\\").replace("`", "'")
        safe_error_msg = error_msg.replace("\\", "\\\\").replace("`", "'").replace("\n", " ")

        # Split LaTeX at error position for highlighting
        error_pos = error_pos if error_pos is not None else len(latex_expr)
        error_pos = max(0, min(error_pos, len(latex_expr)))

        # Create a highlighted version - insert red box around error position
        before_error = latex_expr[:error_pos]
        at_error = latex_expr[error_pos:error_pos+1] if error_pos < len(latex_expr) else ""
        after_error = latex_expr[error_pos+1:] if error_pos < len(latex_expr) else ""

        # Escape for display
        safe_before = before_error.replace("\\", "\\\\").replace("`", "'").replace('"', '\\"')
        safe_at = at_error.replace("\\", "\\\\").replace("`", "'").replace('"', '\\"')
        safe_after = after_error.replace("\\", "\\\\").replace("`", "'").replace('"', '\\"')

        js_code = f"""
            (function(){{
                let existing = document.querySelector('#enhancedParseErrorPopup');
                if(existing) existing.remove();

                let popup = document.createElement('div');
                popup.id = 'enhancedParseErrorPopup';

                let isMobile = window.innerWidth <= 768;

                popup.style.cssText = `
                    position:fixed;
                    ${{isMobile ? 'top:0;left:0;right:0;bottom:0;' : 'top:50%;left:50%;transform:translate(-50%,-50%);max-width:700px;'}}
                    background:#fff;
                    border:2px solid #ef4444;
                    border-radius:${{isMobile ? '0' : '12px'}};
                    box-shadow:0 12px 40px rgba(0,0,0,0.2);
                    z-index:9999;
                    overflow:auto;
                    -webkit-overflow-scrolling:touch;
                    padding:${{isMobile ? '60px 16px 16px' : '24px'}};
                `;

                // Close button
                let closeBtn = document.createElement('button');
                closeBtn.textContent = '√ó';
                closeBtn.style.cssText = `
                    position:absolute;
                    top:${{isMobile ? '10px' : '16px'}};
                    right:${{isMobile ? '10px' : '16px'}};
                    background:#ef4444;
                    color:white;
                    border:none;
                    border-radius:50%;
                    width:${{isMobile ? '44px' : '32px'}};
                    height:${{isMobile ? '44px' : '32px'}};
                    font-size:${{isMobile ? '28px' : '24px'}};
                    cursor:pointer;
                    display:flex;
                    align-items:center;
                    justify-content:center;
                    line-height:1;
                `;
                closeBtn.onclick = () => popup.remove();

                // Title
                let title = document.createElement('div');
                title.textContent = '‚ö†Ô∏è Parse Error';
                title.style.cssText = `
                    font-size:${{isMobile ? '22px' : '20px'}};
                    font-weight:bold;
                    color:#ef4444;
                    margin-bottom:16px;
                    font-family:system-ui,-apple-system,sans-serif;
                `;

                // Error type and message
                let errorInfo = document.createElement('div');
                errorInfo.style.cssText = `
                    background:#fee2e2;
                    padding:12px;
                    border-radius:8px;
                    margin-bottom:16px;
                    font-family:system-ui,-apple-system,sans-serif;
                    font-size:14px;
                `;
                errorInfo.innerHTML = `
                    <div style='font-weight:600;color:#991b1b;margin-bottom:4px;'>{safe_error_type}</div>
                    <div style='color:#7f1d1d;'>{safe_error_msg}</div>
                `;

                // Section label
                let label = document.createElement('div');
                label.textContent = 'Your expression with error highlighted:';
                label.style.cssText = `
                    font-size:14px;
                    font-weight:600;
                    margin-bottom:8px;
                    color:#374151;
                    font-family:system-ui,-apple-system,sans-serif;
                `;

                // Math display container
                let mathContainer = document.createElement('div');
                mathContainer.style.cssText = `
                    background:#f9fafb;
                    padding:16px;
                    border-radius:8px;
                    margin-bottom:16px;
                    overflow-x:auto;
                    border:1px solid #e5e7eb;
                `;

                // Create highlighted LaTeX - use \\colorbox for highlighting
                let highlightedLatex = "{safe_before}\\\\colorbox{{#fecaca}}{{{safe_at}}}{safe_after}";

                mathContainer.innerHTML = `
                    <div style='font-size:18px;text-align:left;'>
                        $$${highlightedLatex}$$
                    </div>
                    <div style='margin-top:12px;padding-top:12px;border-top:1px solid #e5e7eb;'>
                        <div style='font-size:12px;color:#6b7280;font-family:monospace;word-break:break-all;'>
                            {safe_latex}
                        </div>
                        <div style='margin-top:4px;font-size:11px;color:#ef4444;font-family:monospace;'>
                            ${"".padStart(error_pos, " ")}‚Üë Error here (position {error_pos})
                        </div>
                    </div>
                `;

                // Hint section
                let hint = document.createElement('div');
                hint.style.cssText = `
                    background:#dbeafe;
                    padding:12px;
                    border-radius:8px;
                    font-size:13px;
                    color:#1e40af;
                    font-family:system-ui,-apple-system,sans-serif;
                `;
                hint.innerHTML = `
                    <div style='font-weight:600;margin-bottom:4px;'>üí° Common fixes:</div>
                    <ul style='margin:4px 0 0 20px;padding:0;'>
                        <li>Check for unmatched brackets or parentheses</li>
                        <li>Ensure all fractions have numerator and denominator</li>
                        <li>Remove incomplete power notation (like x^)</li>
                        <li>Check matrix format: [[row1],[row2]]</li>
                    </ul>
                `;

                popup.appendChild(closeBtn);
                popup.appendChild(title);
                popup.appendChild(errorInfo);
                popup.appendChild(label);
                popup.appendChild(mathContainer);
                popup.appendChild(hint);
                document.body.appendChild(popup);

                // Render MathJax
                if(window.MathJax && window.MathJax.typesetPromise) {{
                    window.MathJax.typesetPromise([mathContainer]).catch(err => {{
                        console.warn('MathJax rendering failed:', err);
                        // Fallback: show without MathJax
                        mathContainer.innerHTML = `
                            <div style='font-family:monospace;font-size:14px;color:#1f2937;'>
                                {safe_latex}
                            </div>
                            <div style='margin-top:4px;font-size:11px;color:#ef4444;font-family:monospace;'>
                                ${"".padStart(error_pos, " ")}‚Üë Error at position {error_pos}
                            </div>
                        `;
                    }});
                }}
            }})();
        """
        window.eval(js_code)

    def _preprocess_row_operations(self, latex_str):
        """
        Safe preprocessing: only apply row-operation regexes to the operation part.
        Normalizes matrix numbers separately so matrix content is not mangled.
        """
        import re

        # ‚úÖ VALIDATION: Check for balanced brackets in row operations
        # Row operations should be in format: [[matrix]]|ops| or [[matrix]]|ops
        if '|' in latex_str and 'R_' in latex_str:
            # Count pipes
            pipe_count = latex_str.count('|') + latex_str.count(r'\left|') + latex_str.count(r'\right|')
            # For proper row operations, we expect either:
            # 1. Two pipes: \left[\matrix\right]\left|ops\right|
            # 2. One pipe (lenient): \left[\matrix\right|ops (missing closing)
            # Warn if structure looks wrong
            if pipe_count == 1:
                window.console.warn("‚ö†Ô∏è Row operation may be missing closing pipe |")

            # Check for balanced brackets
            open_brackets = latex_str.count('[') + latex_str.count(r'\left[')
            close_brackets = latex_str.count(']') + latex_str.count(r'\right]')
            if open_brackets != close_brackets:
                window.console.warn(f"‚ö†Ô∏è Unbalanced brackets: {open_brackets} open, {close_brackets} close")

        # 0. Quick generic cleanups that are safe everywhere
        s = latex_str.replace(r'\ ', ' ')
        s = s.replace(r'\left(', '(').replace(r'\right)', ')')
        s = s.replace(r'\left[', '[').replace(r'\right]', ']')
        s = s.replace(r'\left\{', '{').replace(r'\right\}', '}')
        s = s.replace(r'\left|', '|').replace(r'\right|', '|')
        s = s.replace(r'\cdot', '*')

        # Split into matrix part and operations part.
        # Prefer explicit '|' split. If no pipe, attempt to split at arrow (\to or ->).
        if '|' in s:
            matrix_part, ops_part = s.split('|', 1)
        else:
            # attempt to split at first arrow occurrence
            m = re.search(r'(\\to|\\rightarrow|->|<-)','%s' % s)
            if m:
                # split so matrix_part includes everything before arrow, ops_part includes arrow+rest
                idx = m.start()
                matrix_part = s[:idx]
                ops_part = s[idx:]
            else:
                # nothing to do: treat entire string as matrix_part (no row op)
                matrix_part, ops_part = s, ''

        # -------------------------
        # Normalize matrix_part (do NOT run row-op rewrites here)
        # -------------------------
        # 1) collapse repeated spaces
        matrix_part = re.sub(r'\s+', ' ', matrix_part).strip()

        # 2) Remove stray spaces between minus and number/fraction inside matrix
        #    Examples: [0, - 1, - \frac{1}{2}] -> [0, -1, -\frac{1}{2}]
        matrix_part = re.sub(r'-\s+\\frac', r'-\\frac', matrix_part)          # - \frac -> -\frac
        matrix_part = re.sub(r'-\s+(\d)', r'-\1', matrix_part)                 # - 1 -> -1
        matrix_part = re.sub(r'(\{)\s+', r'\1', matrix_part)                  # remove space after { 
        matrix_part = re.sub(r'\s+(\})', r'\1', matrix_part)                  # remove space before }
        matrix_part = re.sub(r'\[\s+', '[', matrix_part)
        matrix_part = re.sub(r'\s+\]', ']', matrix_part)

        # 3) (Optional) convert simple LaTeX fractions in matrix to explicit form so parser sees them consistently
        #    e.g. replace \frac{1}{2} with (1/2) ‚Äî only inside matrix part
        #    If you prefer leaving \frac for parser, skip this.
        matrix_part = re.sub(r'\\frac\{([^{}]+)\}\{([^{}]+)\}', r'(\1/\2)', matrix_part)

        # -------------------------
        # Now operate on ops_part only (row-operation specific rewrites)
        # -------------------------
        ops = ops_part  # local alias for clarity

        if ops:
            # 1) Ensure there's a space after arrows so tokenizer can separate parts
            ops = re.sub(r'\\to(?=\S)', r'\\to ', ops)
            ops = re.sub(r'\\rightarrow(?=\S)', r'\\rightarrow ', ops)
            ops = re.sub(r'->(?=\S)', r'-> ', ops)
            ops = re.sub(r'<-(?=\S)', r'<- ', ops)

            # 2) Fix fractions with row reference in denominator: \frac{1}{2R_3} -> (1/2)R_3
            ops = re.sub(r'\\frac\{([^{}]+)\}\{\(?(\d+)\)?R_(\d+)\}', r'(\1/\2)R_\3', ops)

            # 3) Fix fractions before row reference: \frac{1}{2}R_ -> (1/2)R_
            ops = re.sub(r'\\frac\{([^{}]+)\}\{\(?([^{}]+?)\)?\}R_', r'(\1/\2)R_', ops)

            # 4) Negative fractions -\frac{...}R_ -> (-1/2)R_
            ops = re.sub(r'-\\frac\{([^{}]+)\}\{\(?([^{}]+?)\)?\}R_', r'(-\1/\2)R_', ops)

            # 5) Fix fractions in combines: R_2+\frac{1}{2}R_3 -> R_2+(1/2)R_3
            ops = re.sub(r'([+\-])\\frac\{([^{}]+)\}\{\(?([^{}]+?)\)?\}R_', r'\1(\2/\3)R_', ops)

            # 6) Remove outer wrapping parentheses from row scale expressions
            ops = re.sub(r'\((-?\([^)]+\)R_\d+)\)', r'\1', ops)
            ops = re.sub(
                r'(R_\d+\s*(?:\\to|\\rightarrow|->)\s*)\(([^()]+R_\d+)\)(?=\s*(?:\||$))',
                r'\1\2',
                ops
            )
            ops = re.sub(r'\((R_\d+)\)', r'\1', ops)

            # 7) Remove single-number parentheses before R_: (2)R_1 -> 2R_1; (-2)R_1 -> -2R_1
            ops = re.sub(r'\((\d+)\)R_', r'\1R_', ops)
            ops = re.sub(r'\((-\d+)\)R_', r'\1R_', ops)

            # 7.5 Insert implicit coefficient 1 in row combinations (ONLY in ops_part)
            # Handles: R_2-R_1 -> R_2-1R_1 ; R_2+R_1 -> R_2+1R_1
            ops = re.sub(r'(R_\d+)\s*([+\-])\s*R_', r'\1\g<2>1R_', ops)

            # 7c. Force spaces around + and - inside ops_part so lexer never fuses +5 into a single token
            ops = re.sub(r'([+\-])', r' \1 ', ops)

            # 7d. Canonicalize multiple +/- combos: "--"->"+", "+-"|"-+"->"-"
            ops = re.sub(r'\+\s*\+', ' + ', ops)
            ops = re.sub(r'-\s*-', ' + ', ops)
            ops = re.sub(r'\+\s*-|-\s*\+', ' - ', ops)

            # 8) Remove stray backslashes before UPPERCASE letters and parentheses only
            #    Fixes: \R -> R, \( -> (, \) -> )
            #    Preserves: \to, \rightarrow, \frac, etc. (lowercase commands)
            ops = re.sub(r'\\([A-Z()])', r'\1', ops)

            # 9) Clean up multiple spaces in ops
            ops = re.sub(r'\s+', ' ', ops).strip()

        # -------------------------
        # Recombine matrix_part and ops_part (if ops existed)
        # -------------------------
        if ops:
            # Ensure single pipe between matrix and ops
            out = matrix_part.strip() + '|' + ops
        else:
            out = matrix_part.strip()

        # Final cleanup (a little extra safety)
        out = re.sub(r'\|{2,}', '|', out)
        out = re.sub(r'\s+', ' ', out).strip()
        out = re.sub(r'\|\s*$', '', out)  # remove trailing pipe
        # --- Step 7: Final sanity rewrite for self-row combos ---
        # Convert R_n+nR_n ‚Üí R_n-(-n)R_n
            # --- Step 7: Final rewrite for all "+" row operations ---
        # Convert any R_n1 + nR_n2 ‚Üí R_n1 - (-n)R_n2
        out = re.sub(
            r'(R_(\d+))\s*\+\s*([0-9]+)R_(\d+)',
            lambda m: f"{m.group(1)} - (-{m.group(3)})R_{m.group(4)}",
            out
        )

        # Convert any R_n1 + R_n2 ‚Üí R_n1 - (-1)R_n2
        out = re.sub(
            r'(R_(\d+))\s*\+\s*R_(\d+)',
            lambda m: f"{m.group(1)} - (-1)R_{m.group(3)}",
            out
        )

        return out

    def expression_has_matrix_operations(self, latex_str):
      """
      Quick check if a LaTeX expression contains matrix row operations.
      Must have BOTH a pipe AND row operation indicators.
      """
      if not latex_str:
          return False

      # ‚úÖ CRITICAL FIX: Matrix operations MUST have a pipe character
      # This prevents false positives with limits that use \to
      if '|' not in latex_str:
          return False

      # Now check for row operation indicators AFTER the pipe
      indicators = [
          "R_",            # Row reference (most reliable)
          "\\leftarrow",   # Left arrow
          "\\leftrightarrow"  # Swap arrow
      ]

      # Check if any indicator appears after a pipe
      pipe_index = latex_str.find('|')
      if pipe_index >= 0:
          after_pipe = latex_str[pipe_index:]
          return any(ind in after_pipe for ind in indicators)

      return False
  
    def auto_fix_common_errors(self, latex_str):
      """
      Attempt to automatically fix common LaTeX syntax errors.
      Returns (fixed_string, list_of_fixes_applied)
      """
      import re

      fixes_applied = []
      original = latex_str
      s = latex_str

      # 0. Fix \right| when it should be \right]| in matrix context
      #    \right|R_1 ‚Üí \right]|R_1
      before = s
      s = re.sub(r'\\right\|(\s*R_)', r'\\right]|\1', s)
      if s != before:
          fixes_applied.append("Fixed pipe delimiter (\\right| ‚Üí \\right]|)")

      # 0.5. Fix period instead of comma between matrix rows
      #    ]\right].\left[ ‚Üí ]\right],\left[
      before = s
      s = re.sub(r'(\]|\\\right\])\s*\.\s*(\[|\\left\[)', r'\1,\2', s)
      if s != before:
          fixes_applied.append("Fixed period to comma between matrix rows")

      # 0.6. Fix missing outer brackets for comma-separated matrix rows
      #    [1,0],[0,1] ‚Üí [[1,0],[0,1]]
      #    \left[1,0\right],\left[0,1\right] ‚Üí \left[\left[1,0\right],\left[0,1\right]\right]
      before = s
      # For \left\right notation
      if s.startswith(r'\left[') and not s.startswith(r'\left[\left['):
          if re.search(r'\\right\]\s*,\s*\\left\[', s):
              s = r'\left[' + s + r'\right]'
              fixes_applied.append("Added outer brackets for matrix rows (\\left notation)")
      # For simple bracket notation
      elif s.startswith('[') and not s.startswith('[['):
          if '],[' in s:
              s = '[' + s + ']'
              fixes_applied.append("Added outer brackets for matrix rows")

      # 1. Fix missing commas between numbers in matrices (space-separated)
      #    [[1 2 3],[4 5 6]] ‚Üí [[1,2,3],[4,5,6]]
      before = s
      s = re.sub(r'(\d)\s+(\d)', r'\1,\2', s)
      if s != before:
          fixes_applied.append("Added missing commas between numbers")

      # 2. Fix unbalanced square brackets in matrices
      #    Count opening and closing brackets, add missing ones
      open_count = s.count('[')
      close_count = s.count(']')
      if open_count > close_count:
          s = s + (']' * (open_count - close_count))
          fixes_applied.append(f"Added {open_count - close_count} missing closing bracket(s)")
      elif close_count > open_count:
          s = ('[' * (close_count - open_count)) + s
          fixes_applied.append(f"Added {close_count - open_count} missing opening bracket(s)")

      # 3. Fix mismatched brackets in matrices (curly/square)
      #    [[1,2,3},[4,5,6]] ‚Üí [[1,2,3],[4,5,6]]
      before = s
      # Replace } with ] if it appears after [ and before ]
      s = re.sub(r'\[([^[\]]*)\}', r'[\1]', s)
      # Replace { with [ if it appears in matrix context
      s = re.sub(r'\{([^[\]{}]*)\]', r'[\1]', s)
      if s != before:
          fixes_applied.append("Fixed mismatched brackets (changed {} to [])")

      # 4. Fix missing pipe before row operations
      #    [[1,2]]R_1 ‚Üí [[1,2]]|R_1
      before = s
      s = re.sub(r'\]\](\s*R_\d+)', r']]|\1', s)
      if s != before:
          fixes_applied.append("Added missing pipe before row operation")

      # 5. Fix double operators
      #    2+-3 ‚Üí 2-3,  2-+3 ‚Üí 2-3,  2--3 ‚Üí 2+3,  2++3 ‚Üí 2+3
      before = s
      s = re.sub(r'\+\s*-', '-', s)
      s = re.sub(r'-\s*\+', '-', s)
      s = re.sub(r'-\s*-', '+', s)
      s = re.sub(r'\+\s*\+', '+', s)
      if s != before:
          fixes_applied.append("Fixed double operators")

      # 6. Fix unbalanced parentheses
      open_paren = s.count('(')
      close_paren = s.count(')')
      if open_paren > close_paren:
          s = s + (')' * (open_paren - close_paren))
          fixes_applied.append(f"Added {open_paren - close_paren} missing closing parenthesis")
      elif close_paren > open_paren:
          s = ('(' * (close_paren - open_paren)) + s
          fixes_applied.append(f"Added {close_paren - open_paren} missing opening parenthesis")

      # 7. Fix missing asterisk in fraction notation
      #    \frac12 ‚Üí \frac{1}{2}
      before = s
      s = re.sub(r'\\frac(\d)(\d)', r'\\frac{\1}{\2}', s)
      if s != before:
          fixes_applied.append("Fixed fraction notation (added braces)")

      # 8. Remove stray trailing operators
      #    2+3+ ‚Üí 2+3,  5*7* ‚Üí 5*7
      before = s
      s = re.sub(r'[+\-*/]\s*$', '', s)
      if s != before:
          fixes_applied.append("Removed trailing operator")

      # 9. Remove dangling power operators (forgotten exponent)
      #    2^ ‚Üí 2,  x^ ‚Üí x,  (2+3)^ ‚Üí (2+3)
      before = s
      s = re.sub(r'\^(?=\s*[,\]\)|\|]|\s*$)', '', s)  # Remove ^ before comma, ], ), |, or end
      if s != before:
          fixes_applied.append("Removed incomplete power notation (missing exponent)")

      # 10. Fix empty exponents in braces
      #    x^{} ‚Üí x,  2^{} ‚Üí 2
      before = s
      s = re.sub(r'\^\{\s*\}', '', s)
      if s != before:
          fixes_applied.append("Removed empty exponent braces")

      # 11. Fix missing underscore in row operations
      #    R1 ‚Üí R_1,  R2 ‚Üí R_2,  R123 ‚Üí R_123
      before = s
      s = re.sub(r'R(\d+)', r'R_\1', s)
      if s != before:
          fixes_applied.append("Added missing underscore in row notation (R1 ‚Üí R_1)")

      # 12. Normalize arrow notation in row operations
      #    -> ‚Üí \to,  <- ‚Üí \leftarrow
      before = s
      # Only replace arrows that appear in row operation context (after R_digit)
      s = re.sub(r'(R_\d+)\s*->\s*', r'\1\\to ', s)
      s = re.sub(r'(R_\d+)\s*<->\s*', r'\1\\leftrightarrow ', s)
      s = re.sub(r'(R_\d+)\s*<-\s*', r'\1\\leftarrow ', s)
      if s != before:
          fixes_applied.append("Normalized arrow notation (-> ‚Üí \\to)")

      return (s, fixes_applied)

    def parse_latex(self, latex):
      """Parse LaTeX to SymPy expression with error popup display and auto-fix"""
      import re
      from lark.exceptions import UnexpectedToken, UnexpectedCharacters, UnexpectedEOF

      window.console.log(f"üîç [DEBUG 1] Original LaTeX: {latex}")

      # üÜï AUTO-FIX: Try to fix common errors first
      fixed_latex, fixes = self.auto_fix_common_errors(latex)
      if fixes:
          window.console.log(f"üîß Auto-fixes applied: {', '.join(fixes)}")
          window.console.log(f"üîß Fixed LaTeX: {fixed_latex}")
          # Store corrected latex for caller to update MathQuill field
          self.last_corrected_latex = fixed_latex
          # Show a subtle notification to user
          self._show_info_popup(f"‚ú® Auto-corrected: {', '.join(fixes)}")
          latex = fixed_latex
      else:
          self.last_corrected_latex = None

      cleaned = self.clean_latex(latex)
      window.console.log(f"üîç [DEBUG 2] After clean_latex: {cleaned}")

      clean = self._preprocess_derivatives(cleaned)
      window.console.log(f"üîç [DEBUG 3] After preprocess_derivatives: {clean}")

      # ‚úÖ FIX: Only preprocess row operations if they actually exist
      if self.expression_has_matrix_operations(clean):
          clean = self._preprocess_row_operations(clean)
          window.console.log(f"üîç [DEBUG 4] After preprocess_row_operations: {clean}")
      else:
          window.console.log(f"üîç [DEBUG 4] No row operations detected, skipping preprocessing")

      window.console.log(f"Cleaned LaTeX: {clean}")

      try:
          window.console.log(f"üîç [DEBUG 5] About to call parser.parse()...")
          tree = self.parser.parse(clean)
          window.console.log(f"üîç [DEBUG 6] Parse successful, tree type: {type(tree)}")

          window.console.log(f"üîç [DEBUG 7] About to call transformer.transform()...")
          result = self.transformer.transform(tree)
          window.console.log(f"üîç Transformed result: {result}")
          return result

      except (UnexpectedToken, UnexpectedCharacters, UnexpectedEOF) as e:
          # üÜï RETRY: Try more aggressive fixes on first failure
          window.console.log("‚ö†Ô∏è Initial parse failed, attempting aggressive auto-fix...")

          # Try removing extra spaces around operators
          retry_clean = re.sub(r'\s*([+\-*/=])\s*', r'\1', clean)

          # Try fixing common matrix issues in the cleaned string
          retry_clean = re.sub(r',\s*,', ',', retry_clean)  # Remove double commas
          retry_clean = re.sub(r'\[\s*,', '[', retry_clean)  # Remove leading comma in row
          retry_clean = re.sub(r',\s*\]', ']', retry_clean)  # Remove trailing comma in row

          if retry_clean != clean:
              try:
                  window.console.log(f"üîß Retry with aggressive fixes: {retry_clean}")
                  tree = self.parser.parse(retry_clean)
                  result = self.transformer.transform(tree)
                  self._show_info_popup("‚ú® Fixed parsing error with aggressive corrections")
                  window.console.log(f"‚úÖ Retry successful: {result}")
                  return result
              except Exception as retry_error:
                  window.console.log(f"‚ùå Retry also failed: {retry_error}")

          # If retry also failed, show original error with visual highlighting
          pos = getattr(e, "pos_in_stream", None)
          line = getattr(e, "line", "?")
          col = getattr(e, "column", "?")

          # Remove "Expected ‚Ä¶" section from Lark message
          raw_msg = str(e)
          simplified_msg = re.sub(r"Expected one of:.*", "", raw_msg, flags=re.DOTALL).strip()

          # Build context with caret pointing to error
          try:
              span = 35
              start = max(0, (pos or 0) - span)
              end = min(len(clean), (pos or 0) + span)
              snippet = clean[start:end]
              caret_pos = (pos or 0) - start
              caret_line = " " * caret_pos + "‚Üë"
              context = f"{snippet}\n{caret_line}"
          except Exception:
              context = clean

          # üÜï Show enhanced error with MathJax rendering and highlighting
          self._show_enhanced_error_popup(clean, pos, type(e).__name__, simplified_msg)

          # Also log to console
          msg = (
              f"‚ùå Parse error in LaTeX:\n\n"
              f"Line: {line}, Column: {col}\n"
              f"Type: {type(e).__name__}\n"
              f"Message: {simplified_msg}\n\n"
              f"Context:\n{context}"
          )
          window.console.error(msg)
          return None

      except Exception as e:
          window.console.error(f"‚ùå [DEBUG ERROR] Exception type: {type(e).__name__}")
          window.console.error(f"‚ùå [DEBUG ERROR] Exception message: {str(e)}")
          import traceback
          tb_str = traceback.format_exc()
          window.console.error(f"‚ùå [DEBUG ERROR] Traceback:\n{tb_str}")

          msg = f"‚ùå General parse error: {e}"
          window.console.error(msg)
          self._show_error_popup(msg)
          return None

    def clean_latex(self, tex):
      """Normalize LaTeX string for parsing"""
      import re
      if not tex:
          return ""
      t = str(tex)

      # Remove \left and \right but keep the parentheses
      t = t.replace("\\left(", "(")
      t = t.replace("\\right)", ")")
      t = t.replace("\\left[", "[")
      t = t.replace("\\right]", "]")
      t = t.replace("\\left\\{", "{")
      t = t.replace("\\right\\}", "}")
      t = t.replace("\\left|", "|")
      t = t.replace("\\right|", "|")

      # Replace mathrm{d} with d
      t = t.replace("\\mathrm{d}", "d")

      # Remove spacing macros (but NOT backslash-space, which is handled by _preprocess_row_operations)
      t = re.sub(r"\\(?:,|;|:|!|quad|qquad)", "", t)

      # Protect matrix row separators
      t = re.sub(r"\\\\\s*", "\\\\", t)

      # Ensure & separators have no surrounding whitespace
      t = re.sub(r"\s*&\s*", "&", t)

      # ‚≠ê CRITICAL: Replace backslash-space BEFORE removing all whitespace
      # This prevents "\ R" from becoming "\R" when whitespace is removed
      t = t.replace(r"\ ", "<<SPACE>>")

      # Remove whitespace
      t = re.sub(r"\s+", "", t)

      # Restore the spaces that were marked by backslash-space
      t = t.replace("<<SPACE>>", " ")

      # ‚≠ê CRITICAL FIX: Add explicit multiplication for implicit cases
      # IMPORTANT: Apply these BEFORE the digit-letter rule to avoid conflicts

      # 1. Between closing paren and opening paren: )( -> )*(
      t = re.sub(r'\)\s*\(', ')*(', t)

      # 2. Between closing paren and digit: )2 -> )*2
      t = re.sub(r'\)(\d)', r')*\1', t)

      # 3. Between closing paren and letter: )x -> )*x
      t = re.sub(r'\)([a-zA-Z])', r')*\1', t)

      # 4. Between digit and opening paren: 2( -> 2*(
      # BUT NOT after integral bounds: \int_1^3( should stay as is
      t = re.sub(r'(?<![\^])(\d)\(', r'\1*(', t)

      # 5. Between single letter and opening paren: x( -> x*(, but not for function names like sin(
      t = re.sub(r'(?<![a-zA-Z])([a-zA-Z])\(', r'\1*(', t)

      # 6. Between digit and letter: 2x -> 2*x (original rule, kept last)
      # BUT NOT after integral bounds: \int_1^3x should stay as is for cases like \int_0^1x
      # IMPORTANT: Do NOT add * before R_ (row references like 2R_1 must stay as implicit multiplication)
      t = re.sub(r'(?<![\^])(\d)([a-zA-Z])(?!_)', r'\1*\2', t)

      return t.strip()

    def _create_transformer(self):
        """Create the Lark transformer with improved rules"""
        from lark import Transformer, v_args
        import sympy as sp

        # ‚úÖ Define canonical_scalar at the top level of this function
        def canonical_scalar(x):
            """Convert/normalize a value to a canonical SymPy scalar (Integer/Rational/Float simplified)."""
            if not isinstance(x, sp.Basic):
                try:
                    x = sp.sympify(x)
                except Exception:
                    return x
            # Prefer exact rationals for floats represented as strings
            if isinstance(x, sp.Float):
                try:
                    x = sp.Rational(str(x))
                except Exception:
                    pass
            # Simplify and evaluate any Mul/Add wrappers (handles Mul(-1,n) -> -n)
            x = sp.simplify(x)
            try:
                x = x.doit()
            except Exception:
                pass
            return sp.simplify(x)
          
        @v_args(inline=True)
        class Latex2Sympy(Transformer):
            _canonical_scalar = canonical_scalar
            def paren_expr(self, expr):
                return expr

            def braces_expr(self, expr):
                return expr

            def equation(self, lhs, rhs):
                """Handle equations like x=3 by returning an Eq object"""
                return sp.Eq(lhs, rhs, evaluate=False)

            def number(self, tok):
                s = str(tok)
                return sp.Integer(s) if '.' not in s else sp.Float(s)

            def symbol(self, tok):
                s = str(tok).strip()
                return sp.Symbol(s[1:] if s.startswith("\\") else s)

            def pi_symbol(self, _):
                return sp.pi

            def infty_symbol(self, _):
                return sp.oo

            def infinity(self, tok):
                s = str(tok)
                return -sp.oo if s.startswith('-') else sp.oo

            def abs_func(self, expr):
                return sp.Abs(expr)

            def neg(self, v):
                return sp.Mul(-1, v, evaluate=False)

            def add(self, a, b):
                return sp.Add(a, b, evaluate=False)

            def sub(self, a, b):
                return sp.Add(a, sp.Mul(-1, b, evaluate=False), evaluate=False)

            def mul(self, a, b):
                if isinstance(a, (sp.MatrixBase, sp.MatrixExpr)) or isinstance(b, (sp.MatrixBase, sp.MatrixExpr)):
                    a_ = sp.UnevaluatedExpr(a) if isinstance(a, (sp.MatrixBase, sp.MatrixExpr)) else a
                    b_ = sp.UnevaluatedExpr(b) if isinstance(b, (sp.MatrixBase, sp.MatrixExpr)) else b
                    return sp.Mul(a_, b_, evaluate=False)
                return sp.Mul(a, b, evaluate=True)

            def div(self, a, b):
                return sp.Mul(a, sp.Pow(b, -1, evaluate=False), evaluate=False)

            def frac(self, numerator, denominator):
                return sp.Mul(numerator, sp.Pow(denominator, -1, evaluate=False), evaluate=False)

            def trig_func(self, func_name, expr):
                func_str = str(func_name).strip().replace("\\", "")
                func_map = {
                    "sin": sp.sin,
                    "cos": sp.cos,
                    "tan": sp.tan,
                    "cot": sp.cot,
                    "sec": sp.sec,
                    "csc": sp.csc,
                    "arcsin": sp.asin,
                    "arccos": sp.acos,
                    "arctan": sp.atan,
                }
                func = func_map.get(func_str)
                if func:
                    return func(expr)
                return sp.Function(func_str)(expr)

            def log_func(self, func_name, expr):
                func_str = str(func_name).strip().replace("\\", "")
                if func_str == "ln":
                    return sp.ln(expr)
                elif func_str == "log":
                    return sp.log(expr, 10)
                elif func_str == "exp":
                    return sp.exp(expr)
                return sp.Function(func_str)(expr)

            def log_func_with_base(self, base, expr):
                """Handle logarithm with base like \log_{10}100"""
                return sp.log(expr, base)

            def log_func_with_base_no_braces(self, base, expr):
                """Handle logarithm with base without braces like \log_10 100"""
                base_val = sp.sympify(str(base))
                return sp.log(expr, base_val)

            def limit_expr(self, var, value, expr):
                return sp.Limit(expr, sp.Symbol(str(var)), value)

            def integral_definite(self, lower, upper, integrand):
                """Handle definite integrals like \int_{1}^{3}(2x) dx with braces"""
                # Extract the integration variable from the integrand
                # Usually it's the free symbol in the expression
                free_symbols = integrand.free_symbols
                if free_symbols:
                    # Use the first free symbol as the integration variable
                    # For more complex cases, we might need smarter heuristics
                    var = sorted(free_symbols, key=str)[0]
                else:
                    # If no free symbols, use x as default
                    var = sp.Symbol('x')
                return sp.Integral(integrand, (var, lower, upper))

            def integral_definite_no_braces(self, lower, upper, integrand):
                """Handle definite integrals like \int _1^3(2x) dx without braces around bounds"""
                # Convert NUMBER tokens to SymPy expressions
                lower_val = sp.sympify(str(lower))
                upper_val = sp.sympify(str(upper))

                # Extract the integration variable from the integrand
                free_symbols = integrand.free_symbols
                if free_symbols:
                    var = sorted(free_symbols, key=str)[0]
                else:
                    var = sp.Symbol('x')
                return sp.Integral(integrand, (var, lower_val, upper_val))

            def integral_indefinite(self, integrand):
                """Handle indefinite integrals like \int _{ }^{ }(2x) dx with empty braces"""
                # Extract the integration variable from the integrand
                free_symbols = integrand.free_symbols
                if free_symbols:
                    var = sorted(free_symbols, key=str)[0]
                else:
                    var = sp.Symbol('x')
                return sp.Integral(integrand, var)

            def integral_indefinite_simple(self, integrand):
                """Handle indefinite integrals like \int (2x) dx without bounds"""
                # Extract the integration variable from the integrand
                free_symbols = integrand.free_symbols
                if free_symbols:
                    var = sorted(free_symbols, key=str)[0]
                else:
                    var = sp.Symbol('x')
                return sp.Integral(integrand, var)

            def sum_expr(self, var, lower, upper, body):
                """Handle summation like \sum_{i=1}^{n} expr"""
                var_sym = sp.Symbol(str(var))
                return sp.Sum(body, (var_sym, lower, upper))

            def sum_expr_no_body(self, var, lower, upper):
                """Handle summation without body like \sum_{i=1}^{n}"""
                # Return a symbolic sum with a placeholder variable
                var_sym = sp.Symbol(str(var))
                # Use the variable itself as the body when no body is provided
                return sp.Sum(var_sym, (var_sym, lower, upper))

            def sum_expr_no_braces(self, var, lower, upper, body):
                """Handle summation like \sum _i=1^n expr without braces"""
                var_sym = sp.Symbol(str(var))
                lower_val = sp.sympify(str(lower))
                upper_val = sp.sympify(str(upper))
                return sp.Sum(body, (var_sym, lower_val, upper_val))

            def sum_expr_no_braces_no_body(self, var, lower, upper):
                """Handle summation like \sum _i=1^n without braces or body"""
                var_sym = sp.Symbol(str(var))
                lower_val = sp.sympify(str(lower))
                upper_val = sp.sympify(str(upper))
                return sp.Sum(var_sym, (var_sym, lower_val, upper_val))

            def prod_expr(self, var, lower, upper, body):
                """Handle product like \prod_{i=1}^{n} expr"""
                var_sym = sp.Symbol(str(var))
                return sp.Product(body, (var_sym, lower, upper))

            def prod_expr_no_body(self, var, lower, upper):
                """Handle product without body like \prod_{i=1}^{n}"""
                var_sym = sp.Symbol(str(var))
                return sp.Product(var_sym, (var_sym, lower, upper))

            def prod_expr_no_braces(self, var, lower, upper, body):
                """Handle product like \prod _i=1^n expr without braces"""
                var_sym = sp.Symbol(str(var))
                lower_val = sp.sympify(str(lower))
                upper_val = sp.sympify(str(upper))
                return sp.Product(body, (var_sym, lower_val, upper_val))

            def prod_expr_no_braces_no_body(self, var, lower, upper):
                """Handle product like \prod _i=1^n without braces or body"""
                var_sym = sp.Symbol(str(var))
                lower_val = sp.sympify(str(lower))
                upper_val = sp.sympify(str(upper))
                return sp.Product(var_sym, (var_sym, lower_val, upper_val))

            def sqrt_func(self, expr):
                """Handle square root like \sqrt{x}"""
                return sp.sqrt(expr)

            def nthroot_func(self, n, expr):
                """Handle nth root like \sqrt[3]{x} for cube root"""
                return sp.Pow(expr, sp.Rational(1, n))

            def implicit_mul(self, a, b):
                if isinstance(a, sp.Matrix) or isinstance(b, sp.Matrix):
                    return sp.Mul(a, b, evaluate=False)
                return sp.Mul(a, b, evaluate=False)

            def power(self, a, b):
                """
                Handle right-associative power like 10^100^0 correctly.
                Lark gives us nested trees due to right recursion.
                """
                import sympy as sp

                # If right child is another power, handle it recursively.
                # Example: a=10, b=Pow(100, 0) -> Pow(10, (100**0))
                if isinstance(b, sp.Pow):
                    return sp.Pow(a, b, evaluate=False)

                return sp.Pow(a, b, evaluate=False)

            # --- NEW METHOD FOR DEGREES ---
            def atom_to_degree(self, tree):
                """
                Handles expressions like 90^\circ.
                Converts degrees to radians by multiplying by pi/180.
                """
                # tree.children[0] is the already-transformed atom (e.g., the number 90)
                atom = tree.children[0]
                # We don't need tree.children[1] which is the degree_expr
                return sp.pi * atom / 180

            def elements(self, *items):
                return list(items)

            def row(self, elements):
                return list(elements) if isinstance(elements, (list, tuple)) else [elements]

            def matrix_rows(self, *rows):
                row_list = [list(r) if isinstance(r, (list, tuple)) else [r] for r in rows]
                return sp.Matrix(row_list)

            def matrix_env(self, *args):
                rows = []
                for a in args:
                    if a is None:
                        continue
                    if isinstance(a, list) and a and all(isinstance(x, (list, tuple)) for x in a):
                        rows.extend([list(r) for r in a])
                    elif isinstance(a, (list, tuple)):
                        rows.append(list(a))
                    else:
                        rows.append([a])
                return sp.Matrix(rows)

            def scalar_matrix_mul(self, scalar, matrix):
                return sp.Mul(scalar, matrix, evaluate=False)

            def row_reference(self, i):
                return ("ref", int(i))

            def row_scale(self, factor, i):
                return ("scale", int(i), factor)

            def row_replace(self, target, arrow, expr):
                """Row replacement operation - arrow parameter is captured but not used"""
                return ("replace", int(target), expr)

            def row_swap(self, i, swap_arrow, j):
                """Row swap operation - swap_arrow parameter is captured but not used"""
                return ("swap", int(i), int(j))

            def row_combine(self, i, op, factor, j):
                return ("combine", int(i), str(op), factor, int(j))

            def matrix_apply_ops(self, matrix, *ops):
              import sympy as sp
              # Ensure we have a writable SymPy Matrix copy
              m = sp.Matrix(matrix) if not isinstance(matrix, sp.Matrix) else matrix.copy()

              # ‚úÖ Store original matrix and track operations
              original_matrix = m.copy()
              operations_list = []

              # Canonicalize input matrix elements up-front (avoids '- 1' split issues)
              m = m.applyfunc(canonical_scalar)

              for op in ops:
                  # ‚úÖ Record each operation BEFORE applying it
                  operations_list.append({
                      "type": op[0],
                      "details": list(op[1:]) if len(op) > 1 else []
                  })

                  if op[0] == "replace":
                      _, target, expr = op
                      tgt = int(target) - 1  # 0-based

                      if expr[0] == "ref":
                          _, src = expr
                          # copy row to avoid aliasing
                          m[tgt, :] = m[int(src)-1, :].copy()

                      elif expr[0] == "scale":
                          _, src, factor = expr
                          src_row = [canonical_scalar(v) for v in list(m[int(src)-1, :].copy())]
                          factor_sym = canonical_scalar(factor)
                          new_elems = [ canonical_scalar(factor_sym * v) for v in src_row ]
                          m[tgt, :] = sp.Matrix([ new_elems ]).reshape(1, m.cols)

                      elif expr[0] == "combine":
                          _, src, op_str, factor, other = expr
                          src_idx = int(src) - 1
                          other_idx = int(other) - 1

                          # CRITICAL: copy both source rows so we compute from originals
                          src_row = [ canonical_scalar(v) for v in list(m[src_idx, :].copy()) ]
                          other_row = [ canonical_scalar(v) for v in list(m[other_idx, :].copy()) ]

                          factor_sym = canonical_scalar(factor)

                          new_elems = []
                          for a, b in zip(src_row, other_row):
                              if op_str == "+":
                                  val = canonical_scalar(a + factor_sym * b)
                              else:
                                  val = canonical_scalar(a - factor_sym * b)
                              new_elems.append(val)

                          m[tgt, :] = sp.Matrix([ new_elems ]).reshape(1, m.cols)

                  elif op[0] == "swap":
                      _, i, j = op
                      i0, j0 = int(i)-1, int(j)-1
                      temp = m[i0, :].copy()
                      m[i0, :] = m[j0, :].copy()
                      m[j0, :] = temp

              # final pass to ensure everything canonicalized
              result = m.applyfunc(canonical_scalar)

              # ‚úÖ CRITICAL: Store metadata on the FINAL result matrix
              # This preserves the operation history even after canonicalization
              result._matrix_op_metadata = {
                  "operations": operations_list,
                  "original_shape": (original_matrix.rows, original_matrix.cols)
              }

              window.console.log(f"‚úÖ Stored metadata on matrix with {len(operations_list)} operation(s)")

              return result

            # --- METHODS FOR PREPROCESSED DERIVATIVES ---
            def derivative_func(self, var, expr):
                """Handles the preprocessed __derivative(var, expr) call."""
                return sp.Derivative(expr, sp.Symbol(str(var)))

            def partial_derivative_func(self, var, expr):
                """Handles the preprocessed __partial_derivative(var, expr) call."""
                return sp.Derivative(expr, sp.Symbol(str(var)))

            def start(self, e):
                return e

        return Latex2Sympy()

    def validate_limit(self, limit_expr):
        """
        Validate if a limit problem is suitable for students.
        Returns (is_valid, error_message)

        Invalid cases:
        1. Different left and right limit values (discontinuity)
        2. Oscillating limits (e.g., sin(1/x) as x->0)
        3. Limits that evaluate to infinity
        """
        import sympy as sp

        if not isinstance(limit_expr, sp.Limit):
            return (True, None)  # Not a limit, skip validation

        try:
            # Get the limit components
            expr = limit_expr.args[0]
            var = limit_expr.args[1]
            point = limit_expr.args[2]

            # Evaluate the limit
            limit_value = limit_expr.doit()

            # Check 1: Limit evaluates to infinity
            if limit_value.has(sp.oo) or limit_value == sp.oo or limit_value == -sp.oo:
                return (False, f"Limit evaluates to infinity: {limit_value}")

            # Check 2: Limit does not exist (returns unevaluated or NaN)
            if isinstance(limit_value, sp.Limit) or limit_value is sp.nan:
                return (False, "Limit does not exist or cannot be determined")

            # Check 3: Different left and right limits (if approaching a finite point)
            if point != sp.oo and point != -sp.oo:
                try:
                    left_limit = sp.limit(expr, var, point, '-')
                    right_limit = sp.limit(expr, var, point, '+')

                    # Simplify both limits
                    left_simplified = sp.simplify(left_limit)
                    right_simplified = sp.simplify(right_limit)

                    # Check if they're different
                    if not sp.simplify(left_simplified - right_simplified) == 0:
                        return (False, f"Left and right limits differ: left={left_simplified}, right={right_simplified}")
                except:
                    pass

            # Check 4: Oscillating behavior (limit doesn't exist due to oscillation)
            # This is tricky - we check if the limit is AccumBounds or contains zoo
            if hasattr(limit_value, 'is_finite') and not limit_value.is_finite:
                if limit_value != sp.oo and limit_value != -sp.oo:
                    return (False, "Limit oscillates or is undefined")

            # Check for AccumBounds (accumulated bounds, indicates oscillation)
            if 'AccumBounds' in str(type(limit_value)):
                return (False, "Limit oscillates between multiple values")

            # Check for zoo (complex infinity, often from oscillation)
            if limit_value == sp.zoo:
                return (False, "Limit is complex infinity (oscillation or undefined)")

            return (True, None)

        except Exception as e:
            window.console.error(f"Error validating limit: {e}")
            return (False, f"Error evaluating limit: {str(e)}")

    def normalize_expr(self, expr):
        """Normalize and simplify expressions - with better sanity check"""
        import sympy as sp

        if expr is None:
            return None

        try:
            window.console.log(f"üîß NORMALIZE INPUT: {expr}")
            window.console.log(f"üîß NORMALIZE INPUT (srepr): {sp.srepr(expr)}")

            # Store original for comparison
            original_expr = expr

            if hasattr(expr, "doit"):
                window.console.log(f"DEBUG: Expression has doit, calling it...") 
                expr = expr.doit()
                window.console.log(f"DEBUG: After doit: {expr}")
                window.console.log(f"DEBUG: After doit (srepr): {sp.srepr(expr)}")

            if isinstance(expr, list):
                expr = sp.Matrix(expr)
            if isinstance(expr, sp.Matrix):
                expr = expr.applyfunc(sp.simplify)
            else:
                if isinstance(expr, sp.Mul) and not expr.is_Number:
                    args = expr.args
                    has_matrix = any(isinstance(a, sp.Matrix) for a in args)
                    has_scalar = any(not isinstance(a, sp.Matrix) for a in args)
                    if has_matrix and has_scalar:
                        return sp.Mul(*args, evaluate=True)

                # Store expression after doit but before simplify
                after_doit = expr
                window.console.log(f"üîß Before simplify: {after_doit}")

                # ‚úÖ LIGHT normalization
                expr = sp.simplify(expr)
                window.console.log(f"üîß NORMALIZE OUTPUT: {expr}")
                window.console.log(f"üîß NORMALIZE OUTPUT (srepr): {sp.srepr(expr)}")

                # ‚úÖ IMPROVED SANITY CHECK: Test multiple values
                try:
                    free_syms = list(original_expr.free_symbols)
                    if free_syms:
                        # Test with multiple values including 2.5, 3.7, -1.5
                        test_values = [2.5, 3.7, -1.5, 10.0]

                        for test_x in test_values:
                            test_subs = {sym: test_x for sym in free_syms}

                            # Evaluate both
                            try:
                                original_numeric = complex(original_expr.subs(test_subs))
                                normalized_numeric = complex(expr.subs(test_subs))
                                after_doit_numeric = complex(after_doit.subs(test_subs))

                                diff_orig_norm = abs(original_numeric - normalized_numeric)
                                diff_doit_norm = abs(after_doit_numeric - normalized_numeric)

                                window.console.log(f"Test @ x={test_x}:")
                                window.console.log(f"  Original: {original_numeric}")
                                window.console.log(f"  After doit: {after_doit_numeric}")
                                window.console.log(f"  After simplify: {normalized_numeric}")
                                window.console.log(f"  Diff (orig vs norm): {diff_orig_norm}")
                                window.console.log(f"  Diff (doit vs norm): {diff_doit_norm}")

                                if diff_orig_norm > 1e-6:
                                    window.console.error(f"‚ö†Ô∏è NORMALIZATION BROKE EXPRESSION at x={test_x}!")
                                    window.console.error(f"   Difference: {diff_orig_norm}")
                                    # Return the expression after doit, not after simplify
                                    window.console.error(f"   Returning after-doit version instead")
                                    return after_doit

                            except (ZeroDivisionError, OverflowError) as e:
                                window.console.warn(f"  Skipping x={test_x} due to: {e}")
                                continue

                        window.console.log(f"‚úì Sanity check passed all test values")
                except Exception as sanity_err:
                    window.console.warn(f"‚ö†Ô∏è Sanity check failed (non-fatal): {sanity_err}")

        except Exception as e:
            window.console.error(f"ERROR inside normalize: {e}")
            import traceback
            window.console.error(traceback.format_exc())
            return expr

        return expr

    def final_eq(self, a, b):
        """Check equality for scalar or matrix expressions with multiple strategies"""
        import sympy as sp
        try:
            # Handle equation comparisons
            if isinstance(a, sp.Equality) and isinstance(b, sp.Equality):
                # Both are equations: compare both sides
                lhs_eq = self.final_eq(a.lhs, b.lhs) and self.final_eq(a.rhs, b.rhs)
                rhs_eq = self.final_eq(a.lhs, b.rhs) and self.final_eq(a.rhs, b.lhs)
                return lhs_eq or rhs_eq
            elif isinstance(a, sp.Equality) and not isinstance(b, sp.Equality):
                # a is equation, b is plain expression
                # Check if b matches either side of the equation
                return self.final_eq(a.lhs, b) or self.final_eq(a.rhs, b)
            elif isinstance(b, sp.Equality) and not isinstance(a, sp.Equality):
                # b is equation, a is plain expression
                # Check if a matches either side of the equation
                return self.final_eq(a, b.lhs) or self.final_eq(a, b.rhs)

            # Handle matrix comparisons
            if isinstance(a, sp.MatrixBase) and isinstance(b, sp.MatrixBase):
                if a.shape != b.shape:
                    return False
                # Define canonical_scalar locally if not available
                def canonical_scalar_local(x):
                    if not isinstance(x, sp.Basic):
                        try:
                            x = sp.sympify(x)
                        except Exception:
                            return x
                    if isinstance(x, sp.Float):
                        try:
                            x = sp.Rational(str(x))
                        except Exception:
                            pass
                    x = sp.simplify(x)
                    try:
                        x = x.doit()
                    except Exception:
                        pass
                    return sp.simplify(x)

                # Compare elements with canonical normalization
                for i in range(a.rows):
                    for j in range(a.cols):
                        a_elem = canonical_scalar_local(a[i, j])
                        b_elem = canonical_scalar_local(b[i, j])
                        diff = sp.simplify(a_elem - b_elem)
                        if diff != 0:
                            window.console.log(f"Matrix element mismatch at [{i},{j}]: {a_elem} vs {b_elem}, diff={diff}")
                            return False
                return True
            if isinstance(a, sp.MatrixBase) and isinstance(b, list):
                return self.final_eq(a, sp.Matrix(b))
            if isinstance(b, sp.MatrixBase) and isinstance(a, list):
                return self.final_eq(sp.Matrix(a), b)

            # ‚úÖ STRATEGY: Multiple passes with increasing aggressiveness
            # This handles expressions built with evaluate=False

            # Strategy 1: Direct comparison (fastest, handles simple cases)
            try:
                if a == b:
                    window.console.log("‚úì Strategy 1: Direct comparison succeeded")
                    return True
            except:
                pass

            # Strategy 2: Simplify difference (handles most cases)
            try:
                diff = sp.simplify(a - b)
                if diff == 0:
                    window.console.log("‚úì Strategy 2: Simplify difference succeeded")
                    return True
            except:
                pass

            # Strategy 3: Expand then simplify (handles unevaluated Mul/Add with evaluate=False)
            try:
                a_expanded = sp.expand(a)
                b_expanded = sp.expand(b)
                diff = sp.simplify(a_expanded - b_expanded)
                if diff == 0:
                    window.console.log("‚úì Strategy 3: Expand then simplify succeeded")
                    return True
            except:
                pass

            # Strategy 4: Full normalization pipeline (handles complex cases)
            try:
                # Apply multiple simplification passes
                a_norm = sp.simplify(sp.expand(a))
                b_norm = sp.simplify(sp.expand(b))

                # Try difference first
                diff = sp.simplify(a_norm - b_norm)
                if diff == 0:
                    window.console.log("‚úì Strategy 4a: Normalized difference succeeded")
                    return True

                # Try direct comparison
                if a_norm == b_norm:
                    window.console.log("‚úì Strategy 4b: Normalized direct comparison succeeded")
                    return True
            except:
                pass

            # Strategy 5: PowerSimp + Collect (handles nested powers and like terms)
            try:
                a_processed = sp.simplify(sp.powsimp(sp.expand(a), force=True))
                b_processed = sp.simplify(sp.powsimp(sp.expand(b), force=True))

                diff = sp.simplify(a_processed - b_processed)
                if diff == 0:
                    window.console.log("‚úì Strategy 5: PowerSimp succeeded")
                    return True
            except:
                pass

            # Strategy 6: SymPy's equals method (most robust but slowest)
            try:
                result = a.equals(b)
                if result:
                    window.console.log("‚úì Strategy 6: equals() method succeeded")
                return result
            except:
                pass

            # All strategies failed - provide detailed diagnostic information
            window.console.log("=" * 60)
            window.console.log("‚úó All comparison strategies failed")
            window.console.log("=" * 60)
            window.console.log(f"Expression A: {a}")
            window.console.log(f"Expression B: {b}")
            window.console.log(f"Type A: {type(a)}")
            window.console.log(f"Type B: {type(b)}")
            window.console.log(f"srepr(A): {sp.srepr(a)}")
            window.console.log(f"srepr(B): {sp.srepr(b)}")
            try:
                diff = sp.simplify(a - b)
                window.console.log(f"Difference (A - B): {diff}")
                window.console.log(f"srepr(diff): {sp.srepr(diff)}")
            except Exception as diff_err:
                window.console.log(f"Could not compute difference: {diff_err}")
            window.console.log("=" * 60)
            return False

        except Exception as e:
            window.console.error(f"final_eq error: {e}")
            # Last resort: try equals method
            try:
                return a.equals(b)
            except:
                return False
          
    def structural_match(self, expr1, expr2, tolerance='strict'):
      """
      Compare expressions structurally, not just mathematically.

      tolerance levels:
      - 'strict': Must have identical structure
      - 'loose': Allow minor differences (commutativity, associativity)
      - 'math': Full mathematical equivalence (same as final_eq)
      """
      import sympy as sp

      if expr1 is None or expr2 is None:
          return False

      window.console.log(f"üîç Structural match check (tolerance={tolerance})")
      window.console.log(f"   expr1: {expr1}")
      window.console.log(f"   expr2: {expr2}")
      window.console.log(f"   expr1 srepr: {sp.srepr(expr1)}")
      window.console.log(f"   expr2 srepr: {sp.srepr(expr2)}")

      if tolerance == 'math':
          # Use full mathematical equivalence
          return self.final_eq(expr1, expr2)

      # Extract structures
      struct1 = self.extract_structure(expr1)
      struct2 = self.extract_structure(expr2)

      window.console.log(f"   struct1 operators: {struct1['operators']}")
      window.console.log(f"   struct2 operators: {struct2['operators']}")
      window.console.log(f"   struct1 operands: {struct1['operands']}")
      window.console.log(f"   struct2 operands: {struct2['operands']}")

      if tolerance == 'strict':
          # Strict: operators and operands must match exactly
          operators_match = struct1['operators'] == struct2['operators']
          operands_match = struct1['operands'] == struct2['operands']

          window.console.log(f"   operators_match: {operators_match}")
          window.console.log(f"   operands_match: {operands_match}")

          if operators_match and operands_match:
              window.console.log("‚úÖ Strict structural match: PASS")
              return True
          else:
              window.console.log("‚ùå Strict structural match: FAIL")
              # Try mathematical equivalence as fallback
              math_eq = self.final_eq(expr1, expr2)
              if math_eq:
                  window.console.log("‚ö†Ô∏è Expressions are mathematically equivalent but structurally different")
              return False

      elif tolerance == 'loose':
          # Loose: Allow some flexibility but check overall structure
          # Check if operator counts are similar
          ops1_total = struct1['total_ops']
          ops2_total = struct2['total_ops']

          # Allow ¬±1 difference in operator count
          if abs(ops1_total - ops2_total) > 1:
              window.console.log(f"‚ùå Loose structural match: operator count difference too large")
              return False

          # Check if main operators are present
          ops1_set = set(struct1['operators'].keys())
          ops2_set = set(struct2['operators'].keys())

          if ops1_set != ops2_set:
              window.console.log(f"‚ùå Loose structural match: different operator types")
              return False

          window.console.log("‚úÖ Loose structural match: PASS")
          return True

      return False
    
    def extract_structure(self, expr):
      """
      Extract structural fingerprint of expression INCLUDING matrix operations.
      Normalizes all numeric values to consistent float representation for reliable comparison.
      """
      import sympy as sp, traceback
      operators, operands, matrix_ops = {}, {}, []

      def normalize_numeric_to_string(node):
          """
          Convert any numeric value to normalized string representation.
          Rational(1, 2) ‚Üí "0.5"
          Integer(2) ‚Üí "2.0" 
          Float(0.5) ‚Üí "0.5"
          """
          try:
              # Check if it's a SymPy numeric type
              if isinstance(node, sp.Basic):
                  if hasattr(node, 'is_number') and node.is_number:
                      # Convert to float for consistency
                      float_val = float(node.evalf())
                      # Check if it's effectively an integer
                      if float_val == int(float_val):
                          return str(int(float_val))
                      else:
                          return str(float_val)

              # Check if it's a Python numeric type
              if isinstance(node, (int, float)):
                  if isinstance(node, int) or float(node) == int(float(node)):
                      return str(int(node))
                  else:
                      return str(float(node))

              # Try to parse as number from string
              node_str = str(node)
              if '/' in node_str:
                  # Handle fraction strings like "1/2"
                  parts = node_str.split('/')
                  if len(parts) == 2:
                      try:
                          num = float(parts[0].strip())
                          denom = float(parts[1].strip())
                          if denom != 0:
                              result = num / denom
                              if result == int(result):
                                  return str(int(result))
                              else:
                                  return str(result)
                      except:
                          pass

              # Try direct float conversion
              try:
                  float_val = float(node_str)
                  if float_val == int(float_val):
                      return str(int(float_val))
                  else:
                      return str(float_val)
              except:
                  pass

          except Exception as e:
              window.console.log(f"normalize_numeric_to_string error: {e}")

          # If all else fails, return string representation
          return str(node).strip().replace(" ", "")

      def normalize_matrix_metadata(metadata):
          """
          Normalize matrix operation metadata to ensure consistent numeric representation.
          """
          if not metadata or not isinstance(metadata, dict):
              return metadata

          normalized = {
              "type": metadata.get("type"),
              "operations": [],
              "original_shape": metadata.get("original_shape")
          }

          for operation in metadata.get("operations", []):
              normalized_op = {
                  "type": operation.get("type"),
                  "details": normalize_details_list(operation.get("details", []))
              }
              normalized["operations"].append(normalized_op)

          return normalized

      def normalize_details_list(details):
          """
          Recursively normalize a list/tuple of operation details.
          Converts nested structures and numeric values.
          """
          if details is None:
              return []

          if not isinstance(details, (list, tuple)):
              details = [details]

          normalized = []
          for item in details:
              if isinstance(item, (list, tuple)):
                  # Recursively normalize nested structures
                  normalized.append(normalize_details_list(item))
              elif isinstance(item, str):
                  # Keep strings as-is (like "scale", "swap", etc.)
                  normalized.append(item)
              else:
                  # Normalize numeric values
                  normalized.append(normalize_numeric_to_string(item))

          return normalized

      def process(node, parent_op=None):
          nonlocal matrix_ops

          if node is None:
              return

          # Skip tuple coordinates from matrix indexing
          if isinstance(node, (tuple, list)) and all(isinstance(i, sp.Integer) for i in node):
              return

          # ‚úÖ CRITICAL: Detect matrix operations by checking for metadata
          if isinstance(node, sp.MatrixBase):
              # Check if this matrix has row operation metadata
              if hasattr(node, '_matrix_op_metadata'):
                  metadata = node._matrix_op_metadata

                  # Normalize the metadata before storing
                  normalized_metadata = normalize_matrix_metadata(metadata)

                  matrix_ops.append({
                      "type": "matrix_with_row_ops",
                      "operations": normalized_metadata["operations"],
                      "original_shape": normalized_metadata["original_shape"]
                  })

                  window.console.log(f"‚úÖ Found matrix with {len(metadata['operations'])} operation(s)")
                  window.console.log(f"   Normalized operations: {normalized_metadata['operations']}")
              else:
                  window.console.log(f"‚ÑπÔ∏è Matrix has no _matrix_op_metadata attribute")

              # Process matrix elements
              for el in node:
                  process(el, parent_op)
              return

          # Handle MatrixExpr (symbolic matrix operations)
          if isinstance(node, sp.MatrixExpr) and not isinstance(node, sp.MatrixBase):
              val = normalize_numeric_to_string(node)
              operands[val] = operands.get(val, 0) + 1
              return

          # Check if this is a Mul(-1, x) pattern (negation)
          if isinstance(node, sp.Mul) and len(node.args) == 2:
              a, b = node.args
              if a == sp.Integer(-1) and isinstance(b, (sp.Symbol, sp.Number)):
                  # Simplify Mul(-1, x) to -x
                  simplified = sp.simplify(node)
                  val = normalize_numeric_to_string(simplified)
                  operands[val] = operands.get(val, 0) + 1
                  window.console.log(f"‚úÖ Simplified Mul(-1, {b}) -> {val}")
                  return

          # Handle nodes with arguments (operators)
          if hasattr(node, "args") and len(node.args) > 0:
              op_name = type(node).__name__

              # Skip Tuple nodes
              if op_name == "Tuple":
                  for c in node.args:
                      process(c, parent_op)
                  return

              # Don't double-count nested Mul operations
              if not (op_name == "Mul" and (parent_op == "Mul" or len(node.args) == 1)):
                  operators[op_name] = operators.get(op_name, 0) + 1

              # Recursively process children
              for c in node.args:
                  process(c, op_name)
              return

          # Handle leaf nodes (operands) - NORMALIZE HERE
          val = normalize_numeric_to_string(node)

          # Skip -1 as it's usually part of subtraction/negation
          if val == "-1":
              return

          operands[val] = operands.get(val, 0) + 1

      try:
          process(expr)
      except Exception as e:
          window.console.log(f"extract_structure error: {e}")
          window.console.log(traceback.format_exc())

      result = {
          "operators": operators,
          "operands": operands,
          "matrix_ops": matrix_ops,
          "total_ops": sum(operators.values()),
          "total_operands": sum(operands.values())
      }

      window.console.log(f"üìä Extracted structure: {len(matrix_ops)} matrix operation(s)")
      if matrix_ops:
          window.console.log(f"   Matrix ops details: {matrix_ops}")

      return result
    

# ============================================================================
# End of MathParser Class
# Now you can use: self.math_parser = MathParser()
# ============================================================================

class ScoreRecalculationTracker:
    """Tracks edits and triggers score recalculation based on rules"""
    def __init__(self, app_instance):
        self.app = app_instance
        self.edited_steps = set()  # Current session edits: set of (problem_idx, step_idx) tuples
        self.first_time_edits_in_session = set()  # NEW: Track which current session edits are first-time
        self.ever_edited_steps = set()  # All-time edited steps: set of (problem_idx, step_idx) tuples (never reset)
        self.last_edit_time = None
        self.timer_handle = None
        self.pending_edits = {}  # {(problem_idx, step_idx): new_answer}
        self.current_problem_idx = None
    
    def reset(self):
        """Reset current session tracking state (but keep ever_edited_steps)"""
        window.console.log("üîÑ Resetting score recalculation tracker")
        self.edited_steps.clear()
        self.first_time_edits_in_session.clear()  # NEW: Clear first-time tracking
        self.pending_edits.clear()
        self.last_edit_time = None
        if self.timer_handle:
            window.clearTimeout(self.timer_handle)
            self.timer_handle = None

    def full_reset(self):
        """Full reset including ever_edited_steps - called when new problem set is loaded"""
        window.console.log("üîÑ FULL reset of score recalculation tracker (new problem set)")
        self.edited_steps.clear()
        self.first_time_edits_in_session.clear()
        self.ever_edited_steps.clear()  # ‚úÖ Also clear all-time tracking
        self.pending_edits.clear()
        self.last_edit_time = None
        if self.timer_handle:
            window.clearTimeout(self.timer_handle)
            self.timer_handle = None

    def add_edit(self, problem_idx, step_idx, new_answer):
        """Called when user edits an answer"""
        import datetime

        self.current_problem_idx = problem_idx

        # Create a unique key for this edit (global across all problems)
        edit_key = (problem_idx, step_idx)

        # ‚úÖ Track if this is a first-time edit BEFORE adding to ever_edited_steps
        is_first_time_edit = edit_key not in self.ever_edited_steps

        # Add to current session
        self.edited_steps.add(edit_key)

        # ‚úÖ Track first-time status for this session
        if is_first_time_edit:
            self.first_time_edits_in_session.add(edit_key)

        # Add to all-time tracking
        self.ever_edited_steps.add(edit_key)

        self.last_edit_time = datetime.datetime.now()
        self.pending_edits[edit_key] = new_answer

        window.console.log(f"üìù Edit tracked: problem {problem_idx}, step {step_idx}, first-time: {is_first_time_edit}")
        window.console.log(f"   Current session: {len(self.edited_steps)} edits, {len(self.first_time_edits_in_session)} first-time")
        window.console.log(f"   Ever edited (global): {len(self.ever_edited_steps)}")

        # ‚úÖ Check if we have at least 2 first-time edits in current session
        if len(self.first_time_edits_in_session) >= 2:
            window.console.log("‚úÖ At least 2 first-time edits detected (global) - triggering immediate recalculation")
            # Cancel timer if running (no longer needed)
            if self.timer_handle:
                window.clearTimeout(self.timer_handle)
                self.timer_handle = None
                window.console.log("‚è±Ô∏è Timer cancelled (2 edits reached)")
            self.trigger_recalculation("2_edits")
        else:
            window.console.log(f"‚è±Ô∏è Only {len(self.first_time_edits_in_session)} first-time edit(s)")
            # ‚úÖ Only start timer if NOT already running
            if not self.timer_handle:
                # ‚úÖ Only start timer if in review mode (review section exists)
                # Otherwise, score_display_manager timer handles it
                msg_el = document.querySelector("#reviewScoreMessage")
                if msg_el:
                    window.console.log("‚è±Ô∏è In review mode - starting 5-minute timer")
                    def timer_callback():
                        self.trigger_recalculation("5_minutes")
                    self.timer_handle = window.setTimeout(create_proxy(timer_callback), 5 * 60 * 1000)
                    self.update_ui_message()
                else:
                    window.console.log("‚è±Ô∏è In solving mode - score_display_manager will handle timer")
            else:
                window.console.log("‚è±Ô∏è Timer already running - not restarting")
                self.update_ui_message()  # Update countdown display
    
    def trigger_recalculation(self, reason):
        """Recalculate score and reset"""
        window.console.log(f"üî¢ Triggering score recalculation: {reason}")
        
        # Apply all pending edits to problem_states
        for (prob_idx, step_idx), answer in self.pending_edits.items():
            if prob_idx in self.app.problem_states:
                if step_idx < len(self.app.problem_states[prob_idx]):
                    self.app.problem_states[prob_idx][step_idx]["user_answers"] = answer
                    window.console.log(f"  Applied edit to problem {prob_idx}, step {step_idx}: {answer}")
        
        self.app.save_to_storage()
        
        self.show_recalculation_message(reason)
        
        def show_updated_score():
            total_score, max_score, problem_scores = self.app.calculate_total_score()
            percentage = (total_score / max_score * 100.0) if max_score > 0 else 0.0

            self.app.update_score_display_in_review(percentage)
            
            self.reset()
            
            window.console.log(f"‚úÖ Score updated: {percentage:.1f}%")
        
        window.setTimeout(create_proxy(show_updated_score), 2000)
    
    def show_recalculation_message(self, reason):
        """Show message during recalculation"""
        msg_el = document.querySelector("#reviewScoreMessage")
        if msg_el:
            if reason == "2_edits":
                msg_el.innerHTML = """
                <div style='background:#dbeafe;color:#1e40af;padding:12px;border-radius:6px;text-align:center;'>
                    ‚úÖ 2 edits detected - Recalculating score... ‚è≥
                </div>
                """
            else:
                msg_el.innerHTML = """
                <div style='background:#dbeafe;color:#1e40af;padding:12px;border-radius:6px;text-align:center;'>
                    ‚è±Ô∏è 5 minutes elapsed - Recalculating score... ‚è≥
                </div>
                """
    
    def update_ui_message(self):
        """Update the UI to show current status - uses unified timer message"""
        import datetime

        first_time_count = len(self.first_time_edits_in_session)

        # Clear the old #reviewScoreMessage div since we're using unified display now
        msg_el = document.querySelector("#reviewScoreMessage")
        if msg_el:
            msg_el.innerHTML = ""

        if self.last_edit_time and first_time_count < 2:
            elapsed = (datetime.datetime.now() - self.last_edit_time).total_seconds()
            remaining = max(0, int(5 * 60 - elapsed))

            # ‚úÖ Only create unified timer message if one doesn't already exist
            # The unified message has its own internal countdown, so we don't need to recreate it
            review_section = document.querySelector("[id^='reviewSection_']")
            existing_unified_msg = review_section.querySelector(".unified-timer-msg") if review_section else None

            if not existing_unified_msg:
                # Create new unified timer message (it will handle its own countdown)
                self.app.show_unified_timer_message(remaining_seconds=remaining, context="in review mode")
            # else: message already exists with active countdown, don't create duplicate


class KeyboardInputHandler:
  """Common handler for keyboard input to MathQuill fields"""

  @staticmethod
  def handle_action(mathquill_field, action):
      """
      Handle keyboard action for a MathQuill field

      Args:
          mathquill_field: MathQuill field instance
          action: String action from button data-action attribute
      """
      if not mathquill_field:
          window.console.error("No MathQuill field provided")
          return

      window.console.log(f"KeyboardInputHandler: Action = {action}")

      # ==================== NAVIGATION & CONTROL ====================
      if action == "BACKSPACE":
          mathquill_field.keystroke("Backspace")
      elif action == "CLEAR":
          mathquill_field.latex("")
      elif action == "MOVE_LEFT":
          mathquill_field.keystroke("Left")
      elif action == "MOVE_RIGHT":
          mathquill_field.keystroke("Right")
      elif action == "SELECT_LEFT":
          # Selection works but buttons were stealing focus - now fixed with preventDefault
          mathquill_field.keystroke("Shift-Left")
      elif action == "SELECT_RIGHT":
          # Selection works but buttons were stealing focus - now fixed with preventDefault
          mathquill_field.keystroke("Shift-Right")
      elif action == "TOGGLE_KEYBOARD":
          # Special action: toggle keyboard mode
          if hasattr(window, 'problem_solver_app'):
              window.problem_solver_app.toggle_soft_keyboard(None)
          else:
              window.console.error("App instance not found for keyboard toggle")
          return  # Don't process further

      # ==================== SPECIAL OPERATORS ====================
      elif action == "^":
          mathquill_field.cmd("^")
      elif action == "_":
          mathquill_field.cmd("_")
      elif action == "/":
          mathquill_field.cmd("/")

      # ==================== ARITHMETIC OPERATORS ====================
      elif action == "+":
          mathquill_field.write("+")
      elif action == "-":
          mathquill_field.write("-")
      elif action == "*":
          mathquill_field.cmd("times")
      elif action == "\\times":
          mathquill_field.cmd("times")
      elif action == "\\cdot":
          mathquill_field.cmd("cdot")
      elif action == "\\div":
          mathquill_field.cmd("div")
      elif action == "=":
          mathquill_field.write("=")

      # ==================== BRACKETS & DELIMITERS ====================
      elif action == "(":
          mathquill_field.write("(")
      elif action == ")":
          mathquill_field.write(")")
      elif action == "[":
          mathquill_field.write("[")
      elif action == "]":
          mathquill_field.write("]")
      elif action == "{":
          mathquill_field.write("{")
      elif action == "}":
          mathquill_field.write("}")
      elif action == "|":
          mathquill_field.cmd("|")
      elif action == ",":
          mathquill_field.write(",")
      elif action == ".":
          mathquill_field.write(".")
      elif action == "&":
          mathquill_field.write("&")
      elif action == "\\\\":
          mathquill_field.write("\\\\")

      # ==================== ALGEBRA & CALCULUS ====================
      elif action == "\\sqrt":
          mathquill_field.cmd("sqrt")
      elif action == "\\frac":
          mathquill_field.cmd("frac")
      elif action == "\\int":
          mathquill_field.cmd("int")
      elif action == "\\sum":
          mathquill_field.cmd("sum")
      elif action == "\\prod":
          mathquill_field.cmd("prod")
      elif action == "\\infty":
          mathquill_field.cmd("infty")
      elif action == "\\partial":
          mathquill_field.cmd("partial")
      elif action == "\\to":
          mathquill_field.cmd("to")
      elif action == "\\lim":
          mathquill_field.cmd("lim")

      # ==================== TRIGONOMETRY ====================
      elif action == "\\sin":
          mathquill_field.cmd("sin")
      elif action == "\\cos":
          mathquill_field.cmd("cos")
      elif action == "\\tan":
          mathquill_field.cmd("tan")
      elif action == "\\cot":
          mathquill_field.cmd("cot")
      elif action == "\\sec":
          mathquill_field.cmd("sec")
      elif action == "\\csc":
          mathquill_field.cmd("csc")
      elif action == "\\arcsin":
          mathquill_field.cmd("arcsin")
      elif action == "\\arccos":
          mathquill_field.cmd("arccos")
      elif action == "\\arctan":
          mathquill_field.cmd("arctan")

      # ==================== LOGARITHMS ====================
      elif action == "\\log":
          mathquill_field.cmd("log")
      elif action == "\\ln":
          mathquill_field.cmd("ln")
      elif action == "\\exp":
          mathquill_field.cmd("exp")
      elif action == "e":
          mathquill_field.write("e")

      # ==================== GREEK LETTERS ====================
      elif action == "\\alpha":
          mathquill_field.cmd("alpha")
      elif action == "\\beta":
          mathquill_field.cmd("beta")
      elif action == "\\gamma":
          mathquill_field.cmd("gamma")
      elif action == "\\delta":
          mathquill_field.cmd("delta")
      elif action == "\\theta":
          mathquill_field.cmd("theta")
      elif action == "\\lambda":
          mathquill_field.cmd("lambda")
      elif action == "\\pi":
          mathquill_field.cmd("pi")
      elif action == "\\sigma":
          mathquill_field.cmd("sigma")
      elif action == "\\phi":
          mathquill_field.cmd("phi")
      elif action == "\\omega":
          mathquill_field.cmd("omega")

      # ==================== SEQUENCES ====================
      elif action.startswith("SEQ:"):
          # Handle sequences like d/dx, SEQ:d,/,d,x
          # Supports keystrokes in curly braces like {Space}, {Right}
          sequence = action[4:]
          keys = sequence.split(",")
          for key in keys:
              key = key.strip()

              # Check if it's a keystroke command in curly braces
              if key.startswith("{") and key.endswith("}"):
                  # Extract keystroke name (e.g., {Space} -> Space, {Right} -> Right)
                  keystroke_name = key[1:-1]
                  mathquill_field.keystroke(keystroke_name)
              elif key == "/":
                  mathquill_field.cmd("/")
              elif key == "_":
                  mathquill_field.cmd("_")
              elif key == "^":
                  mathquill_field.cmd("^")
              elif key.startswith("\\"):
                  mathquill_field.cmd(key[1:])  # Remove backslash
              else:
                  mathquill_field.write(key)

      # ==================== GENERIC LATEX COMMAND ====================
      elif action.startswith("\\"):
          # Remove backslash and use cmd()
          cmd_name = action[1:]
          window.console.log(f"Generic LaTeX cmd: {cmd_name}")
          mathquill_field.cmd(cmd_name)

      # ==================== DEFAULT: WRITE AS TEXT ====================
      else:
          # For digits, variables, and simple text
          mathquill_field.write(action)

      # Focus the field after input
      try:
          mathquill_field.focus()
      except:
          pass


class ProblemSolverApp:
    # ============================================
    # COMPLETE REVIEW SYSTEM - Only shows when ALL problems done
    # ============================================

    def show_review_section(self):
        """Show the review section - ONLY after all problems are complete"""
        window.console.log("üìä Checking if review can be shown...")

        # ‚úÖ CHECK: All problems must be complete
        if not self._all_problems_complete():
            window.console.log("‚ö†Ô∏è Not all problems are complete yet. Review not shown.")
            return

        window.console.log("‚úÖ All problems complete! Building review section...")

        # Calculate total score
        total_score, max_score, problem_scores = self.calculate_total_score()
        if max_score > 0:
            percentage = (total_score / max_score) * 100
        else:
            percentage = 0

        # ‚úÖ Check if score display should be deferred due to 5-minute timer
        import js
        should_defer_score = False
        remaining_seconds = 0

        if self.score_display_manager["pending_score_update"]:
            last_edit = self.score_display_manager["last_edit_time"]
            if last_edit:
                current_time = js.Date.now()
                elapsed_ms = current_time - last_edit
                elapsed_minutes = elapsed_ms / 60000

                if elapsed_minutes < 5:
                    # Still within waiting period - defer score display
                    should_defer_score = True
                    remaining_seconds = int(300 - (elapsed_ms / 1000))
                    window.console.log(f"‚è±Ô∏è Deferring score display - {remaining_seconds}s remaining in waiting period")
                else:
                    # Waiting period complete - can show score
                    window.console.log("‚úÖ Waiting period complete - showing score")
                    self.score_display_manager["pending_score_update"] = False

        window.console.log(f"Final score: {percentage:.1f}% ({total_score:.1f}/{max_score:.1f}), deferred: {should_defer_score}")

        # Find or create review container
        review_container = document.querySelector("#reviewSectionContainer")
        if not review_container:
            review_container = document.createElement("div")
            review_container.id = "reviewSectionContainer"

            main_content = document.querySelector("#solveProblemsContainer")
            if main_content:
                main_content.appendChild(review_container)

        # Clear existing content
        review_container.innerHTML = ""

        # Create review section
        review_section = document.createElement("div")
        review_section.id = "reviewSection_all"
        review_section.className = "review-section"
        review_section.style.cssText = """
            background: #ffffff;
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        """

        # Add header with completion message
        header = document.createElement("div")
        header.style.cssText = "margin-bottom: 20px;"
        header.innerHTML = """
            <div style="background: linear-gradient(135deg, #10b981, #059669); color: white; padding: 16px; border-radius: 8px; margin-bottom: 16px; text-align: center;">
                <div style="font-size: 32px; margin-bottom: 8px;">üéâ</div>
                <div style="font-size: 20px; font-weight: 700;">Congratulations!</div>
                <div style="font-size: 14px; opacity: 0.9; margin-top: 4px;">You've completed all problems in this set</div>
            </div>
            <h2 style="margin: 0 0 8px 0; color: #1e293b; font-size: 24px;">
                üìä Problem Set Review
            </h2>
            <p style="color: #64748b; margin: 0; font-size: 14px;">
                Review all your answers and edit if needed
            </p>
        """
        review_section.appendChild(header)

        # Add score message div (for edit tracking messages)
        score_msg_div = document.createElement("div")
        score_msg_div.id = "reviewScoreMessage"
        score_msg_div.style.cssText = "margin-bottom: 16px;"
        review_section.appendChild(score_msg_div)

        # Add overall score display with champion badge OR pending message
        score_display = document.createElement("div")
        score_display.id = "overallScoreDisplay"

        if should_defer_score:
            # Show pending message with countdown
            minutes = remaining_seconds // 60
            seconds = remaining_seconds % 60
            time_str = f"{minutes}:{seconds:02d}"

            score_display.style.cssText = """
                background: linear-gradient(135deg, #fef3c7, #fde68a);
                border: 2px solid #f59e0b;
                color: #92400e;
                padding: 20px;
                border-radius: 12px;
                margin-bottom: 24px;
                text-align: center;
            """
            score_display.innerHTML = f"""
                <div style="font-size: 20px; margin-bottom: 8px;">‚è±Ô∏è</div>
                <div style="font-size: 18px; font-weight: 700; margin-bottom: 8px;">Score Update Pending</div>
                <div style="font-size: 14px; margin-bottom: 12px;">
                    Waiting period active to prevent score gaming
                </div>
                <div style="font-size: 24px; font-weight: 700; padding: 12px; background: rgba(255,255,255,0.6); border-radius: 8px;">
                    ‚è≥ Time remaining: <span class="countdown-timer-review" style="color: #d97706;">{time_str}</span>
                </div>
            """
            review_section.appendChild(score_display)

            # Add countdown updater
            countdown_el = score_display.querySelector(".countdown-timer-review")
            remaining_time = [remaining_seconds]

            def update_countdown():
                if remaining_time[0] > 0:
                    remaining_time[0] -= 1
                    mins = remaining_time[0] // 60
                    secs = remaining_time[0] % 60

                    if countdown_el:
                        countdown_el.textContent = f"{mins}:{secs:02d}"

                    window.setTimeout(create_proxy(update_countdown), 1000)
                else:
                    # Timer completed - reload to show score
                    window.console.log("‚è∞ Timer completed - reloading review to show score")
                    window.location.reload()

            window.setTimeout(create_proxy(update_countdown), 1000)
        else:
            # Show actual score
            score_display.style.cssText = """
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 20px;
                border-radius: 12px;
                margin-bottom: 24px;
                text-align: center;
            """
            score_display.innerHTML = f"""
                <div style="font-size: 14px; opacity: 0.9; margin-bottom: 4px;">Overall Score</div>
                <div style="font-size: 48px; font-weight: 700;">{percentage:.1f}%</div>
                <div style="font-size: 14px; opacity: 0.9; margin-top: 4px;">
                    {total_score:.1f} / {max_score:.1f} points
                </div>
            """
            review_section.appendChild(score_display)

        # Add each problem's review
        for prob_idx in sorted(self.problem_states.keys()):
            score_info = problem_scores.get(prob_idx, {'score': 0, 'max_score': 0, 'percentage': 0})
            problem_review = self._create_problem_review(prob_idx, score_info)
            review_section.appendChild(problem_review)

        review_container.appendChild(review_section)

        # Render MathJax for all review content - with delay to ensure DOM is ready
        def render_mathjax_for_review():
            if window.MathJax and window.MathJax.typesetPromise:
                try:
                    window.console.log("üé® Rendering MathJax for review section...")
                    window.MathJax.typesetPromise([review_section]).then(
                        create_proxy(lambda result: window.console.log("‚úÖ MathJax rendered for review section"))
                    ).catch(
                        create_proxy(lambda err: window.console.error(f"‚ùå MathJax error: {err}"))
                    )
                except Exception as e:
                    window.console.error(f"‚ùå Error calling MathJax: {e}")

        # Call MathJax after a short delay to ensure DOM is fully updated
        window.setTimeout(create_proxy(render_mathjax_for_review), 100)

        # Scroll to review
        review_section.scrollIntoView({'behavior': 'smooth', 'block': 'start'})

        window.console.log("‚úÖ Review section displayed")


    def _all_problems_complete(self):
        """Check if ALL problems in the problem set are complete"""
        if not self.problem_states:
            return False

        for prob_idx in self.problem_states.keys():
            if not self.is_problem_complete(prob_idx):
                window.console.log(f"Problem {prob_idx} is not complete yet")
                return False

        return True


    def _create_problem_review(self, prob_idx, score_data):
        """Create review section for a single problem"""
        problem_container = document.createElement("div")
        problem_container.className = "problem-review"
        problem_container.id = f"problemReview_{prob_idx}"
        problem_container.style.cssText = """
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 16px;
            background: #f8fafc;
        """

        # Problem header (without score)
        header = document.createElement("div")
        header.style.cssText = """
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 2px solid #e2e8f0;
        """
        header.innerHTML = f"""
            <div>
                <h3 style="margin: 0; color: #1e293b; font-size: 18px;">Problem {prob_idx + 1}</h3>
            </div>
        """
        problem_container.appendChild(header)

        # Add each step's review
        if prob_idx in self.problem_states:
            for step_idx, step_data in enumerate(self.problem_states[prob_idx]):
                step_review = self._create_step_review(prob_idx, step_idx, step_data)
                problem_container.appendChild(step_review)

        return problem_container


    def _create_step_review(self, prob_idx, step_idx, step_data):
        """Create review display for a single step"""
        step_container = document.createElement("div")
        step_container.className = "step-review"
        step_container.id = f"stepReview_{prob_idx}_{step_idx}"
        step_container.style.cssText = """
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 12px;
        """

        # Step header with edit/review button (no correctness indicator)
        step_header = document.createElement("div")
        step_header.style.cssText = """
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        """

        # Check if this is a read-only step (math-expression or requireCorrect)
        step_type = step_data.get("step_type", "math-expression")
        is_math_expr = step_type == "math-expression" or step_type == "step-by-step"

        # ‚úÖ Check requireCorrect from original problem data
        is_require_correct = False
        if prob_idx < len(self.problem_set):
            problem = self.problem_set[prob_idx]
            original_steps = problem.get("steps", [])
            if step_idx < len(original_steps):
                is_require_correct = original_steps[step_idx].get("requireCorrect", False)

        # Read-only if math-expression OR requireCorrect
        is_readonly = is_math_expr or is_require_correct
        button_label = "üëÅÔ∏è Review" if is_readonly else "‚úèÔ∏è Edit"

        # ‚úÖ Get attempts count
        attempts_count = step_data.get("attempts", 0)

        step_header.innerHTML = f"""
            <div style="display: flex; align-items: center; gap: 12px;">
                <span style="font-weight: 600; color: #475569;">Step {step_idx + 1}</span>
                <span style="background: #f1f5f9; color: #64748b; padding: 4px 8px; border-radius: 4px; font-size: 12px; font-weight: 500;">
                    Attempts: {attempts_count}
                </span>
            </div>
            <button class="edit-step-btn" data-problem="{prob_idx}" data-step="{step_idx}"
                    style="padding: 6px 12px; background: #3b82f6; color: white; border: none;
                           border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 500;">
                {button_label}
            </button>
        """
        step_container.appendChild(step_header)

        # Question text
        question = step_data.get("question", "") or step_data.get("description", "") or step_data.get("text", "")
        if question:
            q_div = document.createElement("div")
            q_div.style.cssText = "margin-bottom: 12px; color: #334155; font-size: 14px;"
            q_div.innerHTML = question
            step_container.appendChild(q_div)

        # User's answer (neutral styling, with MathJax rendering)
        user_answers = step_data.get("user_answers", [])
        answer_div = document.createElement("div")
        answer_div.className = "user-answer-display"
        answer_div.style.cssText = """
            background: #f8fafc;
            border-left: 4px solid #3b82f6;
            padding: 12px;
            border-radius: 6px;
            font-size: 14px;
        """

        if user_answers:
            # Format answer for display with MathJax support
            if len(user_answers) == 1:
                answer_text = self._format_answer_for_display(user_answers[0])
            else:
                formatted_answers = [self._format_answer_for_display(ans) for ans in user_answers]
                answer_text = ", ".join(formatted_answers)

            answer_div.innerHTML = f"""
                <div style="font-weight: 600; color: #475569; margin-bottom: 4px;">Your Answer:</div>
                <div class="mathjax-content" style="color: #1e293b;">{answer_text}</div>
            """
        else:
            answer_div.innerHTML = '<div style="color: #64748b; font-style: italic;">No answer provided</div>'

        step_container.appendChild(answer_div)

        # Add click handler to edit button
        def make_edit_handler(p_idx, s_idx):
            def handler(e):
                self.edit_answer_from_review(p_idx, s_idx)
            return handler

        edit_btn = step_container.querySelector(".edit-step-btn")
        if edit_btn:
            edit_btn.addEventListener("click", create_proxy(make_edit_handler(prob_idx, step_idx)))

        return step_container


    def _format_answer_for_display(self, answer):
        """Format an answer for display with MathJax support"""
        answer_str = str(answer)

        # Check if it looks like LaTeX or math notation
        # Includes: backslashes, curly braces, or matrix notation (double square brackets)
        is_latex = ('\\' in answer_str or
                    ('{' in answer_str and '}' in answer_str) or
                    '[[' in answer_str)

        if is_latex:
            # Convert matrices from [[...]] format to proper LaTeX if needed
            if '[[' in answer_str and '\\begin{' not in answer_str:
                try:
                    # Parse and convert to proper LaTeX
                    parsed = self.math_parser.parse_latex(answer_str)
                    latex_output = self._convert_latex_preserve_order(parsed)
                    # Wrap in display delimiters for MathJax rendering
                    return f"$$\\displaystyle {latex_output}$$"
                except:
                    # Fallback: just wrap as-is
                    return f"\\({answer_str}\\)"
            else:
                # Already LaTeX, just wrap in delimiters for MathJax rendering
                return f"\\({answer_str}\\)"
        else:
            # Plain text, return as is but escape HTML
            import html
            return html.escape(answer_str)


    def _refresh_step_review(self, prob_idx, step_idx):
        """Refresh a single step's review display after editing"""
        window.console.log(f"üîÑ Refreshing step review: problem {prob_idx}, step {step_idx}")

        # Find the existing step review element
        step_review_elem = document.querySelector(f"#stepReview_{prob_idx}_{step_idx}")
        if not step_review_elem:
            window.console.warn(f"‚ö†Ô∏è Step review element not found for {prob_idx}_{step_idx}")
            return

        # Get updated step data from problem_states
        if prob_idx not in self.problem_states or step_idx >= len(self.problem_states[prob_idx]):
            window.console.error(f"‚ùå Step data not found in problem_states")
            return

        step_data = self.problem_states[prob_idx][step_idx]

        # Create new step review
        new_step_review = self._create_step_review(prob_idx, step_idx, step_data)

        # Replace old with new
        step_review_elem.replaceWith(new_step_review)

        # Render MathJax for the new content
        if window.MathJax and window.MathJax.typesetPromise:
            try:
                window.MathJax.typesetPromise([new_step_review]).then(
                    create_proxy(lambda result: window.console.log("‚úÖ MathJax rendered for updated step"))
                ).catch(
                    create_proxy(lambda err: window.console.error(f"‚ùå MathJax error: {err}"))
                )
            except Exception as e:
                window.console.error(f"‚ùå Error calling MathJax: {e}")

        window.console.log(f"‚úÖ Step review refreshed for {prob_idx}_{step_idx}")


    def calculate_total_score(self):
        """Calculate the total score across all problems"""
        total_score = 0
        max_score = 0
        problem_scores = {}

        for prob_idx, steps in self.problem_states.items():
            prob_score = 0
            prob_max = 0

            for step in steps:
                if step.get("finished", False):
                    step_points = step.get("points", 1)
                    prob_max += step_points

                    if step.get("correct", False):
                        prob_score += step_points

            problem_scores[prob_idx] = {
                'score': prob_score,
                'max_score': prob_max,
                'percentage': (prob_score / prob_max * 100) if prob_max > 0 else 0
            }

            total_score += prob_score
            max_score += prob_max

        return total_score, max_score, problem_scores


    def update_score_display_in_review(self, percentage):
      """Update the score display in the review section"""
      score_display = document.querySelector("#overallScoreDisplay")
      if score_display:
          # ‚úÖ FIXED: Get fresh scores
          total_score, max_score, _ = self.calculate_total_score()

          score_display.innerHTML = f"""
              <div style="font-size: 14px; opacity: 0.9; margin-bottom: 4px;">Overall Score</div>
              <div style="font-size: 48px; font-weight: 700;">{percentage:.1f}%</div>
              <div style="font-size: 14px; opacity: 0.9; margin-top: 4px;">
                  {total_score:.1f} / {max_score:.1f} points
              </div>
          """

          window.console.log(f"‚úÖ Score display updated: {percentage:.1f}%")


    def is_problem_complete(self, prob_idx):
        """Check if all steps in a problem are finished"""
        if prob_idx not in self.problem_states:
            return False

        for step in self.problem_states[prob_idx]:
            if not step.get("finished", False):
                return False

        return True


    def count_finished_steps(self, prob_idx):
        """Count how many steps are finished in a problem"""
        if prob_idx not in self.problem_states:
            return 0

        count = 0
        for step in self.problem_states[prob_idx]:
            if step.get("finished", False):
                count += 1

        return count
    # COMPLETE save_answer_from_review() METHOD
    # Integrates: Score tracking, validation, all step types, deferred display

    def save_answer_from_review(self, problem_idx, step_idx):
        """Save the edited answer and return to review - COMPLETE VERSION"""
        window.console.log(f"üíæ Saving edited answer: problem {problem_idx}, step {step_idx}")

        try:
            # ============================================
            # PART 1: VALIDATION - Ensure everything exists
            # ============================================

            # Validate problem state exists
            if problem_idx not in self.solve_states:
                window.console.error("‚ùå No solve_state found")
                window.alert("‚ùå Error: Problem state not found!")
                return

            solve_state = self.solve_states[problem_idx]

            # Validate step index
            if step_idx >= len(solve_state):
                window.console.error(f"‚ùå Invalid step index: {step_idx}")
                window.alert(f"‚ùå Error: Invalid step index {step_idx}")
                return

            step = solve_state[step_idx]
            container = step.get("container")

            if not container:
                window.console.error(f"‚ùå Container not found for step {step_idx}")
                window.alert("‚ùå Error: Step container not found")
                return

            # ‚úÖ Get step_type from solve_state, or fallback to original problem data
            step_type = step.get("step_type", "unknown")

            # If step_type is unknown, try to get it from original problem data
            if step_type == "unknown":
                if problem_idx < len(self.problem_set):
                    problem = self.problem_set[problem_idx]
                    steps = problem.get("steps", [])
                    if step_idx < len(steps):
                        step_type = steps[step_idx].get("step_type", "math-expression")
                        if step_type == "step-by-step":
                            step_type = "math-expression"
                        window.console.log(f"‚úÖ Retrieved step_type from original data: {step_type}")

            window.console.log(f"üìù Step type: {step_type}")

            # ============================================
            # PART 2: CAPTURE ANSWER - Based on step type
            # ============================================

            new_answer = None

            if step_type == "multiple-choice-single":
                window.console.log("üìù Capturing multiple-choice-single answer")
                radio = container.querySelector(f"input[name='mc_single_{step_idx}']:checked")
                if radio:
                    new_answer = [radio.value]
                    window.console.log(f"‚úÖ Captured answer: {new_answer}")
                else:
                    window.console.warn("‚ö†Ô∏è No radio button selected")
                    window.alert("‚ö†Ô∏è Please select an option before saving")
                    return

            elif step_type == "multiple-choice-multiple":
                window.console.log("üìù Capturing multiple-choice-multiple answer")
                checkboxes = container.querySelectorAll(f"input[name='mc_multiple_{step_idx}']:checked")
                if checkboxes.length > 0:
                    new_answer = [checkboxes[i].value for i in range(checkboxes.length)]
                    window.console.log(f"‚úÖ Captured {len(new_answer)} answers: {new_answer}")
                else:
                    window.console.warn("‚ö†Ô∏è No checkboxes selected")
                    window.alert("‚ö†Ô∏è Please select at least one option before saving")
                    return

            elif step_type == "true-false":
                window.console.log("üìù Capturing true-false answer")
                selected = container.querySelector(".tf-btn.selected")
                if selected:
                    value = selected.getAttribute("data-value")
                    new_answer = [value == "true"]
                    window.console.log(f"‚úÖ Captured answer: {new_answer}")
                else:
                    window.console.warn("‚ö†Ô∏è No true/false button selected")
                    window.alert("‚ö†Ô∏è Please select True or False before saving")
                    return

            elif step_type == "fill-blank":
                window.console.log("üìù Capturing fill-blank answer")

                # ‚úÖ Check if this is multi-blank mode
                all_inputs = container.querySelectorAll(".fill-blank-input")
                labeled_inputs = container.querySelectorAll("[data-blank-label]")

                if labeled_inputs.length > 0:
                    # Multi-blank mode: collect answers as dictionary with labels
                    window.console.log(f"üìù Multi-blank mode detected: {labeled_inputs.length} blanks")
                    multi_answers = {}
                    all_filled = True

                    for input_field in labeled_inputs:
                        label = input_field.getAttribute("data-blank-label")
                        value = input_field.value.strip()

                        if value:
                            multi_answers[label] = value
                        else:
                            all_filled = False
                            window.console.warn(f"‚ö†Ô∏è Blank {label} is empty")

                    if not all_filled:
                        window.alert("‚ö†Ô∏è Please fill in all blanks before saving")
                        return

                    if len(multi_answers) == 0:
                        window.alert("‚ö†Ô∏è Please enter answers for all blanks")
                        return

                    new_answer = multi_answers
                    window.console.log(f"‚úÖ Captured multi-blank answers: {new_answer}")

                elif all_inputs.length > 0:
                    # Single-blank mode: collect answer as list
                    window.console.log(f"üìù Single-blank mode detected")
                    input_field = all_inputs[0]
                    value = input_field.value.strip()

                    if not value:
                        window.alert("‚ö†Ô∏è Please fill in the blank before saving")
                        return

                    new_answer = [value]
                    window.console.log(f"‚úÖ Captured single-blank answer: {new_answer}")
                else:
                    window.console.error("‚ùå Fill-blank input not found")
                    window.alert("‚ùå Error: Input field not found")
                    return

            elif step_type in ["freestyle", "math-expression"]:
                window.console.log("üé® Capturing freestyle/math-expression answer")
                # ‚úÖ Use the stored MathQuill instance
                if hasattr(container, 'mq_field') and container.mq_field:
                    try:
                        latex = container.mq_field.latex()
                        if latex and latex.strip():
                            new_answer = [latex]
                            window.console.log(f"‚úÖ Captured LaTeX: {latex}")
                        else:
                            window.console.warn("‚ö†Ô∏è Empty LaTeX captured")
                            window.alert("‚ö†Ô∏è Please enter a mathematical expression before saving")
                            return
                    except Exception as e:
                        window.console.error(f"‚ö†Ô∏è Error capturing LaTeX: {e}")
                        window.alert(f"‚ùå Error capturing answer: {str(e)}")
                        return
                else:
                    window.console.error("‚ùå MathQuill instance not found")
                    window.alert("‚ùå Error: Math field not properly initialized")
                    return

            elif step_type == "multi-mc":
                window.console.log("üìù Capturing multi-mc answer")
                # Get all dropdowns for this step
                dropdowns = container.querySelectorAll(f'.multi-mc-dropdown[data-step-idx="{step_idx}"]')
                if dropdowns.length > 0:
                    # Collect answers as a dictionary {label: value}
                    user_answers = {}
                    all_selected = True
                    for i in range(dropdowns.length):
                        dropdown = dropdowns[i]
                        label = dropdown.getAttribute("data-blank-label")
                        value = dropdown.value
                        if not value or value == "":
                            all_selected = False
                            window.console.warn(f"‚ö†Ô∏è Blank {label} not selected")
                        else:
                            user_answers[label] = value

                    if not all_selected:
                        window.alert("‚ö†Ô∏è Please select an option for all blanks before saving")
                        return

                    # Store as dict in the answer
                    new_answer = user_answers
                    window.console.log(f"‚úÖ Captured multi-mc answers: {new_answer}")
                else:
                    window.console.error("‚ùå No multi-mc dropdowns found")
                    window.alert("‚ùå Error: Dropdowns not found")
                    return

            else:
                window.console.error(f"‚ùå Unknown step type: {step_type}")
                window.alert(f"‚ùå Error: Unknown step type '{step_type}'")
                return

            # ============================================
            # PART 3: VALIDATE ANSWER - Ensure we got something
            # ============================================

            if not new_answer:
                window.alert("‚ö†Ô∏è Please provide an answer before saving")
                window.console.error("‚ùå No answer captured")
                return

            # Filter out empty strings
            if isinstance(new_answer, list):
                new_answer = [ans for ans in new_answer if ans != "" and ans is not None]
                if len(new_answer) == 0:
                    window.alert("‚ö†Ô∏è Please provide a valid answer")
                    window.console.error("‚ùå Answer list is empty after filtering")
                    return

            window.console.log(f"‚úÖ Final validated answer: {new_answer}")

            # ============================================
            # PART 4: UPDATE STATE - Save to problem_states
            # ============================================

            if problem_idx not in self.problem_states:
                window.console.error(f"‚ùå Problem {problem_idx} not found in problem_states")
                window.alert("‚ùå Error: Problem state not found")
                return

            if step_idx >= len(self.problem_states[problem_idx]):
                window.console.error(f"‚ùå Step {step_idx} not found in problem_states")
                window.alert("‚ùå Error: Step state not found")
                return

            # Store old answer for comparison
            old_answer = self.problem_states[problem_idx][step_idx].get("user_answers", [])

            # Check if answer actually changed
            answer_changed = old_answer != new_answer

            # Update with new answer
            self.problem_states[problem_idx][step_idx]["user_answers"] = new_answer

            # ‚úÖ Recalculate correct and score fields based on new answer
            step_data_from_problem_set = self.problem_set[problem_idx]["steps"][step_idx]
            recalculated_score = self.calculate_step_score(step_idx, step_data_from_problem_set, self.problem_states[problem_idx][step_idx])
            recalculated_correct = (recalculated_score >= 100.0)

            self.problem_states[problem_idx][step_idx]["score"] = recalculated_score
            self.problem_states[problem_idx][step_idx]["correct"] = recalculated_correct
            window.console.log(f"‚úÖ Recalculated: score={recalculated_score:.1f}%, correct={recalculated_correct}")

            # ‚úÖ Increment attempts counter if answer changed (edit session = new attempt)
            if answer_changed:
                attempts = self.problem_states[problem_idx][step_idx].get("attempts", 0)
                self.problem_states[problem_idx][step_idx]["attempts"] = attempts + 1
                window.console.log(f"‚úÖ Incremented attempts: {attempts} ‚Üí {attempts + 1} (edit session)")

            window.console.log(f"‚úÖ Updated problem_states[{problem_idx}][{step_idx}]")
            window.console.log(f"   Old answer: {old_answer}")
            window.console.log(f"   New answer: {new_answer}")
            window.console.log(f"   Answer changed: {answer_changed}")

            # ============================================
            # PART 5: TRACK EDIT - For score recalculation
            # ============================================

            self.score_tracker.add_edit(problem_idx, step_idx, new_answer)
            window.console.log("‚úÖ Edit tracked in score_tracker")

            # ============================================
            # PART 6: RECALCULATE SCORE - Always calculate, may not display yet
            # ============================================

            total_score, max_score, problem_scores = self.calculate_total_score()
            if max_score > 0:
                percentage = (total_score / max_score) * 100
            else:
                percentage = 0

            window.console.log(f"üìä Recalculated score: {percentage:.1f}% ({total_score:.1f}/{max_score:.1f})")

            # ============================================
            # PART 7: SCORE DISPLAY LOGIC - Immediate or deferred?
            # ============================================

            # Check if this is a first-time edit for this problem
            is_first_edit_for_problem = problem_idx not in self.score_display_manager["edited_problems"]
            if is_first_edit_for_problem:
                self.score_display_manager["edited_problems"].add(problem_idx)
                window.console.log(f"‚úÖ First edit for problem {problem_idx}")

            # ‚úÖ Update last edit timestamp ONLY on first edit (don't restart timer)
            import js

            # Log current timer state for debugging
            window.console.log(f"üîç Timer state check: pending_score_update={self.score_display_manager['pending_score_update']}, last_edit_time={self.score_display_manager['last_edit_time']}")

            if not self.score_display_manager["pending_score_update"]:
                # No timer running - start a new one
                self.score_display_manager["last_edit_time"] = js.Date.now()
                window.console.log("‚è±Ô∏è Started 5-minute timer (first edit in session)")
            else:
                # Timer already running - preserve the original start time
                if self.score_display_manager["last_edit_time"]:
                    current_time = js.Date.now()
                    elapsed_ms = current_time - self.score_display_manager["last_edit_time"]
                    elapsed_minutes = elapsed_ms / 60000
                    remaining_minutes = 5 - elapsed_minutes
                    window.console.log(f"‚è±Ô∏è Timer already running - NOT restarting (elapsed: {elapsed_minutes:.1f}m, remaining: {remaining_minutes:.1f}m)")
                else:
                    # Fallback: pending_score_update is true but no timestamp (shouldn't happen)
                    window.console.warn("‚ö†Ô∏è pending_score_update=True but no last_edit_time - starting new timer")
                    self.score_display_manager["last_edit_time"] = js.Date.now()

            # ‚úÖ Use score_tracker's first-time step edit count (not problem count)
            first_time_step_edits = len(self.score_tracker.first_time_edits_in_session)
            should_display_now = first_time_step_edits >= 2

            window.console.log(f"üìä Score display check: {first_time_step_edits} first-time step edits")

            if should_display_now:
                window.console.log("‚úÖ Displaying score NOW (2+ first-time step edits)")
                score_to_display = percentage
                should_show_update = True
                # Clear pending update
                self.score_display_manager["pending_score_update"] = False
            else:
                window.console.log(f"‚è≥ Score display deferred (need {2 - first_time_step_edits} more first-time step edit(s) or 5 minutes)")
                # Store as pending
                self.score_display_manager["pending_score_update"] = True
                self.score_display_manager["pending_percentage"] = percentage
                score_to_display = None
                should_show_update = False

            # ============================================
            # PART 8: PERSIST TO STORAGE - Save everything
            # ============================================

            try:
                self.save_to_storage()
                window.console.log("üíæ Progress saved to localStorage")
            except Exception as e:
                window.console.error(f"‚ö†Ô∏è Could not save to localStorage: {e}")
                import traceback
                window.console.error(traceback.format_exc())
                # Don't fail completely if save fails

            # ============================================
            # PART 9: UI FEEDBACK - Show success message
            # ============================================

            self.show_edit_success_message(container)

            # ============================================
            # PART 10: RETURN TO REVIEW - After delay
            # ============================================

            def return_to_review():
                try:
                    # Show appropriate message based on whether answer changed
                    if answer_changed:
                        self.show_notification("‚úÖ Answer Updated!", "success")
                    else:
                        self.show_notification("‚ÑπÔ∏è No changes made (answer is the same)", "info")

                    # Update score display if conditions are met
                    if should_show_update:
                        self.update_score_display_in_review(score_to_display)
                        self.score_tracker.reset()  # ‚úÖ Reset edit tracking after score update
                        self.show_notification("‚ú® Score Updated!", "success")
                        window.console.log("‚úÖ Score display updated immediately")
                    else:
                        # Show deferred message
                        first_time_step_edits = len(self.score_tracker.first_time_edits_in_session)
                        self.show_score_deferred_message(first_time_step_edits)
                        window.console.log(f"‚è≥ Score display deferred (need {2 - first_time_step_edits} more first-time step edit(s))")

                    # Refresh the step review with updated answer
                    self._refresh_step_review(problem_idx, step_idx)
                    window.console.log(f"‚úÖ Step review refreshed for problem {problem_idx}, step {step_idx}")

                    # Return to review section
                    self.cancel_edit_from_review(problem_idx)
                    window.console.log("‚úÖ Returned to review section")

                except Exception as e:
                    window.console.error(f"‚ùå Error returning to review: {e}")
                    import traceback
                    window.console.error(traceback.format_exc())
                    # Try to at least close the edit mode
                    try:
                        self.cancel_edit_from_review(problem_idx)
                    except:
                        pass

            # Delay return to show success message
            window.setTimeout(create_proxy(return_to_review), 1500)

            window.console.log("‚úÖ Save process completed successfully")

        except Exception as e:
            # ============================================
            # ERROR HANDLING - Something went wrong
            # ============================================

            window.console.error(f"‚ùå Error saving answer: {e}")
            import traceback
            error_trace = traceback.format_exc()
            window.console.error(error_trace)

            # Show user-friendly error
            window.alert(f"‚ùå Error saving answer: {str(e)}\n\nPlease try again or refresh the page.")


    # ============================================
    # HELPER METHODS (Add these to your class if not present)
    # ============================================

    def show_notification(self, message, notification_type="success"):
        """
        Show a notification message to the user with flashing effect for errors

        Args:
            message: The message to display
            notification_type: Type of notification - "success", "info", "warning", or "error"
        """
        # Define colors for different notification types
        colors = {
            "success": {
                "bg": "linear-gradient(135deg, #10b981, #059669)",
                "shadow": "rgba(16, 185, 129, 0.3)"
            },
            "info": {
                "bg": "linear-gradient(135deg, #3b82f6, #2563eb)",
                "shadow": "rgba(59, 130, 246, 0.3)"
            },
            "warning": {
                "bg": "linear-gradient(135deg, #f59e0b, #d97706)",
                "shadow": "rgba(245, 158, 11, 0.3)"
            },
            "error": {
                "bg": "linear-gradient(135deg, #ef4444, #dc2626)",
                "shadow": "rgba(239, 68, 68, 0.3)"
            }
        }

        color_scheme = colors.get(notification_type, colors["success"])
        
        # Add flashing class for error notifications
        flash_class = " flash-incorrect" if notification_type == "error" else ""

        notification = document.createElement("div")
        notification.className = flash_class.strip()
        notification.style.cssText = f"""
            position: fixed;
            top: 20px;
            right: 20px;
            background: {color_scheme["bg"]};
            color: white;
            padding: 16px 24px;
            border-radius: 12px;
            box-shadow: 0 4px 12px {color_scheme["shadow"]};
            font-weight: 600;
            z-index: 10000;
            animation: slideIn 0.3s ease-out;
        """
        notification.innerHTML = f"<div>{message}</div>"
        document.body.appendChild(notification)

        def remove_notification():
            notification.remove()
        window.setTimeout(create_proxy(remove_notification), 3000)

    def show_score_update_notification(self, message):
        """Show a notification that the score was updated (deprecated - use show_notification)"""
        self.show_notification(message, "success")

    def show_unified_timer_message(self, remaining_seconds=None, context=""):
        """Unified function to show timer/waiting period message - eliminates duplicates"""
        import js

        review_section = document.querySelector("[id^='reviewSection_']")
        if not review_section:
            return

        # ‚úÖ REMOVE ALL EXISTING TIMER MESSAGES to prevent duplicates
        for class_name in [".score-deferred-msg", ".timer-restored-msg", ".unified-timer-msg"]:
            existing = review_section.querySelector(class_name)
            if existing:
                existing.remove()

        # Calculate remaining time if not provided
        if remaining_seconds is None:
            remaining_seconds = 300  # Default 5 minutes
            if self.score_display_manager.get("last_edit_time"):
                current_time = js.Date.now()
                elapsed_ms = current_time - self.score_display_manager["last_edit_time"]
                elapsed_seconds = elapsed_ms / 1000
                remaining_seconds = max(0, int(300 - elapsed_seconds))

        # Get edit count info
        first_time_count = len(self.score_tracker.first_time_edits_in_session)
        total_edits = len(self.score_tracker.edited_steps)
        needed = max(0, 2 - first_time_count)

        # Format time string
        minutes = remaining_seconds // 60
        seconds = remaining_seconds % 60
        time_str = f"{minutes}:{seconds:02d}"

        # Create unified message
        msg = document.createElement("div")
        msg.className = "unified-timer-msg"
        msg.style.cssText = """
            background: linear-gradient(135deg, #fef3c7, #fde68a);
            border: 2px solid #f59e0b;
            border-radius: 12px;
            padding: 16px 20px;
            margin: 16px 0;
        """

        context_text = f" ({context})" if context else ""

        msg.innerHTML = f"""
            <div style="font-weight: 600; color: #92400e; margin-bottom: 8px;">
                ‚è±Ô∏è Waiting Period Active{context_text}
            </div>
            <div style="font-size: 14px; color: #78350f; margin-bottom: 6px;">
                <strong>{first_time_count}/2</strong> first-time edits made (Total: {total_edits} edits)
            </div>
            <div style="font-size: 14px; color: #78350f; margin-bottom: 8px;">
                Score will update after <strong>{needed} more first-time edit(s)</strong> or when timer completes
            </div>
            <div style="font-size: 16px; color: #92400e; font-weight: 700; text-align: center; padding: 10px; background: rgba(255,255,255,0.6); border-radius: 8px;">
                ‚è≥ Time remaining: <span class="countdown-timer-unified" style="color: #d97706;">{time_str}</span>
            </div>
        """

        review_section.insertBefore(msg, review_section.firstChild)

        # Create countdown timer that updates every second
        countdown_el = msg.querySelector(".countdown-timer-unified")
        remaining_time = [remaining_seconds]

        def update_countdown():
            if remaining_time[0] > 0:
                remaining_time[0] -= 1
                mins = remaining_time[0] // 60
                secs = remaining_time[0] % 60

                if countdown_el:
                    countdown_el.textContent = f"{mins}:{secs:02d}"

                window.setTimeout(create_proxy(update_countdown), 1000)
            else:
                # Timer completed - remove message
                window.console.log("‚è∞ Unified timer completed")
                if msg and msg.parentNode:
                    msg.style.opacity = "0"
                    msg.style.transition = "opacity 0.5s"
                    def final_remove():
                        if msg and msg.parentNode:
                            msg.remove()
                    window.setTimeout(create_proxy(final_remove), 500)

        # Start the countdown
        window.setTimeout(create_proxy(update_countdown), 1000)
        window.console.log(f"‚úÖ Unified timer message displayed: {remaining_seconds}s remaining{context_text}")

    def show_score_deferred_message(self, edited_count):
        """Legacy wrapper - calls unified function"""
        self.show_unified_timer_message(context="after edit")

    def show_edit_success_message(self, container):
        """Show a success message after editing"""
        success_msg = document.createElement("div")
        success_msg.style.cssText = """
            background: #d1fae5;
            color: #065f46;
            padding: 12px;
            border-radius: 6px;
            margin-top: 12px;
            text-align: center;
            font-weight: 600;
        """
        success_msg.textContent = "‚úÖ Answer saved successfully!"
        container.appendChild(success_msg)

        def remove_msg():
            success_msg.remove()
        window.setTimeout(create_proxy(remove_msg), 2000)


    


    # ============================================
    # USAGE NOTES
    # ============================================
    """
    DEPENDENCIES:
    This method requires the following to be present in your class:

    1. self.solve_states - Dict of solve states by problem index
    2. self.problem_states - Dict of problem states by problem index
    3. self.score_tracker - ScoreRecalculationTracker instance
    4. self.score_display_manager - Dict with tracking data
    5. self.calculate_total_score() - Method to calculate scores
    6. self.save_to_storage() - Method to persist data
    7. self.update_score_display_in_review() - Method to update score UI
    8. self.cancel_edit_from_review() - Method to close edit mode

    FEATURES:
    ‚úÖ Handles all step types (MC-single, MC-multiple, T/F, fill-blank, freestyle)
    ‚úÖ Comprehensive validation and error handling
    ‚úÖ Tracks edits for intelligent score recalculation
    ‚úÖ Deferred score display (2-edit rule or 5-minute timer)
    ‚úÖ User-friendly feedback messages
    ‚úÖ Persistent storage
    ‚úÖ Console logging for debugging
    ‚úÖ Graceful error recovery

    STEP TYPES SUPPORTED:
    - "multiple-choice-single"
    - "multiple-choice-multiple"
    - "true-false"
    - "fill-blank"
    - "freestyle"
    - "math-expression"

    ERROR HANDLING:
    - Missing solve_state ‚Üí Alert and return
    - Invalid step index ‚Üí Alert and return
    - No container ‚Üí Alert and return
    - No answer captured ‚Üí Alert and return
    - Empty answer ‚Üí Alert and return
    - Unknown step type ‚Üí Alert and return
    - Storage error ‚Üí Log but continue
    - Return to review error ‚Üí Try fallback

    SCORE DISPLAY LOGIC:
    - Immediate display: When 2+ different problems have been edited
    - Deferred display: When only 1 problem edited (shows timer message)
    - Timer: 5 minutes after edit, score displays automatically

    TESTING:
    1. Test each step type (MC, T/F, fill-blank, freestyle)
    2. Test validation (try submitting empty answers)
    3. Test score display (edit 1 problem, then 2 problems)
    4. Test persistence (save, reload, check data)
    5. Test error handling (remove elements, check alerts)
    """
    
    def start_score_display_timer(self):
        """Check periodically if pending score updates should be displayed"""
        def check_and_display():
            if self.score_display_manager["pending_score_update"]:
                import js
                current_time = js.Date.now()
                last_edit = self.score_display_manager["last_edit_time"]

                if last_edit:
                    elapsed_ms = current_time - last_edit
                    elapsed_minutes = elapsed_ms / 60000

                    if elapsed_minutes >= 5:
                        window.console.log("‚è∞ 5 minutes elapsed, displaying pending score")
                        percentage = self.score_display_manager["pending_percentage"]
                        self.update_score_display_in_review(percentage)
                        self.score_display_manager["pending_score_update"] = False
                        self.score_tracker.reset()  # ‚úÖ Reset edit tracking after 5-minute timer
                        self.show_score_update_notification("‚è∞ Score Updated (5 minutes elapsed)")

            # Check again in 10 seconds
            window.setTimeout(create_proxy(check_and_display), 10000)

        # Start the timer
        window.setTimeout(create_proxy(check_and_display), 10000)
    
    def edit_answer_from_review(self, problem_idx, step_idx):
      """Initiate editing of a specific step from review section"""
      window.console.log("=" * 60)
      window.console.log(f"üîß EDIT ANSWER FROM REVIEW")
      window.console.log(f"   Problem: {problem_idx}, Step: {step_idx}")
      window.console.log("=" * 60)

      # ‚úÖ FIX: Get original step data from problem set FIRST
      if problem_idx >= len(self.problem_set):
          window.console.error(f"‚ùå Invalid problem index: {problem_idx}")
          window.alert("Error: Invalid problem index")
          return

      problem = self.problem_set[problem_idx]
      steps = problem.get("steps", [])

      if step_idx >= len(steps):
          window.console.error(f"‚ùå Invalid step index: {step_idx}")
          window.alert("Error: Invalid step index")
          return

      # ‚úÖ Get the original step data
      original_step_data = steps[step_idx]

      # ‚úÖ Get the step type from original data
      step_type = original_step_data.get("step_type", "math-expression")
      # Handle legacy "step-by-step" type
      if step_type == "step-by-step":
          step_type = "math-expression"

      window.console.log(f"‚úÖ Step type from original data: {step_type}")

      # ‚úÖ Step 1: Hide review section
      review_section = document.querySelector("#reviewSection")
      if review_section:
          review_section.style.display = "none"
          window.console.log("‚úÖ Hidden review section")
      else:
          window.console.warn("‚ö†Ô∏è Review section not found")

      # ‚úÖ Step 2: Get and open problem accordion
      accordion = document.querySelector(f".accordion-problem[data-index='{problem_idx}']")
      if accordion:
          window.console.log(f"‚úÖ Found accordion for problem {problem_idx}")
          if not accordion.classList.contains("open"):
              accordion.classList.add("open")
              window.console.log("‚úÖ Opened accordion")
          else:
              window.console.log("‚ÑπÔ∏è Accordion already open")
      else:
          window.console.error(f"‚ùå Accordion not found for problem {problem_idx}")

      # ‚úÖ Step 3: Get problem body container
      problem_body = document.querySelector(f"#problemBody{problem_idx}")
      if not problem_body:
          window.console.error(f"‚ùå Problem body #{problem_idx} not found in DOM")
          window.alert("Error: Problem container not found")
          return

      window.console.log(f"‚úÖ Found problem body for problem {problem_idx}")
      problem_body.style.display = "block"

      # ‚úÖ Step 4: Set current problem
      self.current_problem_index = problem_idx

      # ‚úÖ Step 5: Ensure solve_state exists with original step data
      if problem_idx not in self.solve_states:
          window.console.log(f"‚ö†Ô∏è solve_state not found, rebuilding from original data...")

          if not self.ensure_solve_state_for_edit(problem_idx):
              window.alert("‚ùå Error: Could not load problem for editing")
              return

      # ‚úÖ Step 6: Create container for this step using original data
      try:
          saved_step = self.problem_states[problem_idx][step_idx]

          # Create step container
          container = document.createElement("div")
          container.id = f"stepContainer{step_idx}"
          container.className = "step-container"
          container.style.cssText = "display:block;margin-bottom:24px;padding:20px;background:#f8fafc;border-radius:12px;border:2px solid #e2e8f0;"

          # Create step header
          step_header = document.createElement("div")
          step_header.style.cssText = "font-size:16px;font-weight:600;color:#1e293b;margin-bottom:16px;"
          step_header.innerHTML = f"üìù Step {step_idx + 1}"
          container.appendChild(step_header)

          # ‚úÖ Create step content based on type from ORIGINAL data
          window.console.log(f"Creating UI for step type: {step_type}")

          if step_type == "multiple-choice-single":
              self._recreate_mc_single_step(container, step_idx, saved_step, original_step_data)
          elif step_type == "multiple-choice-multiple":
              self._recreate_mc_multiple_step(container, step_idx, saved_step, original_step_data)
          elif step_type == "multi-mc":
              self._recreate_multi_mc_step(container, step_idx, saved_step, original_step_data)
          elif step_type == "true-false":
              self._recreate_true_false_step(container, step_idx, saved_step, original_step_data)
          elif step_type == "fill-blank":
              self._recreate_fill_blank_step(container, step_idx, saved_step, original_step_data)
          elif step_type in ["freestyle", "math-expression"]:
              self._recreate_freestyle_step(container, step_idx, saved_step, original_step_data)
          else:
              window.console.error(f"‚ùå Unknown step type: {step_type}")
              error_msg = document.createElement("div")
              error_msg.textContent = f"Unknown step type: {step_type}"
              error_msg.style.cssText = "color:#ef4444;padding:12px;background:#fee2e2;border-radius:6px;"
              container.appendChild(error_msg)

          # Add to body
          problem_body.innerHTML = ""  # Clear existing content

          # ‚úÖ Add problem description if it exists
          problem_description = problem.get("description", [])
          if problem_description and isinstance(problem_description, list):
              desc_html = self.render_content_blocks(problem_description)
              if desc_html.strip():
                  desc_container = document.createElement("div")
                  desc_container.className = "problem-description"
                  desc_container.style.cssText = """
                      background: #f0f9ff;
                      padding: 16px 20px;
                      border-radius: 12px;
                      border-left: 4px solid #3b82f6;
                      margin-bottom: 20px;
                      font-size: 15px;
                      line-height: 1.6;
                      color: #1e293b;
                  """
                  desc_container.innerHTML = f"<div style='font-weight:600;margin-bottom:8px;color:#1e40af;'>üìã Problem Description:</div>{desc_html}"
                  problem_body.appendChild(desc_container)
                  window.console.log("‚úÖ Added problem description to view")

          problem_body.appendChild(container)

          # Store in solve_state
          if problem_idx not in self.solve_states:
              self.solve_states[problem_idx] = []

          # Update or add step to solve_state
          step_state = {
              "container": container,
              "step_type": step_type,
              "step_data": original_step_data,  # ‚úÖ Store original data
              "finished": saved_step.get("finished", True)
          }

          if step_idx < len(self.solve_states[problem_idx]):
              self.solve_states[problem_idx][step_idx] = step_state
          else:
              self.solve_states[problem_idx].append(step_state)

          window.console.log(f"‚úÖ Created container for step {step_idx}")

          # Show the edit UI
          self._show_step_edit_ui(problem_idx, step_idx)

          # Render MathJax for problem description and step content
          if hasattr(window, 'MathJax') and hasattr(window.MathJax, 'typesetPromise'):
              window.console.log("üé® Rendering MathJax for edit mode...")
              window.MathJax.typesetPromise([problem_body]).then(
                  create_proxy(lambda result: window.console.log("‚úÖ MathJax rendered in edit mode"))
              ).catch(
                  create_proxy(lambda e: window.console.error(f"‚ö†Ô∏è MathJax error: {e}"))
              )

      except Exception as e:
          window.console.error(f"‚ùå Error creating step UI: {e}")
          import traceback
          window.console.error(traceback.format_exc())
          window.alert(f"Error loading step: {str(e)}")

    def cancel_edit_from_review(self, problem_idx, show_cancel_message=False):
        """Cancel editing and return to review section"""
        window.console.log(f"‚ùå Canceling edit, returning to review")

        # Show cancellation message if requested
        if show_cancel_message:
            self.show_notification("‚ùå Edit Cancelled", "warning")

        if problem_idx not in self.solve_states:
            window.console.error("‚ùå Problem state not found")
            return

        solve_state = self.solve_states[problem_idx]
        
        # ‚úÖ Hide all step containers and remove edit wrappers
        for i, step in enumerate(solve_state):
            container = step.get("container")
            if container:
                # Remove edit wrapper
                edit_wrapper = container.querySelector(".edit-mode-wrapper")
                if edit_wrapper:
                    edit_wrapper.remove()
                
                # Hide the step container
                container.style.display = "none"
                
                # ‚úÖ Remove the container from DOM to clean up
                container.remove()
        
        # ‚úÖ Clear the solve_state since we're done editing
        del self.solve_states[problem_idx]
        window.console.log(f"üóëÔ∏è Cleared solve_state for problem {problem_idx}")
        
        # ‚úÖ Show the review section again
        review_section = document.querySelector(f"#reviewSection_{problem_idx}")
        if review_section:
            review_section.style.display = "block"
            window.console.log("‚úÖ Review section shown")
            
            # Scroll to review section
            review_section.scrollIntoView({'behavior': 'smooth', 'block': 'start'})
        
        # ‚úÖ Show the completion banner again
        completion_banner = document.querySelector(f"#completionBanner_{problem_idx}")
        if completion_banner:
            completion_banner.style.display = "block"
            window.console.log("‚úÖ Completion banner shown")

    def ensure_solve_state_for_edit(self, problem_idx):
        """Ensure solve_state exists for a completed problem before editing"""
        window.console.log(f"üîß Ensuring solve_state exists for problem {problem_idx}")

        # If solve_state already exists, we're good
        if problem_idx in self.solve_states:
            window.console.log(f"‚úÖ solve_state already exists for problem {problem_idx}")
            return True

        # ‚úÖ Check if we have saved problem_states data
        if problem_idx not in self.problem_states:
            window.console.error(f"‚ùå No saved problem_states for problem {problem_idx}")
            window.alert("‚ùå Error: No saved data for this problem")
            return False

        saved_steps = self.problem_states[problem_idx]
        if not saved_steps or len(saved_steps) == 0:
            window.console.error(f"‚ùå No saved steps for problem {problem_idx}")
            window.alert("‚ùå Error: No steps found for this problem")
            return False

        # ‚úÖ Get the original problem from problem_set
        if problem_idx >= len(self.problem_set):
            window.console.error(f"‚ùå Invalid problem index: {problem_idx}")
            window.alert("‚ùå Error: Invalid problem index")
            return False

        problem = self.problem_set[problem_idx]
        original_steps = problem.get("steps", [])

        if len(original_steps) != len(saved_steps):
            window.console.warn(f"‚ö†Ô∏è Mismatch: {len(original_steps)} original steps vs {len(saved_steps)} saved steps")

        # Get the problem body
        body = document.querySelector(f"#problemBody{problem_idx}")
        if not body:
            window.console.error(f"‚ùå Problem body not found for problem {problem_idx}")
            window.alert("‚ùå Error: Problem container not found")
            return False

        window.console.log(f"üîß Recreating solve_state with {len(saved_steps)} steps from original problem data")

        # Initialize solve_state array
        solve_state = []

        # ‚úÖ Create container for each step using ORIGINAL problem data for step type
        for step_idx, saved_step in enumerate(saved_steps):
            # ‚úÖ Get step type from ORIGINAL problem data, not saved data
            if step_idx < len(original_steps):
                original_step_data = original_steps[step_idx]
                step_type = original_step_data.get("step_type", "math-expression")
                # Handle legacy "step-by-step" type
                if step_type == "step-by-step":
                    step_type = "math-expression"
            else:
                window.console.error(f"‚ùå No original data for step {step_idx}")
                original_step_data = {}
                step_type = "unknown"

            window.console.log(f"üìù Creating step {step_idx} with type: {step_type}")

            # Create step container
            container = document.createElement("div")
            container.id = f"stepContainer{step_idx}"
            container.className = "step-container"
            container.style.cssText = "display:none;margin-bottom:24px;padding:20px;background:#f8fafc;border-radius:12px;border:2px solid #e2e8f0;"

            # Create step header
            step_header = document.createElement("div")
            step_header.style.cssText = "font-size:16px;font-weight:600;color:#1e293b;margin-bottom:16px;"
            step_header.innerHTML = f"üìù Step {step_idx + 1}"
            container.appendChild(step_header)

            # Create step content based on type using ORIGINAL step data
            try:
                if step_type == "multiple-choice-single":
                    self._recreate_mc_single_step(container, step_idx, saved_step, original_step_data)
                elif step_type == "multiple-choice-multiple":
                    self._recreate_mc_multiple_step(container, step_idx, saved_step, original_step_data)
                elif step_type == "multi-mc":
                    self._recreate_multi_mc_step(container, step_idx, saved_step, original_step_data)
                elif step_type == "true-false":
                    self._recreate_true_false_step(container, step_idx, saved_step, original_step_data)
                elif step_type == "fill-blank":
                    self._recreate_fill_blank_step(container, step_idx, saved_step, original_step_data)
                elif step_type in ["freestyle", "math-expression"]:
                    self._recreate_freestyle_step(container, step_idx, saved_step, original_step_data)
                else:
                    window.console.error(f"‚ùå Unknown step type: {step_type}")
                    # Create a generic container anyway
                    error_msg = document.createElement("div")
                    error_msg.textContent = f"Unknown step type: {step_type}"
                    error_msg.style.cssText = "color:#ef4444;padding:12px;"
                    container.appendChild(error_msg)

                window.console.log(f"‚úÖ Created container for step {step_idx}")

            except Exception as e:
                window.console.error(f"‚ùå Error creating step {step_idx}: {e}")
                # Add error message to container
                error_msg = document.createElement("div")
                error_msg.textContent = f"Error creating step: {str(e)}"
                error_msg.style.cssText = "color:#ef4444;padding:12px;background:#fee2e2;border-radius:6px;"
                container.appendChild(error_msg)

            # Add to body
            body.appendChild(container)

            # Store in solve_state
            step_state = {
                "container": container,
                "step_type": step_type,
                "step_data": original_step_data,  # ‚úÖ Store original step data
                "finished": saved_step.get("finished", True)
            }
            solve_state.append(step_state)

        # Store the solve_state
        self.solve_states[problem_idx] = solve_state
        window.console.log(f"‚úÖ solve_state recreated with {len(solve_state)} steps")

        # Render MathJax for all recreated steps
        if hasattr(window, 'MathJax') and hasattr(window.MathJax, 'typesetPromise'):
            window.console.log("üé® Rendering MathJax for recreated steps...")
            window.MathJax.typesetPromise([body]).then(
                create_proxy(lambda result: window.console.log("‚úÖ MathJax rendered for recreated steps"))
            ).catch(
                create_proxy(lambda e: window.console.error(f"‚ö†Ô∏è MathJax error: {e}"))
            )

        return True

    def _show_step_edit_ui(self, problem_idx, step_idx):
        """Show the edit UI for a specific step"""
        window.console.log(f"Showing edit UI for step {step_idx}")

        if problem_idx not in self.solve_states:
            window.console.error("‚ùå No solve_state found")
            window.alert("‚ùå Error: Problem state not found")
            return

        solve_state = self.solve_states[problem_idx]

        if step_idx >= len(solve_state):
            window.console.error(f"‚ùå Invalid step index: {step_idx}")
            window.alert(f"‚ùå Error: Invalid step index {step_idx}")
            return

        # ‚úÖ Hide all steps first
        for i, s in enumerate(solve_state):
            if s.get("container"):
                s["container"].style.display = "none"

        # Hide global history if it exists
        global_history = document.querySelector(f"#globalHistory_{problem_idx}")
        if global_history:
            global_history.style.display = "none"

        step = solve_state[step_idx]
        container = step.get("container")

        if not container:
            window.console.error(f"‚ùå Container not found for step {step_idx}")
            window.alert("‚ùå Error: Step container not found")
            return

        # ‚úÖ Get step_type from solve_state, or fallback to original problem data
        step_type = step.get("step_type", "unknown")

        # If step_type is unknown, try to get it from original problem data
        if step_type == "unknown":
            if problem_idx < len(self.problem_set):
                problem = self.problem_set[problem_idx]
                steps = problem.get("steps", [])
                if step_idx < len(steps):
                    step_type = steps[step_idx].get("step_type", "math-expression")
                    if step_type == "step-by-step":
                        step_type = "math-expression"
                    window.console.log(f"‚úÖ Retrieved step_type from original data: {step_type}")

        window.console.log(f"üìù Step type for editing: {step_type}")

        # ‚úÖ Check requireCorrect from original problem data
        is_require_correct = False
        if problem_idx < len(self.problem_set):
            problem = self.problem_set[problem_idx]
            original_steps = problem.get("steps", [])
            if step_idx < len(original_steps):
                is_require_correct = original_steps[step_idx].get("requireCorrect", False)
                window.console.log(f"‚úÖ requireCorrect: {is_require_correct}")

        # ‚úÖ Show only this step
        container.style.display = "block"
        window.console.log(f"‚úÖ Step container displayed: {step_idx}")

        # ‚úÖ Remove any existing edit wrapper to prevent stacking
        existing_wrapper = container.querySelector(".edit-mode-wrapper")
        if existing_wrapper:
            existing_wrapper.remove()
            window.console.log("üóëÔ∏è Removed existing edit wrapper")

        # ‚úÖ Hide original Submit/Finalize buttons and feedback
        submit_btn = container.querySelector(f"#submitBtn{step_idx}")
        finalize_btn = container.querySelector(f"#finalizeBtn{step_idx}")
        feedback_div = container.querySelector(f"#stepFeedback{current_prob_idx}_{step_idx}")

        if submit_btn:
            submit_btn.style.display = "none"
            window.console.log(f"‚úÖ Hidden submit button for step {step_idx}")
        if finalize_btn:
            finalize_btn.style.display = "none"
            window.console.log(f"‚úÖ Hidden finalize button for step {step_idx}")
        if feedback_div:
            feedback_div.style.display = "none"
            window.console.log(f"‚úÖ Hidden feedback for step {step_idx}")

        # ‚úÖ Remove any "correct/incorrect" styling that might be present
        container.classList.remove("correct-answer", "incorrect-answer")

        # Scroll to it smoothly
        container.scrollIntoView({'behavior': 'smooth', 'block': 'center'})

        # ‚úÖ Check if this is read-only (math-expression OR requireCorrect)
        is_math_expr = step_type in ["freestyle", "math-expression"]
        is_readonly = is_math_expr or is_require_correct

        # Create edit wrapper
        edit_wrapper = document.createElement("div")
        edit_wrapper.className = "edit-mode-wrapper"
        if is_readonly:
            edit_wrapper.style.cssText = "background:#e0f2fe;border:3px solid#0284c7;padding:20px;border-radius:12px;margin-top:16px;animation:slideIn 0.3s ease-out;"
        else:
            edit_wrapper.style.cssText = "background:#fef3c7;border:3px solid #f59e0b;padding:20px;border-radius:12px;margin-top:16px;animation:slideIn 0.3s ease-out;"

        edit_header = document.createElement("div")
        edit_header.style.cssText = "font-size:18px;font-weight:700;margin-bottom:16px;text-align:center;"
        if is_readonly:
            edit_header.style.color = "#0c4a6e"
            edit_header.innerHTML = "üëÅÔ∏è Review Mode - View Only"
        else:
            edit_header.style.color = "#92400e"
            edit_header.innerHTML = "‚úèÔ∏è Editing Mode - Update Your Answer"
        edit_wrapper.appendChild(edit_header)

        # ‚úÖ Handle different step types
        if step_type in ["multiple-choice-single", "multiple-choice-multiple"]:
            if is_require_correct:
                window.console.log(f"üëÅÔ∏è Showing {step_type} in read-only mode (requireCorrect)")

                # Keep radio buttons/checkboxes disabled
                inputs = container.querySelectorAll("input")
                for i in range(inputs.length):
                    inp = inputs[i]
                    inp.disabled = True
                    inp.style.pointerEvents = "none"
                    window.console.log(f"‚úÖ Kept input {i} disabled")

                # Keep option containers disabled
                options = container.querySelectorAll(".mc-option")
                for i in range(options.length):
                    opt = options[i]
                    opt.style.pointerEvents = "none"
                    opt.style.opacity = "0.7"
                    opt.style.cursor = "not-allowed"

                # Show read-only notice
                readonly_notice = document.createElement("div")
                readonly_notice.style.cssText = "background:#dbeafe;border:1px solid #3b82f6;padding:12px;border-radius:6px;margin-bottom:12px;font-size:14px;color:#1e3a8a;"
                readonly_notice.innerHTML = "‚ÑπÔ∏è <strong>Note:</strong> This step requires a correct answer and cannot be edited in review mode. This is a view-only display of your answer."
                edit_wrapper.appendChild(readonly_notice)
            else:
                window.console.log(f"üìù Enabling {step_type} editing")

                # Re-enable radio buttons or checkboxes
                inputs = container.querySelectorAll("input")
                for i in range(inputs.length):
                    inp = inputs[i]
                    inp.disabled = False
                    inp.style.pointerEvents = "auto"
                    window.console.log(f"‚úÖ Enabled input {i}")

                # Re-enable option containers
                options = container.querySelectorAll(".mc-option")
                for i in range(options.length):
                    opt = options[i]
                    opt.style.pointerEvents = "auto"
                    opt.style.opacity = "1"
                    opt.style.cursor = "pointer"
                    # Remove any disabled styling
                    opt.classList.remove("disabled")
        
        elif step_type == "true-false":
            if is_require_correct:
                window.console.log("üëÅÔ∏è Showing true-false in read-only mode (requireCorrect)")

                # Keep true/false buttons disabled
                tf_buttons = container.querySelectorAll(".tf-btn")
                for i in range(tf_buttons.length):
                    btn = tf_buttons[i]
                    btn.style.pointerEvents = "none"
                    btn.style.opacity = "0.7"
                    btn.style.cursor = "not-allowed"
                    btn.disabled = True
                    window.console.log(f"‚úÖ Kept TF button {i} disabled")

                # Show read-only notice
                readonly_notice = document.createElement("div")
                readonly_notice.style.cssText = "background:#dbeafe;border:1px solid #3b82f6;padding:12px;border-radius:6px;margin-bottom:12px;font-size:14px;color:#1e3a8a;"
                readonly_notice.innerHTML = "‚ÑπÔ∏è <strong>Note:</strong> This step requires a correct answer and cannot be edited in review mode. This is a view-only display of your answer."
                edit_wrapper.appendChild(readonly_notice)
            else:
                window.console.log("üìù Enabling true-false editing")

                # Re-enable true/false buttons
                tf_buttons = container.querySelectorAll(".tf-btn")
                for i in range(tf_buttons.length):
                    btn = tf_buttons[i]
                    btn.style.pointerEvents = "auto"
                    btn.style.opacity = "1"
                    btn.style.cursor = "pointer"
                    btn.disabled = False
                    window.console.log(f"‚úÖ Enabled TF button {i}")
        
        elif step_type == "fill-blank":
            # Only disable if requireCorrect AND the step has been finished
            step_finished = step.get("finished", False)
            if is_require_correct and step_finished:
                window.console.log("üëÅÔ∏è Showing fill-blank in read-only mode (requireCorrect + finished)")

                # Check if multi-blank or single-blank
                labeled_inputs = container.querySelectorAll("[data-blank-label]")
                
                if labeled_inputs.length > 0:
                    # Multi-blank mode: disable all labeled inputs
                    window.console.log(f"üëÅÔ∏è Disabling {labeled_inputs.length} multi-blank inputs")
                    for input_field in labeled_inputs:
                        input_field.disabled = True
                        input_field.readOnly = True
                        input_field.style.pointerEvents = "none"
                        input_field.style.opacity = "0.7"
                        input_field.style.backgroundColor = "#f8fafc"
                else:
                    # Single-blank mode: disable the single input
                    window.console.log("üëÅÔ∏è Disabling single-blank input")
                    input_field = container.querySelector(".fill-blank-input")
                    if input_field:
                        input_field.disabled = True
                        input_field.readOnly = True
                        input_field.style.pointerEvents = "none"
                        input_field.style.opacity = "0.7"
                        input_field.style.backgroundColor = "#f8fafc"
                        window.console.log("‚úÖ Kept fill-blank input disabled")

                # Show read-only notice
                readonly_notice = document.createElement("div")
                readonly_notice.style.cssText = "background:#dbeafe;border:1px solid #3b82f6;padding:12px;border-radius:6px;margin-bottom:12px;font-size:14px;color:#1e3a8a;"
                readonly_notice.innerHTML = "‚ÑπÔ∏è <strong>Note:</strong> This step requires a correct answer and cannot be edited in review mode. This is a view-only display of your answer."
                edit_wrapper.appendChild(readonly_notice)
            else:
                window.console.log("üìù Enabling fill-blank editing")

                # Check if multi-blank or single-blank
                labeled_inputs = container.querySelectorAll("[data-blank-label]")
                
                if labeled_inputs.length > 0:
                    # Multi-blank mode: enable all labeled inputs
                    window.console.log(f"üìù Enabling {labeled_inputs.length} multi-blank inputs")
                    for i, input_field in enumerate(labeled_inputs):
                        input_field.disabled = False
                        input_field.readOnly = False
                        input_field.style.pointerEvents = "auto"
                        input_field.style.opacity = "1"
                        input_field.style.backgroundColor = "#ffffff"
                        if i == 0:  # Focus on first input
                            input_field.focus()
                    window.console.log("‚úÖ Enabled all multi-blank inputs")
                else:
                    # Single-blank mode: enable the single input
                    window.console.log("üìù Enabling single-blank input")
                    input_field = container.querySelector(".fill-blank-input")
                    if input_field:
                        input_field.disabled = False
                        input_field.readOnly = False
                        input_field.style.pointerEvents = "auto"
                        input_field.style.opacity = "1"
                        input_field.style.backgroundColor = "#ffffff"
                        input_field.focus()
                        window.console.log("‚úÖ Enabled fill-blank input")
        
        elif step_type in ["freestyle", "math-expression"]:
            window.console.log("üëÅÔ∏è Showing math expression in read-only mode")

            # ‚úÖ Get the stored MathQuill instance and disable it
            if hasattr(container, 'mq_field') and container.mq_field:
                try:
                    # Disable the MathQuill field (make it read-only)
                    container.mq_field.config({'disabled': True})
                    window.console.log("‚úÖ MathQuill field disabled for review")
                except Exception as e:
                    window.console.error(f"‚ö†Ô∏è Could not disable MathQuill: {e}")
            else:
                window.console.warn("‚ö†Ô∏è MathQuill instance not found on container")

            # Make sure the input container is visible but disabled
            input_container = container.querySelector(".math-input-container")
            if input_container:
                input_container.style.pointerEvents = "none"
                input_container.style.opacity = "0.7"
                input_container.style.background = "#f8fafc"

            # Show read-only notice
            readonly_notice = document.createElement("div")
            readonly_notice.style.cssText = "background:#dbeafe;border:1px solid #3b82f6;padding:12px;border-radius:6px;margin-bottom:12px;font-size:14px;color:#1e3a8a;"
            if is_require_correct:
                readonly_notice.innerHTML = "‚ÑπÔ∏è <strong>Note:</strong> This step requires a correct answer and cannot be edited in review mode. This is a view-only display of your answer."
            else:
                readonly_notice.innerHTML = "‚ÑπÔ∏è <strong>Note:</strong> Math expression answers cannot be edited in review mode. This is a view-only display of your answer."
            edit_wrapper.appendChild(readonly_notice)
        
        # Create button container
        button_container = document.createElement("div")
        button_container.style.cssText = "display:flex;gap:12px;margin-top:16px;"

        # ‚úÖ Only show Save button for editable step types (not read-only)
        if not is_readonly:
            # Save button
            save_btn = document.createElement("button")
            save_btn.className = "btn"
            save_btn.style.cssText = "flex:1;background:#10b981;color:white;font-weight:600;padding:12px;border:none;border-radius:8px;cursor:pointer;transition:all 0.2s;"
            save_btn.textContent = "üíæ Save Answer"
            save_btn.onmouseover = create_proxy(lambda e: setattr(e.target.style, 'background', '#059669'))
            save_btn.onmouseout = create_proxy(lambda e: setattr(e.target.style, 'background', '#10b981'))

            def make_save_handler(prob_idx, s_idx):
                def handler(e):
                    self.save_answer_from_review(prob_idx, s_idx)
                return handler

            save_btn.addEventListener("click", create_proxy(make_save_handler(problem_idx, step_idx)))
            button_container.appendChild(save_btn)

        # Cancel button (always show, but different style for read-only)
        cancel_btn = document.createElement("button")
        cancel_btn.className = "btn ghost"
        if is_readonly:
            # For read-only, make Cancel button blue and full width
            cancel_btn.style.cssText = "flex:1;background:#3b82f6;color:white;font-weight:600;padding:12px;border:none;border-radius:8px;cursor:pointer;transition:all 0.2s;"
            cancel_btn.textContent = "‚úñÔ∏è Close"
            cancel_btn.onmouseover = create_proxy(lambda e: setattr(e.target.style, 'background', '#2563eb'))
            cancel_btn.onmouseout = create_proxy(lambda e: setattr(e.target.style, 'background', '#3b82f6'))
        else:
            # For editable, keep red Cancel button
            cancel_btn.style.cssText = "flex:1;background:#ef4444;color:white;font-weight:600;padding:12px;border:none;border-radius:8px;cursor:pointer;transition:all 0.2s;"
            cancel_btn.textContent = "‚ùå Cancel"
            cancel_btn.onmouseover = create_proxy(lambda e: setattr(e.target.style, 'background', '#dc2626'))
            cancel_btn.onmouseout = create_proxy(lambda e: setattr(e.target.style, 'background', '#ef4444'))

        def make_cancel_handler(prob_idx):
            def handler(e):
                self.cancel_edit_from_review(prob_idx, show_cancel_message=False)
            return handler

        cancel_btn.addEventListener("click", create_proxy(make_cancel_handler(problem_idx)))
        button_container.appendChild(cancel_btn)

        edit_wrapper.appendChild(button_container)
        container.appendChild(edit_wrapper)

        window.console.log("‚úÖ Edit UI fully constructed and displayed")

    def _recreate_mc_single_step(self, container, step_idx, saved_step, original_step_data):
        """Recreate a multiple-choice-single step for editing"""
        window.console.log(f"üìù Recreating MC-single step {step_idx}")

        # ‚úÖ Get question from original step data (description blocks)
        desc_blocks = original_step_data.get("description", [])
        question_html = self.render_content_blocks(desc_blocks)
        if not question_html.strip():
            question_html = f"Multiple Choice Question {step_idx + 1}"

        # ‚úÖ Get options from original step data
        options = original_step_data.get("options", [])

        # ‚úÖ Get user's previous answer from saved_step
        user_answer = saved_step.get("user_answers", [])

        window.console.log(f"Question HTML: {question_html[:100]}...")
        window.console.log(f"Options: {options}")

        # If no options, create generic ones
        if not options or len(options) == 0:
            options = ["Option A", "Option B", "Option C", "Option D"]

        # Create question
        q_div = document.createElement("div")
        q_div.style.cssText = "margin-bottom:16px;font-size:15px;color:#334155;line-height:1.6;"
        q_div.innerHTML = question_html
        container.appendChild(q_div)

        # Create options
        for i, option in enumerate(options):
            # Handle both string and dict options
            if isinstance(option, dict):
                # Use label (A, B, C, D) as the value
                opt_value = option.get("label", f"Option_{i}")
                # Render the rich content
                opt_content = option.get("content", [])
                if opt_content and isinstance(opt_content, list):
                    opt_text = self.render_content_blocks(opt_content)
                else:
                    opt_text = str(option.get("label", f"Option {i+1}"))
            else:
                opt_value = option
                opt_text = option

            opt_container = document.createElement("div")
            opt_container.className = "mc-option"
            opt_container.style.cssText = "padding:12px;margin-bottom:8px;border:2px solid #e2e8f0;border-radius:8px;cursor:pointer;transition:all 0.2s;background:white;"

            radio = document.createElement("input")
            radio.type = "radio"
            radio.name = f"mc_single_{step_idx}"
            radio.value = opt_value
            radio.id = f"mc_single_{step_idx}_{i}"
            radio.style.cssText = "cursor:pointer;"

            # Check if this was the user's answer
            if user_answer and opt_value in user_answer:
                radio.checked = True
                opt_container.style.borderColor = "#3b82f6"
                opt_container.style.background = "#eff6ff"

            label = document.createElement("label")
            label.htmlFor = radio.id
            label.style.cssText = "margin-left:8px;cursor:pointer;display:inline-block;width:calc(100% - 24px);"
            label.innerHTML = opt_text  # Use innerHTML to render math
            
            opt_container.appendChild(radio)
            opt_container.appendChild(label)
            
            # Add click handler for visual feedback
            def make_click_handler(opt_cont, r):
                def handler(e):
                    # Deselect all options
                    all_opts = container.querySelectorAll(".mc-option")
                    for j in range(all_opts.length):
                        all_opts[j].style.borderColor = "#e2e8f0"
                        all_opts[j].style.background = "white"
                    # Select this one
                    r.checked = True
                    opt_cont.style.borderColor = "#3b82f6"
                    opt_cont.style.background = "#eff6ff"
                return handler
            
            opt_container.addEventListener("click", create_proxy(make_click_handler(opt_container, radio)))
            container.appendChild(opt_container)

    def _recreate_mc_multiple_step(self, container, step_idx, saved_step, original_step_data):
        """Recreate a multiple-choice-multiple step for editing"""
        window.console.log(f"üìù Recreating MC-multiple step {step_idx}")

        # ‚úÖ Get question from original step data (description blocks)
        desc_blocks = original_step_data.get("description", [])
        question_html = self.render_content_blocks(desc_blocks)
        if not question_html.strip():
            question_html = f"Multiple Choice Question {step_idx + 1} (Select all that apply)"

        # ‚úÖ Get options from original step data
        options = original_step_data.get("options", [])

        # ‚úÖ NEW: Check localStorage for existing shuffle to maintain consistency
        # Get current problem index from saved data
        current_prob_idx = saved_step.get("problem_index", 0)
        shuffle_key = f"mc_multiple_shuffle_{current_prob_idx}_{step_idx}"
        stored_shuffle = window.localStorage.getItem(shuffle_key)

        if stored_shuffle:
            # Reuse existing shuffle to preserve user experience
            import json
            stored_data = json.loads(stored_shuffle)

            # Handle both old format (just labels) and new format (dict with labels and visible_correct)
            if isinstance(stored_data, list):
                # Old format - just labels
                stored_labels = stored_data
            else:
                # New format - dict with labels and visible_correct
                stored_labels = stored_data.get("labels", [])

            options = [opt for opt in options if opt.get("label", "") in stored_labels]
            # Restore original order from stored shuffle
            options.sort(key=lambda opt: stored_labels.index(opt.get("label", "")))
            window.console.log(f"‚ôªÔ∏è  MC-Multiple recreate reusing stored shuffle: {stored_labels}")
        elif len(options) > 3:
            # First time: Apply shuffle algorithm for mc-multiple with >3 options
            # Display (total - 1) options, ensuring at least 2 correct answers are included
            import random
            import json
            correct_answers = set(original_step_data.get("correct_answers", []))

            # Separate correct and incorrect options
            correct_opts = [opt for opt in options if opt.get("label", "") in correct_answers]
            incorrect_opts = [opt for opt in options if opt.get("label", "") not in correct_answers]

            num_correct = len(correct_opts)
            num_to_display = len(options) - 1

            # Ensure at least 2 correct options are included
            if num_correct >= 2:
                # Determine how many correct and incorrect to include
                num_correct_to_include = min(num_correct, max(2, num_to_display - len(incorrect_opts)))
                num_incorrect_to_include = num_to_display - num_correct_to_include

                # Shuffle and select
                random.shuffle(correct_opts)
                random.shuffle(incorrect_opts)

                selected_correct = correct_opts[:num_correct_to_include]
                selected_incorrect = incorrect_opts[:num_incorrect_to_include]

                # Combine and shuffle again for display
                options = selected_correct + selected_incorrect
                random.shuffle(options)

                # Store the shuffled labels AND visible correct answers in localStorage
                shuffled_labels = [opt.get("label", "") for opt in options]
                visible_correct = [opt.get("label", "") for opt in options if opt.get("label", "") in correct_answers]

                shuffle_data = {
                    "labels": shuffled_labels,
                    "visible_correct": visible_correct
                }
                window.localStorage.setItem(shuffle_key, json.dumps(shuffle_data))

                window.console.log(f"üîÄ MC-Multiple recreate shuffle: {len(original_step_data.get('options', []))} ‚Üí {len(options)} options ({len(visible_correct)} correct visible)")

        # ‚úÖ Get user's previous answers from saved_step
        user_answers = saved_step.get("user_answers", [])

        window.console.log(f"Question HTML: {question_html[:100]}...")
        window.console.log(f"Options: {options}")

        if not options or len(options) == 0:
            options = ["Option A", "Option B", "Option C", "Option D"]

        # Create question
        q_div = document.createElement("div")
        q_div.style.cssText = "margin-bottom:16px;font-size:15px;color:#334155;line-height:1.6;"
        q_div.innerHTML = question_html
        container.appendChild(q_div)
        
        # Create hint
        hint = document.createElement("div")
        hint.style.cssText = "font-size:13px;color:#64748b;margin-bottom:12px;font-style:italic;"
        hint.textContent = "‚úì Select all that apply"
        container.appendChild(hint)
        
        # Create options
        for i, option in enumerate(options):
            if isinstance(option, dict):
                # Use label (A, B, C, D) as the value
                opt_value = option.get("label", f"Option_{i}")
                # Render the rich content
                opt_content = option.get("content", [])
                if opt_content and isinstance(opt_content, list):
                    opt_text = self.render_content_blocks(opt_content)
                else:
                    opt_text = str(option.get("label", f"Option {i+1}"))
            else:
                opt_value = option
                opt_text = option

            opt_container = document.createElement("div")
            opt_container.className = "mc-option"
            opt_container.style.cssText = "padding:12px;margin-bottom:8px;border:2px solid #e2e8f0;border-radius:8px;cursor:pointer;background:white;transition:all 0.2s;"

            checkbox = document.createElement("input")
            checkbox.type = "checkbox"
            checkbox.name = f"mc_multiple_{step_idx}"
            checkbox.value = opt_value
            checkbox.id = f"mc_multiple_{step_idx}_{i}"
            checkbox.style.cssText = "cursor:pointer;"

            # Check if this was selected
            if opt_value in user_answers:
                checkbox.checked = True
                opt_container.style.borderColor = "#3b82f6"
                opt_container.style.background = "#eff6ff"

            label = document.createElement("label")
            label.htmlFor = checkbox.id
            label.style.cssText = "margin-left:8px;cursor:pointer;display:inline-block;width:calc(100% - 24px);"
            label.innerHTML = opt_text  # Use innerHTML to render math
            
            opt_container.appendChild(checkbox)
            opt_container.appendChild(label)
            
            # Add click handler
            def make_click_handler(opt_cont, cb):
                def handler(e):
                    # Toggle checkbox
                    if e.target.tagName != "INPUT":  # Only toggle if not clicking the checkbox itself
                        cb.checked = not cb.checked
                    
                    if cb.checked:
                        opt_cont.style.borderColor = "#3b82f6"
                        opt_cont.style.background = "#eff6ff"
                    else:
                        opt_cont.style.borderColor = "#e2e8f0"
                        opt_cont.style.background = "white"
                return handler
            
            opt_container.addEventListener("click", create_proxy(make_click_handler(opt_container, checkbox)))
            container.appendChild(opt_container)

    def _recreate_true_false_step(self, container, step_idx, saved_step, original_step_data):
        """Recreate a true-false step for editing"""
        window.console.log(f"üìù Recreating True/False step {step_idx}")

        # ‚úÖ Get question from original step data (description blocks)
        desc_blocks = original_step_data.get("description", [])
        question_html = self.render_content_blocks(desc_blocks)
        if not question_html.strip():
            question_html = f"True or False Question {step_idx + 1}"

        # ‚úÖ Get user's previous answer from saved_step
        user_answer = saved_step.get("user_answers", [])

        window.console.log(f"Question HTML: {question_html[:100]}...")
        window.console.log(f"User answer: {user_answer}")

        # Create question
        q_div = document.createElement("div")
        q_div.style.cssText = "margin-bottom:16px;font-size:15px;color:#334155;line-height:1.6;"
        q_div.innerHTML = question_html
        container.appendChild(q_div)
        
        # Create button container
        btn_container = document.createElement("div")
        btn_container.style.cssText = "display:flex;gap:12px;margin-top:16px;"
        
        # True button
        true_btn = document.createElement("button")
        true_btn.className = "tf-btn"
        true_btn.setAttribute("data-value", "true")
        true_btn.style.cssText = "flex:1;padding:16px;border:2px solid #e2e8f0;border-radius:8px;background:white;cursor:pointer;font-weight:600;font-size:15px;transition:all 0.2s;"
        true_btn.textContent = "‚úì True"
        
        if user_answer and len(user_answer) > 0 and user_answer[0] == True:
            true_btn.classList.add("selected")
            true_btn.style.borderColor = "#10b981"
            true_btn.style.background = "#d1fae5"
            true_btn.style.color = "#065f46"
        
        # False button
        false_btn = document.createElement("button")
        false_btn.className = "tf-btn"
        false_btn.setAttribute("data-value", "false")
        false_btn.style.cssText = "flex:1;padding:16px;border:2px solid #e2e8f0;border-radius:8px;background:white;cursor:pointer;font-weight:600;font-size:15px;transition:all 0.2s;"
        false_btn.textContent = "‚úó False"
        
        if user_answer and len(user_answer) > 0 and user_answer[0] == False:
            false_btn.classList.add("selected")
            false_btn.style.borderColor = "#ef4444"
            false_btn.style.background = "#fee2e2"
            false_btn.style.color = "#991b1b"
        
        # Add click handlers
        def make_tf_handler(btn, other_btn, is_true):
            def handler(e):
                btn.classList.add("selected")
                if is_true:
                    btn.style.borderColor = "#10b981"
                    btn.style.background = "#d1fae5"
                    btn.style.color = "#065f46"
                else:
                    btn.style.borderColor = "#ef4444"
                    btn.style.background = "#fee2e2"
                    btn.style.color = "#991b1b"
                
                other_btn.classList.remove("selected")
                other_btn.style.borderColor = "#e2e8f0"
                other_btn.style.background = "white"
                other_btn.style.color = "inherit"
            return handler
        
        true_btn.addEventListener("click", create_proxy(make_tf_handler(true_btn, false_btn, True)))
        false_btn.addEventListener("click", create_proxy(make_tf_handler(false_btn, true_btn, False)))
        
        btn_container.appendChild(true_btn)
        btn_container.appendChild(false_btn)
        container.appendChild(btn_container)

    def _recreate_fill_blank_step(self, container, step_idx, saved_step, original_step_data):
      """Recreate a fill-in-the-blank step for editing (handles both single and multi-blank)"""
      window.console.log(f"üìù Recreating Fill-blank step {step_idx}")

      # Use unified method to detect blank mode
      is_multi_blank = self._detect_blank_mode(original_step_data)
      
      correct_answers = original_step_data.get("correct_answers", {})
      user_answers = saved_step.get("user_answers", [])

      window.console.log(f"üìù Fill-blank mode: {'multi' if is_multi_blank else 'single'}")
      window.console.log(f"User answers: {user_answers}")

      if is_multi_blank:
          # Multi-blank mode
          # Get question from description blocks
          desc_blocks = original_step_data.get("description", [])
          question = self.render_content_blocks(desc_blocks)

          # Replace {blank} with ___ for visual display
          question = question.replace("{blank}", "___")

          if not question.strip():
              question = f"Fill in the blanks: Step {step_idx + 1}"

          # Display question
          q_div = document.createElement("div")
          q_div.style.cssText = "margin-bottom:16px;font-size:15px;color:#334155;line-height:1.6;"
          q_div.innerHTML = question
          container.appendChild(q_div)

          # Create input fields for each blank (A, B, C, etc.)
          if isinstance(correct_answers, dict):
              # Sort labels alphabetically
              labels = sorted(correct_answers.keys())

              for label in labels:
                  # Create labeled input section
                  blank_section = document.createElement("div")
                  blank_section.style.cssText = "margin-bottom:12px;"

                  # Label
                  label_elem = document.createElement("div")
                  label_elem.style.cssText = "font-weight:600;color:#0b6efd;margin-bottom:4px;font-size:14px;"
                  label_elem.textContent = f"Blank {label}:"
                  blank_section.appendChild(label_elem)

                  # Input field
                  input_field = document.createElement("input")
                  input_field.type = "text"
                  input_field.className = f"fill-blank-input fill-blank-{label}"
                  input_field.setAttribute("data-blank-label", label)
                  input_field.style.cssText = "border:2px solid #cbd5e1;border-radius:6px;padding:8px 12px;width:100%;font-size:15px;transition:all 0.2s;"
                  input_field.placeholder = f"Enter answer for blank {label}..."

                  # Populate with user's previous answer if exists
                  if isinstance(user_answers, dict) and label in user_answers:
                      input_field.value = user_answers[label]

                  # Add focus styling
                  input_field.addEventListener("focus", create_proxy(lambda e: setattr(e.target.style, 'borderColor', '#3b82f6')))
                  input_field.addEventListener("blur", create_proxy(lambda e: setattr(e.target.style, 'borderColor', '#cbd5e1')))

                  blank_section.appendChild(input_field)
                  container.appendChild(blank_section)
          else:
              # Fallback for unexpected format
              error_div = document.createElement("div")
              error_div.style.cssText = "color:#ef4444;padding:12px;background:#fee2e2;border-radius:6px;"
              error_div.textContent = "‚ö†Ô∏è Error: Invalid multi-blank configuration"
              container.appendChild(error_div)
      else:
          # Single-blank mode
          # Get question from original step data
          question = original_step_data.get("text", "")

          # If no text field, try description blocks
          if not question:
              desc_blocks = original_step_data.get("description", [])
              question = self.render_content_blocks(desc_blocks)

          if not question.strip():
              question = f"Fill in the blank: Step {step_idx + 1}"

          window.console.log(f"Question: {question[:100]}...")

          # Create question with blank
          q_div = document.createElement("div")
          q_div.style.cssText = "margin-bottom:16px;font-size:15px;color:#334155;line-height:1.6;"

          # Replace ___ with input field
          if "___" in question:
              parts = question.split("___")

              span1 = document.createElement("span")
              span1.textContent = parts[0]
              q_div.appendChild(span1)

              input_field = document.createElement("input")
              input_field.type = "text"
              input_field.className = "fill-blank-input"
              input_field.style.cssText = "border:2px solid #cbd5e1;border-radius:6px;padding:8px 12px;min-width:150px;font-size:15px;margin:0 4px;transition:all 0.2s;"
              input_field.placeholder = "Your answer..."

              if user_answers and len(user_answers) > 0:
                  input_field.value = user_answers[0]

              # Add focus styling
              input_field.addEventListener("focus", create_proxy(lambda e: setattr(e.target.style, 'borderColor', '#3b82f6')))
              input_field.addEventListener("blur", create_proxy(lambda e: setattr(e.target.style, 'borderColor', '#cbd5e1')))

              q_div.appendChild(input_field)

              if len(parts) > 1:
                  span2 = document.createElement("span")
                  span2.textContent = parts[1]
                  q_div.appendChild(span2)
          else:
              q_div.innerHTML = question

              # Add input below
              input_field = document.createElement("input")
              input_field.type = "text"
              input_field.className = "fill-blank-input"
              input_field.style.cssText = "border:2px solid #cbd5e1;border-radius:6px;padding:8px 12px;width:100%;font-size:15px;margin-top:12px;transition:all 0.2s;"
              input_field.placeholder = "Your answer..."

              if user_answers and len(user_answers) > 0:
                  input_field.value = user_answers[0]

              # Add focus styling
              input_field.addEventListener("focus", create_proxy(lambda e: setattr(e.target.style, 'borderColor', '#3b82f6')))
              input_field.addEventListener("blur", create_proxy(lambda e: setattr(e.target.style, 'borderColor', '#cbd5e1')))

              container.appendChild(q_div)
              container.appendChild(input_field)
              return

          container.appendChild(q_div)

    def _recreate_multi_mc_step(self, container, step_idx, saved_step, original_step_data):
      """Recreate a multi-mc step for editing with dropdowns"""
      import re

      window.console.log(f"üìù Recreating Multi-MC step {step_idx}")

      # Get description blocks
      desc_blocks = original_step_data.get("description", [])
      desc_html = self.render_content_blocks(desc_blocks)

      # Get blanks and user answers
      blanks = original_step_data.get("blanks", {})
      user_answers = saved_step.get("user_answers", {})

      window.console.log(f"Blanks: {blanks}")
      window.console.log(f"User answers: {user_answers}")

      # Count {blank} placeholders
      blank_count = len(re.findall(r'\{blank\}', desc_html))

      # Replace each {blank} with a dropdown pre-filled with user's answer
      modified_desc = desc_html
      blank_labels = sorted(blanks.keys())

      for i in range(blank_count):
          if i < len(blank_labels):
              label = blank_labels[i]
              blank_data = blanks[label]
              options = blank_data.get("options", [])
              user_answer = user_answers.get(label, "")

              # Build dropdown HTML
              options_html = "<option value=''>--</option>"
              for opt in options:
                  selected = "selected" if opt == user_answer else ""
                  options_html += f"<option value='{opt}' {selected}>{opt}</option>"

              dropdown_html = f"""<select class='multi-mc-dropdown' data-blank-label='{label}' data-step-idx='{step_idx}' style='padding:4px 8px; border:2px solid #0b6efd; border-radius:4px; font-size:14px; background:white;'>{options_html}</select>"""

              # Replace first occurrence of {blank}
              modified_desc = modified_desc.replace('{blank}', dropdown_html, 1)

      # Create div with dropdowns
      q_div = document.createElement("div")
      q_div.style.cssText = "margin-bottom:16px;font-size:16px;color:#334155;line-height:1.8;"
      q_div.innerHTML = modified_desc

      container.appendChild(q_div)

    def _recreate_freestyle_step(self, container, step_idx, saved_step, original_step_data):
      """Recreate a freestyle/math-expression step for editing"""
      window.console.log(f"üìù Recreating Freestyle/Math step {step_idx}")

      # ‚úÖ Get question from original step data (description blocks)
      desc_blocks = original_step_data.get("description", [])
      question_html = self.render_content_blocks(desc_blocks)
      if not question_html.strip():
          question_html = f"Math Expression Step {step_idx + 1}"

      # ‚úÖ Get user's previous answer from saved_step
      user_answer = saved_step.get("user_answers", [])

      window.console.log(f"Question HTML: {question_html[:100]}...")
      window.console.log(f"User answer: {user_answer}")

      # Create question
      q_div = document.createElement("div")
      q_div.style.cssText = "margin-bottom:16px;font-size:15px;color:#334155;line-height:1.6;"
      q_div.innerHTML = question_html
      container.appendChild(q_div)

      # Create math input field container
      input_container = document.createElement("div")
      input_container.className = "math-input-container"
      input_container.style.cssText = "border:2px solid #cbd5e1;border-radius:8px;padding:12px;background:white;margin-top:12px;"

      # ‚úÖ Create span element for MathQuill initialization
      math_field = document.createElement("span")
      math_field.className = "math-input step-answer"
      math_field.style.cssText = "min-height:40px;font-size:16px;display:block;"

      input_container.appendChild(math_field)
      container.appendChild(input_container)

      # ‚úÖ Initialize MathQuill field
      if self.MQ:
          try:
              mq_instance = self.MQ.MathField(math_field)
              # Set previous answer if available
              if user_answer and len(user_answer) > 0:
                  mq_instance.latex(user_answer[0])
                  window.console.log(f"‚úÖ Set previous answer: {user_answer[0]}")
              # Store instance for later access
              container.mq_field = mq_instance
              # Store reference for keyboard toggling
              math_field.mathquill = mq_instance
              # Disable soft keyboard for touch devices (conditionally)
              self.disable_soft_keyboard(mq_instance)
              window.console.log("‚úÖ MathQuill field initialized")

              # ‚úÖ Build and insert minimal keyboard based on expected structure
              expected_structure = original_step_data.get('expected_structure')
              buttons_needed = self.build_minimal_keyboard_from_structure(expected_structure, original_step_data)

              keyboard_html = '<div class="minimal-keyboard" style="margin-top:12px;"><div style="display:grid;grid-template-columns:repeat(5,1fr);gap:4px;padding:8px;background:#f8fafc;border-radius:8px;border:1px solid #e2e8f0;">'
              for btn in buttons_needed:
                  keyboard_html += self.create_keyboard_button_html(btn)
              keyboard_html += '</div></div>'

              keyboard_container = document.createElement("div")
              keyboard_container.innerHTML = keyboard_html
              input_container.appendChild(keyboard_container)

              # Attach event handlers to keyboard buttons
              keyboard_btns = input_container.querySelectorAll(".minimal-keyboard .input-btn")
              for i in range(keyboard_btns.length):
                  btn = keyboard_btns[i]
                  action = btn.getAttribute("data-action")
                  if action:
                      def make_handler(mq, act):
                          def handler(e):
                              e.preventDefault()
                              KeyboardInputHandler.handle_action(mq, act)
                          return handler
                      btn.addEventListener("click", create_proxy(make_handler(mq_instance, action)))

              window.console.log(f"‚úÖ Minimal keyboard created with {len(buttons_needed)} buttons")

          except Exception as e:
              window.console.error(f"‚ùå Error initializing MathQuill: {e}")
              # Fallback: show previous answer as text
              if user_answer and len(user_answer) > 0:
                  prev_answer = document.createElement("div")
                  prev_answer.style.cssText = "margin-top:12px;padding:10px;background:#f1f5f9;border-radius:6px;font-size:14px;color:#475569;"
                  prev_answer.innerHTML = f"<strong>Previous answer:</strong> {user_answer[0]}"
                  container.appendChild(prev_answer)
      else:
          window.console.error("‚ùå MathQuill not available")
          # Show previous answer as text
          if user_answer and len(user_answer) > 0:
              prev_answer = document.createElement("div")
              prev_answer.style.cssText = "margin-top:12px;padding:10px;background:#f1f5f9;border-radius:6px;font-size:14px;color:#475569;"
              prev_answer.innerHTML = f"<strong>Previous answer:</strong> {user_answer[0]}"
              container.appendChild(prev_answer)

    def __init__(self):
        self.problem_set = []
        self.problem_states = {}
        self.current_problem_index = None
        self.current_problem_set_uuid = None
        self.MQ = None

        # ‚úÖ Global history tracking
        self.global_attempt_history = []
        self.problem_global_histories = {}
        self.solve_states = {}  # NEW: {problem_index: solve_state}

        # ‚úÖ Initialize MathParser for expression validation
        self.math_parser = MathParser()

        # ‚úÖ Credit system for freestyle practice
        self.credit_balance = 0
        self.credit_earned_total = 0
        self.credit_spent_total = 0
        self.credit_history = []  # List of credit transactions
        self.freestyle_solved_problems = []  # History of solved problems

        # ‚úÖ Add this line to make the app accessible for button callbacks
        window.problem_solver_app = self
        # ‚úÖ Score recalculation tracker (NEW)

        self.score_display_manager = {
            "last_edit_time": None,
            "edited_problems": set(),
            "pending_score_update": False,
            "pending_percentage": 0
        }
        self.score_tracker = ScoreRecalculationTracker(self)

        # ‚úÖ Time tracking for steps
        # Format: {problem_idx: {step_idx: {"first_attempt_time": seconds, "edit_sessions": [session_times]}}}
        self.step_time_tracking = {}

        # ‚úÖ Keyboard toggle state
        self.is_handheld_device = self.detect_handheld_device()
        self.soft_keyboard_enabled = not self.is_handheld_device  # Big screen: enable soft keyboard by default
        window.console.log(f"üñ•Ô∏è Device detection: handheld={self.is_handheld_device}, soft_keyboard={self.soft_keyboard_enabled}")

    def init(self):
        # Initialize MathQuill
        if hasattr(window, 'MathQuill'):
            self.MQ = window.MathQuill.getInterface(2)
        
        self.setup_events()
        self.load_from_storage()
        self.load_credit_data()  # Load credit system data
        
        overlay = document.querySelector("#loadingOverlay")
        if overlay:
            overlay.style.opacity = "0"
            window.setTimeout(create_proxy(lambda: overlay.remove()), 400)

        # Populate example problem set text
        self.populate_example_text()

        # ‚úÖ ADD THIS NEW LINE:
        self.start_score_display_timer()

    def shuffle_array(self, array):
        """Shuffle an array in place using Fisher-Yates algorithm"""
        import random
        for i in range(len(array) - 1, 0, -1):
            j = random.randint(0, i)
            array[i], array[j] = array[j], array[i]
        return array

    def _detect_blank_mode(self, step_data):
        """
        Unified method to detect if fill-blank is single or multi-blank mode.
        
        This method conforms to the export format from create_problem.html:
        - Single blank: blank_config.mode = "single", correct_answers is a list
        - Multi blank: blank_config.mode = "multi", correct_answers is a dict
        
        Returns:
            bool: True if multi-blank, False if single-blank
        """
        # Priority 1: Check blank_config.mode (most reliable)
        blank_config = step_data.get("blank_config", {})
        blank_mode = blank_config.get("mode", None)
        
        if blank_mode == "multi":
            return True
        elif blank_mode == "single":
            return False
        
        # Priority 2: Fallback to checking correct_answers structure
        # Multi-blank uses dict, single-blank uses list
        correct_answers = step_data.get("correct_answers", {})
        is_multi = isinstance(correct_answers, dict)
        
        # Log the detection for debugging
        window.console.log(f"üîç _detect_blank_mode: mode={blank_mode}, correct_answers type={type(correct_answers).__name__}, is_multi={is_multi}")
        
        return is_multi

    def create_hangman_ui(self, correct_answer, step_idx):
        """Create an interactive hangman UI with a start button"""
        # Convert answer to string and get length
        if isinstance(correct_answer, dict):
            answer_str = correct_answer.get("display", correct_answer.get("value", ""))
        else:
            answer_str = str(correct_answer)

        # Generate unique ID for this hangman instance
        hangman_id = f"hangman_{step_idx}"
        window.console.log(f"üîç create_hangman_ui called: answer={answer_str}, step_idx={step_idx}")
        window.console.log(f"üîç create_hangman_ui: hangman_id = {hangman_id}")

        # Create container with button to start hangman
        hangman_html = f"""
        <div id='{hangman_id}' style='margin-top:16px;padding:12px;background:#f8f9fa;border-radius:8px;'>
            <div style='font-weight:600;margin-bottom:8px;color:#6366f1;'>üí° Hangman Hint:</div>
            <button
                onclick='window.problem_solver_app.start_hangman("{hangman_id}", "{answer_str}")'
                style='padding:8px 16px;background:#6366f1;color:white;border:none;border-radius:6px;cursor:pointer;font-weight:600;'>
                ‚ñ∂ Start Hangman Game
            </button>
            <div id='{hangman_id}_game' style='display:none;margin-top:12px;'></div>
        </div>
        """
        window.console.log(f"üîç create_hangman_ui: returning HTML, length = {len(hangman_html)}")
        return hangman_html

    def toggle_hangman_accordion(self, hangman_id):
        """Toggle accordion visibility for hangman option"""
        content = document.querySelector(f"#accordion_content_{hangman_id}")
        if not content:
            return

        # Toggle display
        if content.style.display == "none":
            content.style.display = "block"
            # Update icon
            accordion_item = document.querySelector(f".hangman-accordion-item[data-hangman-id='{hangman_id}']")
            if accordion_item:
                icon = accordion_item.querySelector(".accordion-icon")
                if icon:
                    icon.innerHTML = "‚ñ≤"
        else:
            content.style.display = "none"
            # Update icon
            accordion_item = document.querySelector(f".hangman-accordion-item[data-hangman-id='{hangman_id}']")
            if accordion_item:
                icon = accordion_item.querySelector(".accordion-icon")
                if icon:
                    icon.innerHTML = "‚ñº"

    def toggle_blank_accordion(self, accordion_id):
        """Toggle accordion visibility for multi-blank"""
        content = document.querySelector(f"#accordion_content_{accordion_id}")
        if not content:
            window.console.log(f"‚ö†Ô∏è Could not find accordion content: {accordion_id}")
            return

        # Toggle display
        if content.style.display == "none":
            content.style.display = "block"
            # Update icon
            accordion_item = document.querySelector(f".blank-accordion-item[data-blank-id='{accordion_id}']")
            if accordion_item:
                icon = accordion_item.querySelector(".accordion-icon")
                if icon:
                    icon.innerHTML = "‚ñ≤"
            window.console.log(f"‚úÖ Opened blank accordion: {accordion_id}")
        else:
            content.style.display = "none"
            # Update icon
            accordion_item = document.querySelector(f".blank-accordion-item[data-blank-id='{accordion_id}']")
            if accordion_item:
                icon = accordion_item.querySelector(".accordion-icon")
                if icon:
                    icon.innerHTML = "‚ñº"
            window.console.log(f"‚úÖ Closed blank accordion: {accordion_id}")

    def start_hangman(self, hangman_id, answer_str):
        """Initialize and start the hangman game"""
        import js

        # Hide the start button
        button = document.querySelector(f"#{hangman_id} button")
        if button:
            button.style.display = "none"

        # Get the game container
        game_container = document.querySelector(f"#{hangman_id}_game")
        if not game_container:
            return

        # Hide all other hangman options in the same group
        # Find the accordion item for this hangman
        accordion_item = document.querySelector(f".hangman-accordion-item[data-hangman-id='{hangman_id}']")
        if accordion_item:
            # Find the parent group
            parent_group = accordion_item.parentElement
            if parent_group and parent_group.classList.contains("hangman-option-group"):
                # Hide all other accordion items in this group
                all_items = parent_group.querySelectorAll(".hangman-accordion-item")
                for i in range(all_items.length):
                    item = all_items[i]
                    item_id = item.getAttribute("data-hangman-id")
                    if item_id != hangman_id:
                        item.style.display = "none"
                        window.console.log(f"üôà Hidden hangman option: {item_id}")

        # Initialize game state
        answer_upper = answer_str.upper()
        guessed_letters = set()
        max_wrong = 6
        wrong_count = 0
        attempt_number = 1
        revealed_letters = set()  # Letters permanently revealed from previous failed attempts

        # Store game state on the element
        game_container.answer = answer_upper
        game_container.guessed = guessed_letters
        game_container.wrong_count = wrong_count
        game_container.max_wrong = max_wrong
        game_container.attempt_number = attempt_number
        game_container.revealed_letters = revealed_letters

        # Show game container
        game_container.style.display = "block"

        # Render initial game state
        self.render_hangman_game(hangman_id)

    def restart_hangman(self, hangman_id):
        """Restart hangman after a failed attempt with revealed letters"""
        game_container = document.querySelector(f"#{hangman_id}_game")
        if not game_container:
            return

        answer = game_container.answer
        revealed_letters = game_container.revealed_letters
        attempt_number = game_container.attempt_number
        guessed = game_container.guessed

        # Calculate which letters to reveal
        all_letters = set(c.upper() for c in answer if c.isalnum())

        # Determine which letters user correctly guessed in this attempt
        correctly_guessed = guessed.intersection(all_letters)

        # Unrevealed = all letters - previously revealed - correctly guessed this time
        unrevealed = all_letters - revealed_letters - correctly_guessed

        # Only reveal more letters if more than 1 letter remains unrevealed
        if len(unrevealed) > 1:
            # Calculate minimum number of letters to reveal (at least 1, max is total - 1)
            num_to_reveal = max(1, len(unrevealed) // 3)  # Reveal ~33% of remaining letters

            # Select letters to reveal (spread across the word)
            letters_to_reveal = self.select_letters_to_reveal(answer, unrevealed, num_to_reveal)
            revealed_letters.update(letters_to_reveal)

            window.console.log(f"üéÆ Attempt {attempt_number + 1}: User correctly guessed {len(correctly_guessed)} letters. Revealed {len(letters_to_reveal)} more letters. Total revealed: {len(revealed_letters)}/{len(all_letters)}")
        else:
            window.console.log(f"üéÆ Attempt {attempt_number + 1}: Only {len(unrevealed)} letter(s) left unrevealed. No more reveals.")

        # Reset game state for new attempt
        game_container.guessed = set()
        game_container.wrong_count = 0
        game_container.attempt_number = attempt_number + 1

        # Render the game
        self.render_hangman_game(hangman_id)

    def select_letters_to_reveal(self, answer, unrevealed_letters, num_to_reveal):
        """Select letters to reveal, spreading them across the word"""
        import random

        # Create a list of positions for each unrevealed letter
        letter_positions = {}
        for i, char in enumerate(answer):
            if char.upper() in unrevealed_letters:
                if char.upper() not in letter_positions:
                    letter_positions[char.upper()] = []
                letter_positions[char.upper()].append(i)

        # Sort letters by their first position to spread reveals across the word
        sorted_letters = sorted(letter_positions.keys(), key=lambda x: letter_positions[x][0])

        # Calculate step size to spread reveals evenly
        if len(sorted_letters) <= num_to_reveal:
            return set(sorted_letters[:-1]) if len(sorted_letters) > 1 else set()

        # Select letters at regular intervals
        step = len(sorted_letters) / num_to_reveal
        selected = set()
        for i in range(num_to_reveal):
            idx = int(i * step)
            selected.add(sorted_letters[idx])

        return selected

    def render_hangman_game(self, hangman_id):
        """Render the current state of the hangman game"""
        game_container = document.querySelector(f"#{hangman_id}_game")
        if not game_container:
            return

        answer = game_container.answer
        guessed = game_container.guessed
        wrong_count = game_container.wrong_count
        max_wrong = game_container.max_wrong
        attempt_number = game_container.attempt_number
        revealed_letters = game_container.revealed_letters

        # Show attempt number if > 1
        display_html = ""
        if attempt_number > 1:
            display_html += f"<div style='color:#6366f1;font-weight:600;margin-bottom:8px;'>üéØ Attempt #{attempt_number}</div>"

        # Build display with blanks, guessed letters, and revealed letters
        display_html += "<div style='font-family:monospace;font-size:20px;letter-spacing:6px;margin-bottom:16px;'>"
        for char in answer:
            if char == ' ':
                display_html += "&nbsp;&nbsp;&nbsp;"
            elif not char.isalnum():
                display_html += f"{char} "
            elif char.upper() in revealed_letters:
                # Permanently revealed letter (shown in blue)
                display_html += f"<span style='color:#3b82f6;font-weight:700;'>{char}</span> "
            elif char.upper() in guessed:
                # Correctly guessed letter (shown in green)
                display_html += f"<span style='color:#10b981;font-weight:700;'>{char}</span> "
            else:
                display_html += "_ "
        display_html += "</div>"

        # Show revealed letters info if any
        if len(revealed_letters) > 0:
            all_letters = set(c.upper() for c in answer if c.isalnum())
            correctly_guessed = guessed.intersection(all_letters)
            unrevealed_count = len(all_letters - revealed_letters - correctly_guessed)
            display_html += f"<div style='color:#6366f1;font-size:14px;margin-bottom:8px;'>üí° {len(revealed_letters)} letter(s) auto-revealed, {len(correctly_guessed)} guessed correctly ({unrevealed_count} remaining)</div>"

        # Wrong guesses counter
        display_html += f"<div style='margin-bottom:12px;'>‚ùå Wrong guesses: {wrong_count}/{max_wrong}</div>"

        # Check if game is won or lost
        all_letters = set(c.upper() for c in answer if c.isalnum())
        # Combine guessed and revealed letters for win check
        all_known = guessed.union(revealed_letters)
        is_won = all_letters.issubset(all_known)
        is_lost = wrong_count >= max_wrong

        if is_won:
            display_html += "<div style='color:#10b981;font-weight:700;font-size:18px;margin-top:12px;'>üéâ You got it!</div>"
        elif is_lost:
            correctly_guessed = guessed.intersection(all_letters)
            unrevealed = all_letters - revealed_letters - correctly_guessed
            if len(unrevealed) > 1:
                # More letters can be revealed
                display_html += f"""
                    <div style='color:#dc2626;font-weight:700;font-size:18px;margin-top:12px;'>
                        üòî Out of guesses! Try again with some letters revealed.
                    </div>
                    <button
                        onclick='window.problem_solver_app.restart_hangman("{hangman_id}")'
                        style='margin-top:12px;padding:10px 20px;background:#6366f1;color:white;border:none;border-radius:6px;cursor:pointer;font-weight:600;font-size:16px;'>
                        üîÑ Try Again (Reveal More Letters)
                    </button>
                """
            else:
                # Only 1 letter left - no more reveals
                display_html += f"""
                    <div style='color:#dc2626;font-weight:700;font-size:18px;margin-top:12px;'>
                        üòî Out of guesses! Only one letter left to find - keep trying!
                    </div>
                    <button
                        onclick='window.problem_solver_app.restart_hangman("{hangman_id}")'
                        style='margin-top:12px;padding:10px 20px;background:#6366f1;color:white;border:none;border-radius:6px;cursor:pointer;font-weight:600;font-size:16px;'>
                        üîÑ Try Again
                    </button>
                """
        else:
            # Create alphabet buttons
            display_html += "<div style='display:flex;flex-wrap:wrap;gap:6px;margin-top:12px;'>"
            alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
            for letter in alphabet:
                if letter in revealed_letters:
                    # Permanently revealed - show as blue disabled
                    display_html += f"<button style='width:36px;height:36px;background:#3b82f6;color:white;border:none;border-radius:4px;font-weight:600;opacity:0.5;cursor:not-allowed;' disabled>{letter}</button>"
                elif letter in guessed:
                    # Already guessed - show as disabled
                    is_correct = letter in all_letters
                    bg_color = "#10b981" if is_correct else "#dc2626"
                    display_html += f"<button style='width:36px;height:36px;background:{bg_color};color:white;border:none;border-radius:4px;font-weight:600;opacity:0.5;cursor:not-allowed;' disabled>{letter}</button>"
                else:
                    # Available to guess
                    display_html += f"<button onclick='window.problem_solver_app.guess_hangman_letter(\"{hangman_id}\", \"{letter}\")' style='width:36px;height:36px;background:#3b82f6;color:white;border:none;border-radius:4px;cursor:pointer;font-weight:600;transition:all 0.2s;' onmouseover='this.style.background=\"#2563eb\"' onmouseout='this.style.background=\"#3b82f6\"'>{letter}</button>"
            display_html += "</div>"

        game_container.innerHTML = display_html

    def guess_hangman_letter(self, hangman_id, letter):
        """Handle a letter guess in hangman"""
        game_container = document.querySelector(f"#{hangman_id}_game")
        if not game_container:
            return

        answer = game_container.answer
        guessed = game_container.guessed
        wrong_count = game_container.wrong_count

        # Add letter to guessed set
        guessed.add(letter)

        # Check if letter is in answer
        if letter not in answer:
            wrong_count += 1
            game_container.wrong_count = wrong_count

        # Re-render game
        self.render_hangman_game(hangman_id)

    def setup_events(self):
        # Navigation
        nav_items = document.querySelectorAll(".nav-item")
        for i in range(nav_items.length):
            item = nav_items[i]
            page = item.getAttribute("data-page")
            
            def make_nav_handler(p):
                def handler(e):
                    self.show_page(p)
                return handler
            
            item.addEventListener("click", create_proxy(make_nav_handler(page)))
        
        # Menu button
        menu_btn = document.querySelector("#menuBtn")
        if menu_btn:
            menu_btn.addEventListener("click", create_proxy(lambda e: self.toggle_sidebar(e)))
        
        overlay = document.querySelector("#sidebarOverlay")
        if overlay:
            overlay.addEventListener("click", create_proxy(lambda e: self.close_sidebar(e)))
        
        # File upload
        upload = document.querySelector("#uploadFile")
        if upload:
            upload.addEventListener("change", create_proxy(lambda e: self.handle_file_upload(e)))
        
        # Load JSON button
        load_json_btn = document.querySelector("#loadJsonBtn")
        if load_json_btn:
            load_json_btn.addEventListener("click", create_proxy(lambda e: self.load_json(e)))
        
        # Export button
        export_btn = document.querySelector("#exportProgressBtn")
        if export_btn:
            export_btn.addEventListener("click", create_proxy(lambda e: self.export_progress(e)))

        # WhatsApp share button
        whatsapp_btn = document.querySelector("#shareWhatsAppBtn")
        if whatsapp_btn:
            whatsapp_btn.addEventListener("click", create_proxy(lambda e: self.share_via_whatsapp(e)))

        # Telegram share button
        telegram_btn = document.querySelector("#shareTelegramBtn")
        if telegram_btn:
            telegram_btn.addEventListener("click", create_proxy(lambda e: self.share_via_telegram(e)))

        # Reset buttons
        reset_all_btn = document.querySelector("#resetAllBtn")
        if reset_all_btn:
            def handle_reset_all(e):
                confirmed = window.confirm(
                    "‚ö†Ô∏è WARNING: This will delete ALL your saved answers and progress!\\n\\n"
                    "This action cannot be undone.\\n\\n"
                    "Are you sure you want to continue?"
                )
                if confirmed:
                    self.reset_all_answers()
            reset_all_btn.addEventListener("click", create_proxy(handle_reset_all))
            window.console.log("‚úÖ Reset All button handler attached")

        reset_current_btn = document.querySelector("#resetCurrentProblemBtn")
        if reset_current_btn:
            def handle_reset_current(e):
                current_prob_idx = self.current_problem_index
                if current_prob_idx is None:
                    window.alert("‚ö†Ô∏è Please open a problem first")
                    return

                confirmed = window.confirm(
                    f"‚ö†Ô∏è This will reset Problem {current_prob_idx + 1}\\n\\n"
                    "All answers and progress for this problem will be deleted.\\n\\n"
                    "Continue?"
                )
                if confirmed:
                    self.reset_current_problem()
            reset_current_btn.addEventListener("click", create_proxy(handle_reset_current))
            window.console.log("‚úÖ Reset Current Problem button handler attached")

        # Tab switching for load page
        tab_buttons = document.querySelectorAll(".load-tab")
        for i in range(tab_buttons.length):
            tab_btn = tab_buttons[i]
            def make_tab_handler(btn):
                def handler(e):
                    self.switch_load_tab(btn.getAttribute("data-tab"))
                return handler
            tab_btn.addEventListener("click", create_proxy(make_tab_handler(tab_btn)))

        # Copy example button
        copy_example_btn = document.querySelector("#copyExampleBtn")
        if copy_example_btn:
            copy_example_btn.addEventListener("click", create_proxy(lambda e: self.copy_example_to_clipboard(e)))

        # Load example button
        load_example_btn = document.querySelector("#loadExampleBtn")
        if load_example_btn:
            load_example_btn.addEventListener("click", create_proxy(lambda e: self.load_example_problem_set(e)))

        # Credit history modal handlers
        show_history_btn = document.querySelector("#showCreditHistory")
        if show_history_btn:
            show_history_btn.addEventListener("click", create_proxy(lambda e: self.show_credit_history_modal(e)))
        
        close_history_btn = document.querySelector("#closeCreditHistory")
        if close_history_btn:
            close_history_btn.addEventListener("click", create_proxy(lambda e: self.close_credit_history_modal(e)))

    # ============================================
    # HELPER METHODS - Button Loading States
    # ============================================

    def set_button_loading(self, button, loading=True):
        """Add or remove loading state from a button"""
        if not button:
            return

        if loading:
            button.classList.add("loading")
            button.disabled = True
        else:
            button.classList.remove("loading")
            button.disabled = False

    # ============================================
    # HELPER METHODS - Step Number Animation
    # ============================================

    def animate_step_number(self, from_step, to_step):
        """Animate step number with slot machine effect"""
        try:
            step_number_el = document.querySelector(".step-number-display")
            if not step_number_el:
                window.console.warn("‚ö†Ô∏è Step number element not found for animation")
                return

            # Create slot effect
            step_number_el.classList.add("step-number-rolling")

            def end_animation():
                step_number_el.textContent = str(to_step + 1)
                step_number_el.classList.remove("step-number-rolling")

            # Update number after animation
            window.setTimeout(create_proxy(end_animation), 600)

            window.console.log(f"üé∞ Animated step number from {from_step + 1} to {to_step + 1}")

        except Exception as e:
            window.console.error(f"‚ùå Error animating step number: {e}")

    # ============================================
    # HELPER METHODS - Time Tracking
    # ============================================

    def start_step_timer(self, problem_idx, step_idx, is_first_attempt=True):
        """Start timing a step"""
        import js

        if problem_idx not in self.step_time_tracking:
            self.step_time_tracking[problem_idx] = {}

        if step_idx not in self.step_time_tracking[problem_idx]:
            self.step_time_tracking[problem_idx][step_idx] = {
                "first_attempt_start": None,
                "first_attempt_time": None,
                "edit_sessions": []
            }

        step_time = self.step_time_tracking[problem_idx][step_idx]

        if is_first_attempt and step_time["first_attempt_start"] is None:
            step_time["first_attempt_start"] = js.Date.now()
            window.console.log(f"‚è±Ô∏è Started timer for problem {problem_idx}, step {step_idx} (first attempt)")
        else:
            # Start a new edit session
            step_time["edit_sessions"].append({"start": js.Date.now(), "end": None})
            window.console.log(f"‚è±Ô∏è Started edit session {len(step_time['edit_sessions'])} for problem {problem_idx}, step {step_idx}")

    def end_step_timer(self, problem_idx, step_idx, is_first_attempt=True):
        """End timing a step and return the elapsed time"""
        import js

        if problem_idx not in self.step_time_tracking:
            return 0

        if step_idx not in self.step_time_tracking[problem_idx]:
            return 0

        step_time = self.step_time_tracking[problem_idx][step_idx]
        elapsed = 0

        if is_first_attempt and step_time["first_attempt_start"] is not None:
            end_time = js.Date.now()
            elapsed = (end_time - step_time["first_attempt_start"]) / 1000  # Convert to seconds
            step_time["first_attempt_time"] = elapsed
            step_time["first_attempt_start"] = None  # Clear start time
            window.console.log(f"‚è±Ô∏è First attempt completed in {elapsed:.1f}s for problem {problem_idx}, step {step_idx}")
        else:
            # End the current edit session
            if step_time["edit_sessions"] and step_time["edit_sessions"][-1]["end"] is None:
                end_time = js.Date.now()
                session = step_time["edit_sessions"][-1]
                elapsed = (end_time - session["start"]) / 1000
                session["end"] = end_time
                session["duration"] = elapsed
                window.console.log(f"‚è±Ô∏è Edit session {len(step_time['edit_sessions'])} completed in {elapsed:.1f}s for problem {problem_idx}, step {step_idx}")

        return elapsed

    def get_current_step_elapsed_time(self, problem_idx, step_idx):
        """Get current elapsed time for a step without stopping the timer"""
        import js

        if problem_idx not in self.step_time_tracking:
            return 0

        if step_idx not in self.step_time_tracking[problem_idx]:
            return 0

        step_time = self.step_time_tracking[problem_idx][step_idx]

        # If timer is currently running (first_attempt_start is set)
        if step_time.get("first_attempt_start") is not None:
            current_time = js.Date.now()
            elapsed = (current_time - step_time["first_attempt_start"]) / 1000  # Convert to seconds
            return elapsed

        # Timer not running, return completed time if any
        return step_time.get("first_attempt_time", 0) or 0

    def get_step_time_summary(self, problem_idx, step_idx):
        """Get a summary of time spent on a step"""
        if problem_idx not in self.step_time_tracking:
            return {"first_attempt": 0, "total_edit_time": 0, "edit_count": 0}

        if step_idx not in self.step_time_tracking[problem_idx]:
            return {"first_attempt": 0, "total_edit_time": 0, "edit_count": 0}

        step_time = self.step_time_tracking[problem_idx][step_idx]

        first_attempt = step_time.get("first_attempt_time", 0) or 0
        total_edit_time = sum(session.get("duration", 0) or 0 for session in step_time.get("edit_sessions", []))
        edit_count = len(step_time.get("edit_sessions", []))

        return {
            "first_attempt": first_attempt,
            "total_edit_time": total_edit_time,
            "edit_count": edit_count,
            "total_time": first_attempt + total_edit_time
        }

    def show_page(self, page_name):
        # Hide all pages
        pages = document.querySelectorAll(".page")
        for i in range(pages.length):
            pages[i].classList.remove("active")
        
        # Show selected page
        target = document.querySelector(f"#{page_name}Page")
        if target:
            target.classList.add("active")
        
        # Update nav
        nav_items = document.querySelectorAll(".nav-item")
        for i in range(nav_items.length):
            nav_items[i].classList.remove("active")
        
        active_nav = document.querySelector(f".nav-item[data-page='{page_name}']")
        if active_nav:
            active_nav.classList.add("active")
        
        if page_name == "freestyle":
          def delayed_init():
              self.ensure_freestyle_initialized()
          window.setTimeout(create_proxy(delayed_init), 100)

        if page_name == "reset":
          def delayed_update():
              self.update_storage_info()
          window.setTimeout(create_proxy(delayed_update), 100)

        self.close_sidebar(None)
    
    def toggle_sidebar(self, event):
        sidebar = document.querySelector("#sidebar")
        overlay = document.querySelector("#sidebarOverlay")
        
        if sidebar:
            is_open = sidebar.classList.contains("open")
            if is_open:
                sidebar.classList.remove("open")
                if overlay:
                    overlay.classList.remove("show")
            else:
                sidebar.classList.add("open")
                if overlay:
                    overlay.classList.add("show")
    
    def close_sidebar(self, event):
        sidebar = document.querySelector("#sidebar")
        overlay = document.querySelector("#sidebarOverlay")
        if sidebar:
            sidebar.classList.remove("open")
        if overlay:
            overlay.classList.remove("show")
    
    def load_json(self, event):
        textarea = document.querySelector("#pasteJson")
        if not textarea:
            window.alert("Paste area not found")
            return
        
        content = textarea.value.strip()
        if not content:
            window.alert("Please paste some data first")
            return
        
        try:
            self.decode_and_load(content)
            textarea.value = ""
        except Exception as e:
            window.console.error(f"Error loading pasted data: {e}")
            window.alert(f"‚ùå Error loading data: {e}")
    
    def handle_file_upload(self, event):
        files = event.target.files
        if files and files.length > 0:
            file = files.item(0)
            from js import FileReader
            reader = FileReader.new()
            
            def on_load(e):
                try:
                    content = e.target.result
                    self.decode_and_load(content)
                    event.target.value = ""
                except Exception as ex:
                    window.console.error(f"Error processing file: {ex}")
                    window.alert(f"‚ùå Error processing file: {ex}")
            
            reader.onload = create_proxy(on_load)
            reader.readAsText(file)
    
    def decode_and_load(self, base64text):
        try:
            import brotli
            
            # Extract base64 if wrapped
            if "===" in base64text:
                import re
                pattern = r"===.*?EXPORT.*?===(.*?)(?:===|$)"
                matches = re.findall(pattern, base64text, re.DOTALL)
                if matches:
                    base64text = re.sub(r"[\s\r\n]+", "", "".join(matches))
            
            # Decode and decompress
            compressed = base64.b64decode(base64text)
            json_text = brotli.decompress(compressed).decode("utf-8")
            data = json.loads(json_text)
            
            # Handle different formats
            if isinstance(data, dict) and "problems" in data:
                problems = data["problems"]
                self.current_problem_set_uuid = data.get("problem_set_id", str(uuid.uuid4()))
                description = data.get("problem_set_description", "")
            else:
                problems = data if isinstance(data, list) else []
                self.current_problem_set_uuid = str(uuid.uuid4())
                description = ""
            
            if not problems:
                raise ValueError("No problems found in data")

            # Clear and set new data
            self.problem_set = problems
            self.problem_states = {}
            self.current_problem_index = None

            # ‚úÖ Clear global attempt history for new problem set
            self.global_attempt_history = []
            self.problem_global_histories = {}
            window.console.log("‚úÖ Global attempt history cleared for new problem set")

            # ‚úÖ FULL RESET of score tracker when new problem set is loaded
            if hasattr(self, 'score_tracker') and self.score_tracker:
                self.score_tracker.full_reset()
                window.console.log("‚úÖ Score tracker fully reset for new problem set")

            # ‚úÖ Clear edit history from localStorage (new session starts)
            window.localStorage.removeItem("score_edits")
            window.localStorage.removeItem("score_tracker_state")
            window.console.log("‚úÖ Edit history and timer state cleared from localStorage (new session)")

            # ‚úÖ Reset score display manager for new problem set
            if hasattr(self, 'score_display_manager'):
                self.score_display_manager["last_edit_time"] = None
                self.score_display_manager["edited_problems"] = set()
                self.score_display_manager["pending_score_update"] = False
                self.score_display_manager["pending_percentage"] = 0
                window.console.log("‚úÖ Score display manager reset for new problem set")

            # Update UI
            self.update_problem_set_info(description)
            self.render_problems()

            window.alert(f"‚úÖ Loaded {len(problems)} problems")
            self.show_page("problems")

            # Save
            def delayed_save():
                self.save_to_storage()
            window.setTimeout(create_proxy(delayed_save), 500)
            
        except Exception as e:
            window.console.error(f"Decode error: {e}")
            import traceback
            window.console.error(traceback.format_exc())
            window.alert(f"‚ùå Failed to load: {e}")

    def switch_load_tab(self, tab_id):
        """Switch between load page tabs"""
        try:
            # Remove active class from all tabs and contents
            all_tabs = document.querySelectorAll(".load-tab")
            all_contents = document.querySelectorAll(".load-tab-content")

            for i in range(all_tabs.length):
                all_tabs[i].classList.remove("active")

            for i in range(all_contents.length):
                all_contents[i].classList.remove("active")

            # Add active class to selected tab and content
            selected_tab = document.querySelector(f'.load-tab[data-tab="{tab_id}"]')
            selected_content = document.querySelector(f'#{tab_id}')

            if selected_tab:
                selected_tab.classList.add("active")

            if selected_content:
                selected_content.classList.add("active")

            window.console.log(f"‚úÖ Switched to tab: {tab_id}")

        except Exception as e:
            window.console.error(f"Error switching tab: {e}")

    def copy_example_to_clipboard(self, event):
        """Copy example problem set base64 to clipboard"""
        try:
            # Get the base64 compressed example directly
            base64_example = self.get_example_problem_set()

            # Use navigator.clipboard if available
            if hasattr(window.navigator, 'clipboard'):
                window.navigator.clipboard.writeText(base64_example)
                window.alert("‚úÖ Base64-compressed example copied to clipboard!\n\nYou can now paste it in the 'Paste JSON' tab.")
            else:
                # Fallback: create a temporary textarea
                temp = document.createElement("textarea")
                temp.value = base64_example
                temp.style.position = "fixed"
                temp.style.opacity = "0"
                document.body.appendChild(temp)
                temp.select()
                document.execCommand('copy')
                document.body.removeChild(temp)
                window.alert("‚úÖ Base64-compressed example copied to clipboard!\n\nYou can now paste it in the 'Paste JSON' tab.")

            window.console.log("‚úÖ Example copied to clipboard")

        except Exception as e:
            window.console.error(f"Error copying to clipboard: {e}")
            window.alert(f"‚ùå Failed to copy: {e}")

    def load_example_problem_set(self, event):
        """Load the example problem set directly"""
        try:
            example_data = self.get_example_problem_set()

            # Use the same decode_and_load method
            self.decode_and_load(example_data)

            window.console.log("‚úÖ Example problem set loaded")

        except Exception as e:
            window.console.error(f"Error loading example: {e}")
            window.alert(f"‚ùå Failed to load example: {e}")

    def get_example_problem_set(self):
        """Return example base64-compressed problem set"""
        # This is a sample problem set with different problem types
        example_json = {
            "problem_set_id": "example-001",
            "problem_set_description": "Example Problem Set - Mathematics Practice",
            "problems": [
                {
                    "title": "Algebra: Solve for x",
                    "description": [
                        {"type": "text", "value": "Solve the equation 2(x + 3) = 12 for x. Show your work by first simplifying the left side, then isolating the variable."}
                    ],
                    "steps": [
                        {
                            "instruction": "Simplify the left side by distributing 2 across (x + 3)",
                            "description": [
                                {"type": "text", "value": "Apply the distributive property: 2(x + 3) = 2¬∑x + 2¬∑3. Write the simplified equation."}
                            ],
                            "expected": "2x+6=12",
                            "type": "math-expression",
                            "expected_structure": {
                                "operators": {"Add": 1, "Mul": 1, "Equality": 1},
                                "operands": {"2": 1, "x": 1, "6": 1, "12": 1}
                            }
                        },
                        {
                            "instruction": "Now solve the equation 2x + 6 = 12 for x",
                            "description": [
                                {"type": "text", "value": "Subtract 6 from both sides, then divide by 2 to isolate x. You can enter the answer as an equation (x=3) or just the value (3)."}
                            ],
                            "expected": "x=3",
                            "type": "math-expression",
                            "expected_structure": {
                                "operators": {"Equality": 1},
                                "operands": {"x": 1, "3": 1}
                            }
                        }
                    ]
                },
                {
                    "title": "Calculus: Find the Derivative",
                    "description": [
                        {"type": "text", "value": "Find the derivative of f(x) = x¬≤ + 3x with respect to x using the power rule."}
                    ],
                    "steps": [
                        {
                            "instruction": "Apply the power rule to find f'(x)",
                            "description": [
                                {"type": "text", "value": "Use the power rule: d/dx(x‚Åø) = n¬∑x‚Åø‚Åª¬π for each term. For x¬≤, the derivative is 2x. For 3x, the derivative is 3."}
                            ],
                            "expected": "2x+3",
                            "type": "math-expression",
                            "expected_structure": {
                                "operators": {"Add": 1, "Mul": 1},
                                "operands": {"2": 1, "x": 1, "3": 1}
                            }
                        }
                    ]
                },
                {
                    "title": "Matrix Addition",
                    "description": [
                        {"type": "text", "value": "Add the two matrices: [[1,2],[3,4]] + [[2,3],[4,5]]. Add corresponding elements."}
                    ],
                    "steps": [
                        {
                            "instruction": "Add the corresponding elements of both matrices",
                            "description": [
                                {"type": "text", "value": "For matrix addition, add each element in position (i,j) from the first matrix with the element at position (i,j) from the second matrix. (1+2=3, 2+3=5, 3+4=7, 4+5=9)"}
                            ],
                            "expected": "[[3,5],[7,9]]",
                            "type": "math-expression",
                            "expected_structure": {
                                "operators": {},
                                "operands": {"3": 1, "5": 1, "7": 1, "9": 1}
                            }
                        }
                    ]
                }
            ]
        }

        # Compress and encode
        import brotli
        json_text = json.dumps(example_json)
        compressed = brotli.compress(json_text.encode("utf-8"))
        base64_text = base64.b64encode(compressed).decode("utf-8")

        return base64_text

    def populate_example_text(self):
        """Populate the example text area with formatted problem set"""
        try:
            textarea = document.querySelector("#exampleFormatText")
            if not textarea:
                return

            # Get the example JSON structure
            example_json = {
                "problem_set_id": "example-001",
                "problem_set_description": "Example Problem Set - Mathematics Practice",
                "problems": [
                    {
                        "title": "Algebra: Solve for x",
                        "description": [
                            {"type": "text", "value": "Solve the equation 2(x + 3) = 12 for x. Show your work by first simplifying the left side, then isolating the variable."}
                        ],
                        "steps": [
                            {
                                "instruction": "Simplify the left side by distributing 2 across (x + 3)",
                                "description": [
                                    {"type": "text", "value": "Apply the distributive property: 2(x + 3) = 2¬∑x + 2¬∑3. Write the simplified equation."}
                                ],
                                "expected": "2x+6=12",
                                "type": "math-expression",
                                "expected_structure": {
                                    "operators": {"Add": 1, "Mul": 1, "Equality": 1},
                                    "operands": {"2": 1, "x": 1, "6": 1, "12": 1}
                                }
                            },
                            {
                                "instruction": "Now solve the equation 2x + 6 = 12 for x",
                                "description": [
                                    {"type": "text", "value": "Subtract 6 from both sides, then divide by 2 to isolate x. You can enter the answer as an equation (x=3) or just the value (3)."}
                                ],
                                "expected": "x=3",
                                "type": "math-expression",
                                "expected_structure": {
                                    "operators": {"Equality": 1},
                                    "operands": {"x": 1, "3": 1}
                                }
                            }
                        ]
                    },
                    {
                        "title": "Calculus: Find the Derivative",
                        "description": [
                            {"type": "text", "value": "Find the derivative of f(x) = x¬≤ + 3x with respect to x using the power rule."}
                        ],
                        "steps": [
                            {
                                "instruction": "Apply the power rule to find f'(x)",
                                "description": [
                                    {"type": "text", "value": "Use the power rule: d/dx(x‚Åø) = n¬∑x‚Åø‚Åª¬π for each term. For x¬≤, the derivative is 2x. For 3x, the derivative is 3."}
                                ],
                                "expected": "2x+3",
                                "type": "math-expression",
                                "expected_structure": {
                                    "operators": {"Add": 1, "Mul": 1},
                                    "operands": {"2": 1, "x": 1, "3": 1}
                                }
                            }
                        ]
                    },
                    {
                        "title": "Matrix Addition",
                        "description": [
                            {"type": "text", "value": "Add the two matrices: [[1,2],[3,4]] + [[2,3],[4,5]]. Add corresponding elements."}
                        ],
                        "steps": [
                            {
                                "instruction": "Add the corresponding elements of both matrices",
                                "description": [
                                    {"type": "text", "value": "For matrix addition, add each element in position (i,j) from the first matrix with the element at position (i,j) from the second matrix. (1+2=3, 2+3=5, 3+4=7, 4+5=9)"}
                                ],
                                "expected": "[[3,5],[7,9]]",
                                "type": "math-expression",
                                "expected_structure": {
                                    "operators": {},
                                    "operands": {"3": 1, "5": 1, "7": 1, "9": 1}
                                }
                            }
                        ]
                    }
                ]
            }

            # Convert to formatted JSON string
            json_text = json.dumps(example_json, indent=2)

            # Compress with Brotli and encode to base64
            import brotli
            compressed = brotli.compress(json_text.encode("utf-8"))
            base64_text = base64.b64encode(compressed).decode("utf-8")

            # Create a readable formatted text showing all three formats
            formatted_text = f"""‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üìù EXAMPLE PROBLEM SET - THREE FORMATS
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üìö SECTION 1: FORMATTED TEXT DESCRIPTION
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Problem Set ID: example-001
Description: Example Problem Set - Mathematics Practice

PROBLEM 1: Algebra: Solve for x
  Description: Solve the equation 2(x + 3) = 12 for x. Show your work by first
               simplifying the left side, then isolating the variable.

  Step 1:
    Instruction: Simplify the left side by distributing 2 across (x + 3)
    Description: Apply the distributive property: 2(x + 3) = 2¬∑x + 2¬∑3.
                 Write the simplified equation.
    Expected Answer: 2x+6=12
    Type: math-expression

  Step 2:
    Instruction: Now solve the equation 2x + 6 = 12 for x
    Description: Subtract 6 from both sides, then divide by 2 to isolate x.
                 You can enter the answer as an equation (x=3) or just the value (3).
    Expected Answer: x=3
    Type: math-expression

PROBLEM 2: Calculus: Find the Derivative
  Description: Find the derivative of f(x) = x¬≤ + 3x with respect to x using
               the power rule.

  Step 1:
    Instruction: Apply the power rule to find f'(x)
    Description: Use the power rule: d/dx(x‚Åø) = n¬∑x‚Åø‚Åª¬π for each term. For x¬≤,
                 the derivative is 2x. For 3x, the derivative is 3.
    Expected Answer: 2x+3
    Type: math-expression

PROBLEM 3: Matrix Addition
  Description: Add the two matrices: [[1,2],[3,4]] + [[2,3],[4,5]]. Add
               corresponding elements.

  Step 1:
    Instruction: Add the corresponding elements of both matrices
    Description: For matrix addition, add each element in position (i,j) from
                 the first matrix with the element at position (i,j) from the
                 second matrix. (1+2=3, 2+3=5, 3+4=7, 4+5=9)
    Expected Answer: [[3,5],[7,9]]
    Type: math-expression

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üìã SECTION 2: JSON FORMAT (Before Compression)
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

{json_text}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üóúÔ∏è SECTION 3: BROTLI-COMPRESSED BASE64 (Final Format)
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

This is what you paste in the "Paste JSON" tab:

{base64_text}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üí° HOW TO USE THIS
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Method 1: Copy the compressed base64 text above
  1. Copy the base64 text from Section 3
  2. Go to "Paste JSON" tab
  3. Paste and click "Load Problem Set"

Method 2: Use the button
  ‚Ä¢ Click "Load This Example" button below to load directly!

Method 3: Create your own
  1. Edit the JSON in Section 2 with your own problems
  2. Compress it using Brotli: brotli.compress(json.encode('utf-8'))
  3. Encode to base64: base64.b64encode(compressed)
  4. Paste the result in "Paste JSON" tab

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚úÖ WHAT'S INCLUDED
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Each problem includes:
  ‚úì Problem title
  ‚úì Problem description (what to solve)
  ‚úì Step instruction (what to do in this step)
  ‚úì Step description (detailed explanation)
  ‚úì Expected answer
  ‚úì Expected structure (for minimal keyboard generation)

This demonstrates the complete format for creating your own problem sets!
"""

            textarea.value = formatted_text
            window.console.log("‚úÖ Example text populated")

        except Exception as e:
            window.console.error(f"Error populating example text: {e}")

    def update_problem_set_info(self, description):
        info_panel = document.querySelector("#problemSetInfo")
        desc_el = document.querySelector("#currentProblemSetDescription")
        uuid_el = document.querySelector("#currentProblemSetUuid")
        
        if self.problem_set:
            info_panel.style.display = "block"
            desc_el.textContent = description or "No description"
            uuid_el.textContent = self.current_problem_set_uuid
        else:
            info_panel.style.display = "none"
    
    def render_problems(self):
      """Render problem list with completion status"""
      container = document.querySelector("#solveProblemsContainer")
      if not container:
          return
      container.innerHTML = ""

      # Hide initial panel
      initial_panel = document.querySelector("#initialLoadPanel")
      if initial_panel:
          initial_panel.style.display = "none"

      for idx, prob in enumerate(self.problem_set):
          title = prob.get("title", f"Problem {idx+1}")
          steps = prob.get("steps", [])
          total = len(steps)

          prob_state = self.problem_states.get(idx, [])
          finished = sum(1 for s in prob_state if s.get("finished", False))
          is_done = finished == total and total > 0

          accordion = document.createElement("div")
          accordion.className = "accordion-problem"
          accordion.setAttribute("data-index", idx)

          if is_done:
              accordion.classList.add("finished")

          header = document.createElement("div")
          header.className = "accordion-header"

          # Different header content for completed vs incomplete
          if is_done:
              # ‚úÖ Count must-not-be-correct questions (where must_correct is False)
              non_math_count = 0
              for step in steps:
                  if step.get("requireCorrect") == False:
                      non_math_count += 1

              # Completed problem - show completion message
              if non_math_count > 0:
                  # Has non-math questions - display the count
                  header.innerHTML = f"""
                  <span>{idx+1}. {html.escape(title)}</span>
                  <span class='progress-summary' style='color:#059669;display:flex;align-items:center;gap:8px;'>
                      <span style='font-size:20px;'>üéâ</span>
                      <span style='font-weight:700;'>Completed! (non-math: {non_math_count})</span>
                  </span>
                  """
              else:
                  # All questions require correct answers
                  header.innerHTML = f"""
                  <span>{idx+1}. {html.escape(title)}</span>
                  <span class='progress-summary' style='color:#059669;display:flex;align-items:center;gap:8px;'>
                      <span style='font-size:20px;'>üéâ</span>
                      <span style='font-weight:700;'>Completed!</span>
                  </span>
                  """
              header.style.background = "#f0fdf4"
          else:
              # Incomplete problem - show progress
              progress_color = "#6b7280"
              header.innerHTML = f"""
              <span>{idx+1}. {html.escape(title)}</span>
              <span class='progress-summary' style='color:{progress_color}'>‚úÖ {finished}/{total} completed</span>
              """
              header.style.background = "#f0f4ff"

          header.style.transition = "background 0.2s ease"
          header.style.fontSize = "16px"
          header.style.minHeight = "60px"
          header.style.padding = "16px"
          header.style.fontWeight = "700"
          header.style.cursor = "pointer"
          header.style.display = "flex"
          header.style.justifyContent = "space-between"
          header.style.alignItems = "center"

          def make_hover_handler(h, done):
              def on_hover(e):
                  if done:
                      h.style.background = "#dcfce7"
                  else:
                      h.style.background = "#dbeafe"
              def off_hover(e):
                  if done:
                      h.style.background = "#f0fdf4"
                  else:
                      h.style.background = "#f0f4ff"
              return on_hover, off_hover

          on_h, off_h = make_hover_handler(header, is_done)
          header.addEventListener("mouseenter", create_proxy(on_h))
          header.addEventListener("mouseleave", create_proxy(off_h))

          body = document.createElement("div")
          body.className = "accordion-body"
          body.id = f"problemBody{idx}"

          accordion.appendChild(header)
          accordion.appendChild(body)
          container.appendChild(accordion)

          def make_toggle_handler(i):
              def handler(e):
                  self.toggle_problem(i)
              return handler

          header.addEventListener("click", create_proxy(make_toggle_handler(idx)))

      # ‚úÖ Check if all problems are completed and show banner
      # ‚úÖ Check if all problems are completed and show banner
      # ‚úÖ Check if all problems are completed and show REVIEW SECTION
      def check_and_show_all_complete():
          window.console.log("=" * 80)
          window.console.log("üîç CHECKING COMPLETION STATUS ON LOAD")
          window.console.log("=" * 80)

          # Debug: Check problem_states
          window.console.log(f"Total problems in problem_set: {len(self.problem_set)}")
          window.console.log(f"Total problems in problem_states: {len(self.problem_states)}")

          # Check each problem individually
          for prob_idx in range(len(self.problem_set)):
              problem = self.problem_set[prob_idx]
              steps = problem.get("steps", [])
              total_steps = len(steps)

              window.console.log(f"\nProblem {prob_idx}: {total_steps} total steps")

              if prob_idx in self.problem_states:
                  saved_steps = self.problem_states[prob_idx]
                  window.console.log(f"  Saved state: {len(saved_steps)} steps")

                  finished_count = 0
                  for step_idx, step_state in enumerate(saved_steps):
                      is_finished = step_state.get("finished", False)
                      is_correct = step_state.get("correct", False)
                      window.console.log(f"    Step {step_idx}: finished={is_finished}, correct={is_correct}")
                      if is_finished:
                          finished_count += 1

                  window.console.log(f"  Result: {finished_count}/{total_steps} finished")

                  is_complete = self.is_problem_complete(prob_idx)
                  window.console.log(f"  is_problem_complete() returns: {is_complete}")
              else:
                  window.console.log(f"  ‚ùå No saved state found!")

          # Now check overall completion
          window.console.log("\n" + "=" * 80)
          all_completed = self.check_all_problems_completion()
          window.console.log(f"check_all_problems_completion() returns: {all_completed}")

          all_completed_v2 = self._all_problems_complete()
          window.console.log(f"_all_problems_complete() returns: {all_completed_v2}")
          window.console.log("=" * 80)

          if all_completed_v2:
              window.console.log("‚úÖ ALL COMPLETE - Showing review section in 500ms...")
              # ‚úÖ Show the actual review section with scores
              def show_review_delayed():
                  window.console.log("üìä Calling show_review_section() now...")
                  self.show_review_section()
                  window.console.log("‚úÖ show_review_section() completed")
              window.setTimeout(create_proxy(show_review_delayed), 500)
          else:
              window.console.log("‚è≥ NOT ALL COMPLETE - Opening first incomplete problem")
              # Not all complete - auto-open first incomplete problem
              first_incomplete = self.find_first_incomplete_problem()
              window.console.log(f"First incomplete problem: {first_incomplete}")
              if first_incomplete is not None:
                  def auto_open():
                      self.toggle_problem(first_incomplete)
                  window.setTimeout(create_proxy(auto_open), 100)
                  window.console.log(f"‚úÖ Auto-opening first incomplete problem: {first_incomplete}")

      # Delay the check slightly to ensure DOM is ready
      window.setTimeout(create_proxy(check_and_show_all_complete), 200)
    
    def toggle_problem(self, index):
      """Toggle problem accordion open/close"""
      # Prevent recursive calls
      if hasattr(self, '_toggling') and self._toggling:
          window.console.warn("‚ö†Ô∏è Already toggling, skipping...")
          return

      self._toggling = True

      try:
          acc = document.querySelector(f".accordion-problem[data-index='{index}']")
          if not acc:
              self._toggling = False
              return

          # Close if already open
          if acc.classList.contains("open"):
              # ‚úÖ Save global history before closing
              if self.current_problem_index is not None:
                  self.save_global_history_state(self.current_problem_index)
              acc.classList.remove("open")
              self._toggling = False
              return

          # ‚úÖ Save current problem's history before switching
          if self.current_problem_index is not None and self.current_problem_index != index:
              window.console.log(f"Saving global history for problem {self.current_problem_index} before switching")
              self.save_global_history_state(self.current_problem_index)

          # Close all
          accordions = document.querySelectorAll(".accordion-problem")
          for i in range(accordions.length):
              accordions[i].classList.remove("open")

          # Open selected
          acc.classList.add("open")
          body = acc.querySelector(".accordion-body")

          if not body:
              self._toggling = False
              return

          # ‚úÖ NEW: Check if problem is complete BEFORE checking if loaded
          is_complete = self.check_problem_completion(index)
          is_first_load = not body.getAttribute("data-loaded")

          if is_complete:
              # ‚úÖ COMPLETED PROBLEM: Always reload to show completion banner
              window.console.log(f"‚úÖ Problem {index} is complete, reloading completion view")
              self.current_problem_index = index
              body.innerHTML = ""  # Clear old content
              self.load_problem(index, body)  # Reload (will show banner only)
              body.setAttribute("data-loaded", "true")

          elif is_first_load:
              # ‚úÖ INCOMPLETE PROBLEM: First load
              window.console.log(f"üìÇ First time loading problem {index}")
              self.current_problem_index = index
              self.load_problem(index, body)
              body.setAttribute("data-loaded", "true")

          else:
              # ‚úÖ INCOMPLETE PROBLEM: Reopening
              window.console.log(f"üìÇ Reopening incomplete problem {index}")
              self.current_problem_index = index

              # ‚úÖ Restore solve_state if available
              if index in self.solve_states:
                  self.solve_state = self.solve_states[index]
                  window.console.log(f"‚úÖ Restored solve_state with {len(self.solve_state)} steps")
              else:
                  window.console.warn(f"‚ö†Ô∏è No solve_state found, using current state")
                
              # Show first unfinished step
              first_unfinished = self.find_first_unfinished_step(index)
              if first_unfinished is not None and hasattr(self, 'solve_state'):
                  # Hide all steps
                  for i, step in enumerate(self.solve_state):
                      step["container"].style.display = "none"
                      step["container"].classList.remove("active")

                  # Show first unfinished
                  self.solve_state[first_unfinished]["container"].style.display = "block"
                  self.solve_state[first_unfinished]["container"].classList.add("active")

                  window.console.log(f"‚úÖ Reopened to step {first_unfinished}")

                  # ‚úÖ Start timer for the reopened step
                  self.start_step_timer(index, first_unfinished, is_first_attempt=True)
                  window.console.log(f"‚è±Ô∏è Started timer for reopened step {first_unfinished}")

          # Re-render MathJax when reopening
          def rerender_mathjax(retry_count=0):
              max_retries = 3
              try:
                  if hasattr(window, 'MathJax') and hasattr(window.MathJax, 'typesetPromise'):
                      window.console.log("üé® Re-rendering MathJax for reopened problem...")
                      window.MathJax.typesetPromise([body]).then(
                          create_proxy(lambda result: window.console.log("‚úÖ MathJax re-rendered"))
                      )
                  elif retry_count < max_retries:
                      window.setTimeout(create_proxy(lambda: rerender_mathjax(retry_count + 1)), 200)
              except Exception as e:
                  window.console.error(f"MathJax re-render error: {e}")

          window.setTimeout(create_proxy(lambda: rerender_mathjax(0)), 100)

      finally:
          # Clear the lock after a short delay
          def clear_lock():
              self._toggling = False
          window.setTimeout(create_proxy(clear_lock), 100)
    
    def restore_global_history_state(self, prob_idx):
      """Restore the saved global history state for a problem"""
      try:
          if prob_idx not in self.problem_global_histories:
              return False

          saved_state = self.problem_global_histories[prob_idx]
          global_history = document.querySelector(f"#globalHistory_{prob_idx}")

          if not global_history:
              return False

          # Restore the HTML content
          global_history.innerHTML = saved_state["html"]

          # Restore visibility
          if saved_state["visible"]:
              global_history.style.display = "block"
          else:
              global_history.style.display = "none"

          window.console.log(f"‚úÖ Restored global history for problem {prob_idx}")
          return True
      except Exception as e:
          window.console.error(f"‚ùå Failed to restore global history: {e}")
          return False

    
    def save_global_history_state(self, prob_idx):
      """Save the current global history state for a problem"""
      try:
          global_history = document.querySelector(f"#globalHistory_{prob_idx}")
          if not global_history:
              window.console.warn(f"‚ö†Ô∏è No global history element for problem {prob_idx}")
              return

          # Save the innerHTML
          history_html = global_history.innerHTML
          is_visible = global_history.style.display != "none"

          self.problem_global_histories[prob_idx] = {
              "html": history_html,
              "visible": is_visible
          }

          window.console.log(f"‚úÖ Saved global history for problem {prob_idx}")
      except Exception as e:
          window.console.error(f"‚ùå Failed to save global history: {e}")

    
    def add_to_global_history(self, step_idx, latex, correct, time_taken, attempt_type):
        """Add attempt to global history view"""
        window.console.log(f"üîµ Adding to global history: step {step_idx}, correct={correct}")
        if self.current_problem_index is None:
            window.console.error(f"‚ùå current_problem_index is None")
            return
        global_history_id = f"#globalHistory_{self.current_problem_index}"
        global_history = document.querySelector(global_history_id)
        if not global_history:
            window.console.error(f"‚ùå Global history element not found: {global_history_id}")
            return

        # Show the container
        global_history.style.display = "block"

        # Convert LaTeX for display (handle matrices and row operations)
        display_latex = self._convert_for_display(latex)

        # ‚úÖ Get actual elapsed time from tracking system if available
        prob_idx = self.current_problem_index
        if time_taken is None or time_taken == 0:
            # Try to get from time tracking system
            time_summary = self.get_step_time_summary(prob_idx, step_idx)
            if attempt_type == "submit":
                # For first submit, use first_attempt time
                time_taken = time_summary.get("first_attempt", 0)
            else:
                # For edits/finalize, use total time
                time_taken = time_summary.get("total_time", 0)

        # Format time nicely
        if time_taken > 0:
            time_str = f"{time_taken:.1f}s"
        else:
            time_str = "0s"

        # Create entry
        entry = document.createElement("div")
        entry.className = "attempt-entry-wrapper"
        if attempt_type == "submit":
            entry.style.background = "#dcfce7" if correct else "#fee2e2"
            entry.style.border = f"2px solid {'#86efac' if correct else '#fecaca'}"
            status_text = '‚úÖ Correct' if correct else '‚ùå Incorrect'
            step_label = f"Step {step_idx + 1}"
        else:  # finalize or other
            entry.style.background = "#dcfce7" if correct else "#fef3c7"
            entry.style.border = f"2px solid {'#86efac' if correct else '#fbbf24'}"
            status_text = '‚úÖ Finalized' if correct else '‚ö†Ô∏è Check'
            step_label = f"Step {step_idx + 1}"

        entry.innerHTML = f"""
        <div style='font-weight:700;font-size:15px;'>
            {step_label}: {status_text} ‚è±Ô∏è {time_str}
        </div>
        <div style='margin-top:6px;padding:8px;background:#fff;border-radius:6px;overflow-x:auto;'>
            $$\\displaystyle {display_latex}$$
        </div>
        """
        global_history.appendChild(entry)

        # Re-render MathJax
        if hasattr(window, 'MathJax') and hasattr(window.MathJax, 'typesetPromise'):
            window.MathJax.typesetPromise([entry])

        # Scroll to bottom
        global_history.scrollTop = global_history.scrollHeight
        window.console.log(f"‚úÖ Added entry to global history")

    def _convert_for_display(self, latex):
        """Convert LaTeX for display, handling matrices and row operations"""
        try:
            import sympy as sp
            import re

            # Check if this is a row operation
            is_row_op = (
                '|R_' in latex or 
                '|\\mathrm{R}_' in latex or
                '\\left|R_' in latex or
                '\\right|' in latex
            )

            # Check if contains matrices
            has_matrix = (
                '[[' in latex or 
                '\\left[\\left[' in latex or 
                '\\begin{matrix}' in latex or
                '\\begin{bmatrix}' in latex or
                '\\begin{pmatrix}' in latex
            )

            # Handle row operations: convert matrix part, keep operation part
            if is_row_op and has_matrix:
                window.console.log(f"Converting row operation for display: {latex}")

                # Split at the pipe: matrix part | operation part
                match = re.match(r'(.+?)(\\left\|.*?\\right\|)', latex)

                if match:
                    matrix_part = match.group(1)
                    operation_part = match.group(2)

                    # Convert only the matrix part
                    parsed_matrix = self.math_parser.parse_latex(matrix_part)
                    converted_matrix = self._convert_latex_preserve_order(parsed_matrix)

                    # Combine: converted matrix + original operation
                    result = converted_matrix + operation_part
                    window.console.log(f"  ‚úÖ Row operation converted: {result}")
                    return result
                else:
                    window.console.log("  Regex didn't match, using original")
                    return latex

            # Regular matrices (not row operations)
            elif has_matrix and not is_row_op:
                window.console.log(f"Converting matrix for display: {latex}")

                # Parse and convert
                parsed = self.math_parser.parse_latex(latex)
                result = self._convert_latex_preserve_order(parsed)

                window.console.log(f"  ‚úÖ Matrix converted: {result}")
                return result

            # No matrices, use original
            else:
                return latex

        except Exception as e:
            window.console.error(f"Error converting LaTeX for display: {e}")
            import traceback
            window.console.error(traceback.format_exc())
            # Fallback to original
            return latex
    
    def find_first_incomplete_problem(self):
      """
      Find the index of the first incomplete problem.
      Returns None if all problems are complete.
      """
      for idx in range(len(self.problem_set)):
          if not self.check_problem_completion(idx):
              window.console.log(f"Found first incomplete problem at index {idx}")
              return idx

      window.console.log("All problems are complete")
      return None
    
    def find_first_unfinished_step(self, problem_idx):
      """
      Find the index of the first unfinished step in a problem.
      Returns None if all steps are finished or no saved state exists.
      """
      # Check if we have saved state for this problem
      if problem_idx not in self.problem_states:
          window.console.log(f"No saved state for problem {problem_idx}, starting from step 0")
          return 0

      saved_state = self.problem_states[problem_idx]

      if not saved_state:
          window.console.log(f"Empty saved state for problem {problem_idx}, starting from step 0")
          return 0

      # Find first unfinished step
      for i, step_state in enumerate(saved_state):
          if not step_state.get("finished", False):
              window.console.log(f"Found first unfinished step at index {i}")
              return i

      # All steps finished - show last step
      window.console.log(f"All steps finished, showing last step")
      return len(saved_state) - 1 if saved_state else 0
    
    def save_to_storage(self):
        """Save to localStorage - problem_set compressed, problem_states uncompressed"""
        try:
            import json
            import base64
            import brotli

            # ============================================
            # PART 1: Save problem_set (COMPRESSED - large, changes rarely)
            # ============================================

            if self.problem_set:
                problem_set_data = {
                    "problem_set_id": self.current_problem_set_uuid,
                    "problem_set": self.problem_set,
                    "description": getattr(self, '_problem_set_description', '')
                }

                # Compress problem set
                json_str = json.dumps(problem_set_data)
                compressed = brotli.compress(json_str.encode('utf-8'))
                encoded = base64.b64encode(compressed).decode('ascii')
                window.localStorage.setItem("problem_solver_problem_set", encoded)

                window.console.log(f"‚úÖ Saved compressed problem set ({len(self.problem_set)} problems)")

            # ============================================
            # PART 2: Save problem_states (UNCOMPRESSED - small, changes frequently)
            # ============================================

            # ‚úÖ Clean problem_states - remove DOM elements
            clean_problem_states = {}
            for prob_idx, steps in self.problem_states.items():
                clean_problem_states[str(prob_idx)] = []
                for step in steps:
                    clean_step = {
                        "finished": step.get("finished", False),
                        "correct": step.get("correct", False),
                        "user_answers": step.get("user_answers", []),
                        "attempts": step.get("attempts", 0),
                        "structure_correct": step.get("structure_correct", False),
                        "points": step.get("points", 100),
                        "score": step.get("score", 0)
                    }
                    clean_problem_states[str(prob_idx)].append(clean_step)

            # Save as plain JSON (fast updates!)
            window.localStorage.setItem("problem_solver_states", json.dumps(clean_problem_states))

            # Debug log
            for prob_idx, steps in self.problem_states.items():
                finished_count = sum(1 for step in steps if step.get("finished", False))
                total_steps = len(steps)
                window.console.log(f"üíæ Problem {prob_idx}: {finished_count}/{total_steps} finished")

            window.console.log(f"‚úÖ Saved problem states ({len(self.problem_states)} problems)")

            # Save current problem index
            if self.current_problem_index is not None:
                window.localStorage.setItem("problem_solver_current_index", str(self.current_problem_index))

            # ============================================
            # PART 3: Save enhanced tracking data
            # ============================================

            # Save score display manager state
            manager_state = {
                "edited_problems": list(self.score_display_manager["edited_problems"]),
                "last_edit_time": self.score_display_manager["last_edit_time"],
                "pending_score_update": self.score_display_manager["pending_score_update"],
                "pending_percentage": self.score_display_manager["pending_percentage"]
            }
            window.localStorage.setItem("score_display_manager", json.dumps(manager_state))
            window.console.log("‚úÖ Saved score display manager")

            # Save global edit tracking (always save, even if empty)
            if hasattr(self.score_tracker, 'ever_edited_steps'):
                edits_to_save = {}
                for (prob_idx, step_idx) in self.score_tracker.ever_edited_steps:
                    prob_key = str(prob_idx)
                    if prob_key not in edits_to_save:
                        edits_to_save[prob_key] = {}
                    edits_to_save[prob_key][str(step_idx)] = True

                window.localStorage.setItem("score_edits", json.dumps(edits_to_save))
                window.console.log(f"‚úÖ Saved {len(self.score_tracker.ever_edited_steps)} edit records")

            # Save score tracker session state (for timer restoration)
            if hasattr(self.score_tracker, 'edited_steps'):
                tracker_state = {
                    "edited_steps": list([list(key) for key in self.score_tracker.edited_steps]),
                    "first_time_edits_in_session": list([list(key) for key in self.score_tracker.first_time_edits_in_session]),
                    "last_edit_time": self.score_tracker.last_edit_time.isoformat() if self.score_tracker.last_edit_time else None,
                    "pending_edits": {f"{k[0]}_{k[1]}": v for k, v in self.score_tracker.pending_edits.items()}
                }
                window.localStorage.setItem("score_tracker_state", json.dumps(tracker_state))
                window.console.log(f"‚úÖ Saved score tracker session state ({len(self.score_tracker.edited_steps)} current edits)")

            # Save credit data
            if hasattr(self, 'credit_balance'):
                credit_data = {
                    "balance": self.credit_balance,
                    "earned_total": self.credit_earned_total,
                    "spent_total": self.credit_spent_total,
                    "history": self.credit_history
                }
                window.localStorage.setItem("credit_data", json.dumps(credit_data))
                window.console.log("‚úÖ Saved credit data")

            window.console.log("‚úÖ Save complete")

        except Exception as e:
            window.console.error(f"‚ö†Ô∏è Error saving to localStorage: {e}")
            import traceback
            window.console.error(traceback.format_exc())


    
    def reset_all_answers(self):
        """Reset all answers and progress"""
        import js
        try:
            window.console.log("üîÑ Resetting all answers...")

            # Clear only answer/progress keys - PRESERVE the problem set!
            # DO NOT remove 'problem_solver_problem_set' - that's the problem set itself
            window.localStorage.removeItem('problem_solver_states')  # User answers
            window.localStorage.removeItem('problem_solver_current_index')  # Current position
            window.localStorage.removeItem('score_display_manager')  # Score display
            window.localStorage.removeItem('score_edits')  # Score edits
            window.localStorage.removeItem('score_tracker_state')  # Score tracker
            window.localStorage.removeItem('credit_data')  # Credit data

            window.console.log("‚úÖ All localStorage data cleared")

            # Reset internal state
            self.problem_states = {}
            self.solve_states = {}
            if hasattr(self, 'step_timers'):
                self.step_timers = {}

            window.alert("‚úÖ All answers and progress have been reset!\n\nPlease reload the page to start fresh.")

        except Exception as e:
            window.console.error(f"‚ùå Reset failed: {e}")
            window.alert(f"‚ùå Reset failed: {e}")

    def reset_current_problem(self):
        """Reset only the current problem's answers"""
        import js
        try:
            current_prob_idx = self.current_problem_index
            if current_prob_idx is None:
                window.alert("‚ö†Ô∏è No problem is currently open")
                return

            window.console.log(f"üîÑ Resetting problem {current_prob_idx}...")

            # Remove from problem_states
            if current_prob_idx in self.problem_states:
                del self.problem_states[current_prob_idx]

            # Remove from solve_states
            if current_prob_idx in self.solve_states:
                del self.solve_states[current_prob_idx]

            # Save updated state
            self.save_to_storage()

            window.console.log(f"‚úÖ Problem {current_prob_idx} reset")
            window.alert(f"‚úÖ Problem {current_prob_idx + 1} has been reset!\n\nPlease reload the problem to start fresh.")

        except Exception as e:
            window.console.error(f"‚ùå Reset failed: {e}")
            window.alert(f"‚ùå Reset failed: {e}")

    def get_storage_info(self):
        """Get information about current localStorage usage"""
        import js
        try:
            info = {
                "problems_count": len(self.problem_states),
                "total_steps": sum(len(steps) for steps in self.problem_states.values()),
                "completed_problems": sum(1 for prob_idx in self.problem_states if self.is_problem_complete(prob_idx))
            }

            # Get localStorage sizes
            try:
                problem_states_str = window.localStorage.getItem('problem_solver_states')
                if problem_states_str:
                    info["problem_states_size"] = len(problem_states_str)
            except:
                info["problem_states_size"] = 0

            return info
        except Exception as e:
            window.console.error(f"Error getting storage info: {e}")
            return {}


    def update_storage_info(self):
        """Update the storage info display on reset page"""
        info_div = document.querySelector("#storageInfo")
        if not info_div:
            return

        try:
            info = self.get_storage_info()

            size_kb = info.get("problem_states_size", 0) / 1024

            html = f"""
                <div style='margin-bottom: 8px;'><strong>Problems with saved data:</strong> {info.get('problems_count', 0)}</div>
                <div style='margin-bottom: 8px;'><strong>Total steps saved:</strong> {info.get('total_steps', 0)}</div>
                <div style='margin-bottom: 8px;'><strong>Completed problems:</strong> {info.get('completed_problems', 0)}</div>
                <div><strong>Storage size:</strong> {size_kb:.2f} KB</div>
            """

            info_div.innerHTML = html
            window.console.log("‚úÖ Storage info updated")
        except Exception as e:
            info_div.innerHTML = f"<div style='color: #dc2626;'>Error loading storage info: {e}</div>"
            window.console.error(f"Error updating storage info: {e}")

    def load_from_storage(self):
        """Load from localStorage - problem_set compressed, problem_states uncompressed"""
        try:
            window.console.log("üîç Loading data from localStorage...")
            import json

            # ============================================
            # PART 1: Load problem_set (COMPRESSED)
            # ============================================

            stored_problem_set = window.localStorage.getItem("problem_solver_problem_set")
            if stored_problem_set:
                try:
                    import brotli
                    import base64

                    # Decompress problem set
                    compressed = base64.b64decode(stored_problem_set)
                    json_str = brotli.decompress(compressed).decode('utf-8')
                    data = json.loads(json_str)

                    # Restore problem set data
                    self.current_problem_set_uuid = data.get("problem_set_id")
                    self.problem_set = data.get("problem_set", [])
                    self._problem_set_description = data.get("description", "")

                    window.console.log(f"‚úÖ Loaded compressed problem set: {len(self.problem_set)} problems")

                except Exception as e:
                    window.console.error(f"‚ö†Ô∏è Error loading compressed problem set: {e}")
                    # Try legacy format
                    self._try_load_legacy_compressed_format()
            else:
                window.console.log("‚ÑπÔ∏è No problem set found")
                # Try legacy format
                self._try_load_legacy_compressed_format()

            # ============================================
            # PART 2: Load problem_states (UNCOMPRESSED - fast!)
            # ============================================

            stored_states = window.localStorage.getItem("problem_solver_states")
            if stored_states:
                loaded_states = json.loads(stored_states)

                # Convert string keys to integers
                self.problem_states = {}
                for k, v in loaded_states.items():
                    self.problem_states[int(k)] = v

                window.console.log(f"‚úÖ Loaded problem states: {len(self.problem_states)} problems")

                # ‚úÖ MIGRATION: Add step_type to loaded states if missing
                if self.problem_set:
                    for prob_idx, problem in enumerate(self.problem_set):
                        if prob_idx in self.problem_states:
                            steps = problem.get("steps", [])
                            saved_steps = self.problem_states[prob_idx]
                            for step_idx, step_data in enumerate(steps):
                                if step_idx < len(saved_steps):
                                    # Add step_type if it doesn't exist
                                    if "step_type" not in saved_steps[step_idx]:
                                        step_type = step_data.get("step_type", "math-expression")
                                        # Normalize step-by-step to math-expression
                                        if step_type == "step-by-step":
                                            step_type = "math-expression"
                                        saved_steps[step_idx]["step_type"] = step_type
                                        window.console.log(f"üîß Added step_type '{step_type}' to problem {prob_idx}, step {step_idx}")
                                    else:
                                        # Normalize existing step-by-step to math-expression
                                        if saved_steps[step_idx]["step_type"] == "step-by-step":
                                            saved_steps[step_idx]["step_type"] = "math-expression"
                                            window.console.log(f"üîß Normalized step_type 'step-by-step' to 'math-expression' for problem {prob_idx}, step {step_idx}")

                # ‚úÖ DEBUG: Log completion data
                window.console.log("=" * 50)
                window.console.log("üìä LOADED COMPLETION DATA:")
                for prob_idx, steps in self.problem_states.items():
                    finished_count = sum(1 for step in steps if step.get("finished", False))
                    total_steps = len(steps)
                    is_complete = finished_count >= total_steps and total_steps > 0
                    status = "‚úÖ COMPLETE" if is_complete else f"‚è≥ {finished_count}/{total_steps}"
                    window.console.log(f"  Problem {prob_idx}: {status}")
                window.console.log("=" * 50)
            else:
                window.console.log("‚ÑπÔ∏è No problem states found - starting fresh")
                self.problem_states = {}

            # Load current problem index
            current_index_str = window.localStorage.getItem("problem_solver_current_index")
            if current_index_str:
                self.current_problem_index = int(current_index_str)

            # ‚úÖ Initialize solve_states as empty (UI only, not persisted)
            self.solve_states = {}
            window.console.log("‚úÖ Initialized empty solve_states (UI only)")

            # Update UI if problem set exists
            if self.problem_set:
                self.update_problem_set_info(self._problem_set_description)
                self.render_problems()
                window.console.log("‚úÖ Problem set rendered")

            # ============================================
            # PART 3: Load enhanced tracking data
            # ============================================

            # Load score display manager state
            score_manager_data = window.localStorage.getItem("score_display_manager")
            if score_manager_data:
                try:
                    manager_data = json.loads(score_manager_data)

                    if "edited_problems" in manager_data:
                        self.score_display_manager["edited_problems"] = set(manager_data["edited_problems"])
                        window.console.log(f"‚úÖ Restored {len(self.score_display_manager['edited_problems'])} edited problems")

                    if "last_edit_time" in manager_data:
                        self.score_display_manager["last_edit_time"] = manager_data["last_edit_time"]

                    if "pending_score_update" in manager_data:
                        self.score_display_manager["pending_score_update"] = manager_data["pending_score_update"]
                        self.score_display_manager["pending_percentage"] = manager_data.get("pending_percentage", 0)

                    window.console.log("‚úÖ Restored score display manager state")
                except Exception as e:
                    window.console.error(f"‚ö†Ô∏è Error loading score manager data: {e}")

            # Load global edit tracking
            edits_data = window.localStorage.getItem("score_edits")
            if edits_data:
                try:
                    edits = json.loads(edits_data)

                    for prob_idx_str, step_edits in edits.items():
                        prob_idx = int(prob_idx_str)
                        for step_idx_str in step_edits.keys():
                            step_idx = int(step_idx_str)
                            self.score_tracker.ever_edited_steps.add((prob_idx, step_idx))

                    total_edits = len(self.score_tracker.ever_edited_steps)
                    window.console.log(f"‚úÖ Restored {total_edits} historical edits")
                except Exception as e:
                    window.console.error(f"‚ö†Ô∏è Error loading edit tracking: {e}")

            # Load score tracker session state (for timer restoration)
            tracker_data = window.localStorage.getItem("score_tracker_state")
            if tracker_data:
                try:
                    import datetime
                    tracker = json.loads(tracker_data)

                    # Restore session edit sets
                    for key in tracker.get("edited_steps", []):
                        self.score_tracker.edited_steps.add((key[0], key[1]))

                    for key in tracker.get("first_time_edits_in_session", []):
                        self.score_tracker.first_time_edits_in_session.add((key[0], key[1]))

                    # Restore last edit time
                    if tracker.get("last_edit_time"):
                        self.score_tracker.last_edit_time = datetime.datetime.fromisoformat(tracker["last_edit_time"])

                    # Restore pending edits
                    for key_str, value in tracker.get("pending_edits", {}).items():
                        parts = key_str.split("_")
                        prob_idx = int(parts[0])
                        step_idx = int(parts[1])
                        self.score_tracker.pending_edits[(prob_idx, step_idx)] = value

                    window.console.log(f"‚úÖ Restored score tracker session: {len(self.score_tracker.edited_steps)} edits, {len(self.score_tracker.first_time_edits_in_session)} first-time")
                except Exception as e:
                    window.console.error(f"‚ö†Ô∏è Error loading score tracker state: {e}")

            # Load credit data
            credit_data = window.localStorage.getItem("credit_data")
            if credit_data:
                try:
                    credits = json.loads(credit_data)
                    self.credit_balance = credits.get("balance", 0)
                    self.credit_earned_total = credits.get("earned_total", 0)
                    self.credit_spent_total = credits.get("spent_total", 0)
                    self.credit_history = credits.get("history", [])
                    window.console.log(f"‚úÖ Loaded credit data: {self.credit_balance} credits")
                except Exception as e:
                    window.console.error(f"‚ö†Ô∏è Error loading credit data: {e}")

            # ============================================
            # PART 4: Auto-open first incomplete problem
            # ============================================

            if self.problem_set and len(self.problem_states) > 0:
                first_incomplete = None
                for prob_idx in range(len(self.problem_set)):
                    if prob_idx in self.problem_states:
                        steps = self.problem_states[prob_idx]
                        finished_count = sum(1 for step in steps if step.get("finished", False))
                        total_steps = len(steps)

                        if finished_count < total_steps:
                            first_incomplete = prob_idx
                            window.console.log(f"Found first incomplete problem at index {prob_idx}")
                            break
                    else:
                        first_incomplete = prob_idx
                        break

                if first_incomplete is not None:
                    window.console.log(f"‚úÖ Auto-opening first incomplete problem: {first_incomplete}")

                    def open_problem():
                        self.toggle_problem(first_incomplete)
                    window.setTimeout(create_proxy(open_problem), 500)

            # ============================================
            # PART 5: Restore timers if pending
            # ============================================

            self.restore_timers_after_load()

            window.console.log("‚úÖ Load complete")

        except Exception as e:
            window.console.error(f"‚ö†Ô∏è Critical error in load_from_storage: {e}")
            import traceback
            window.console.error(traceback.format_exc())

    def restore_timers_after_load(self):
        """Restore 5-minute timers after app load/refresh"""
        try:
            import js
            import datetime

            window.console.log("üîÑ Checking for pending timers to restore...")

            # ============================================
            # PART 1: Check score_display_manager timer (solving mode)
            # ============================================

            if self.score_display_manager["pending_score_update"]:
                last_edit = self.score_display_manager["last_edit_time"]

                if last_edit:
                    current_time = js.Date.now()
                    elapsed_ms = current_time - last_edit
                    elapsed_minutes = elapsed_ms / 60000

                    window.console.log(f"‚è±Ô∏è Found pending score update - {elapsed_minutes:.1f} minutes elapsed")

                    if elapsed_minutes >= 5:
                        # 5 minutes already elapsed during downtime - update now!
                        window.console.log("‚úÖ 5+ minutes elapsed during downtime - recalculating and updating score now")

                        # ‚úÖ Recalculate score fresh from problem_states (don't use cached pending_percentage)
                        total_score, max_score, problem_scores = self.calculate_total_score()
                        if max_score > 0:
                            percentage = (total_score / max_score) * 100
                        else:
                            percentage = 0

                        window.console.log(f"üìä Recalculated score: {percentage:.1f}% ({total_score:.1f}/{max_score:.1f})")

                        def delayed_update():
                            self.update_score_display_in_review(percentage)
                            self.score_display_manager["pending_score_update"] = False
                            self.score_display_manager["pending_percentage"] = percentage  # Update cached value
                            self.score_tracker.reset()

                            # Save the updated state to localStorage
                            self.save_to_storage()

                            # Show notification with score details
                            notification_text = f"‚è∞ Score Updated: {percentage:.1f}% (Timer completed during app restart)"
                            self.show_score_update_notification(notification_text)

                            # Show banner message
                            self.show_score_updated_after_load_banner(percentage, elapsed_minutes)

                            window.console.log(f"‚úÖ Score display updated in overall banner: {percentage:.1f}%")

                        window.setTimeout(create_proxy(delayed_update), 1000)
                    else:
                        # Less than 5 minutes - restart timer with remaining time
                        remaining_ms = (5 * 60 * 1000) - elapsed_ms
                        remaining_minutes = remaining_ms / 60000
                        window.console.log(f"‚è±Ô∏è Restarting timer with {remaining_minutes:.1f} minutes remaining")

                        # Timer will be handled by start_score_display_timer() which runs automatically
                        # Display UI message showing pending timer
                        self.show_pending_timer_message_after_load(remaining_minutes)
                else:
                    window.console.log("‚ö†Ô∏è Pending score update but no last_edit_time - clearing pending state")
                    self.score_display_manager["pending_score_update"] = False
            else:
                # No pending timer, clear any stale UI messages
                window.console.log("‚ÑπÔ∏è No pending timer to restore")

            # ============================================
            # PART 2: Check score_tracker timer (review mode)
            # ============================================

            if self.score_tracker.last_edit_time and len(self.score_tracker.first_time_edits_in_session) < 2:
                # Check if in review mode
                msg_el = document.querySelector("#reviewScoreMessage")
                if msg_el:
                    current_time = datetime.datetime.now()
                    elapsed = (current_time - self.score_tracker.last_edit_time).total_seconds()
                    elapsed_minutes = elapsed / 60

                    window.console.log(f"‚è±Ô∏è Found score_tracker timer - {elapsed_minutes:.1f} minutes elapsed")

                    if elapsed_minutes >= 5:
                        # 5 minutes already elapsed - trigger now
                        window.console.log("‚úÖ 5+ minutes elapsed in review mode - triggering recalculation")
                        self.score_tracker.trigger_recalculation("5_minutes")
                    else:
                        # Restart timer with remaining time
                        remaining_seconds = (5 * 60) - elapsed
                        remaining_ms = remaining_seconds * 1000
                        window.console.log(f"‚è±Ô∏è Restarting review timer with {remaining_seconds/60:.1f} minutes remaining")

                        def timer_callback():
                            self.score_tracker.trigger_recalculation("5_minutes")

                        self.score_tracker.timer_handle = window.setTimeout(create_proxy(timer_callback), int(remaining_ms))
                        self.score_tracker.update_ui_message()

            window.console.log("‚úÖ Timer restoration complete")

        except Exception as e:
            window.console.error(f"‚ö†Ô∏è Error restoring timers: {e}")
            import traceback
            window.console.error(traceback.format_exc())

    def show_pending_timer_message_after_load(self, remaining_minutes):
        """Legacy wrapper - calls unified timer message function"""
        remaining_seconds = int(remaining_minutes * 60)
        self.show_unified_timer_message(remaining_seconds=remaining_seconds, context="restored from previous session")

    def show_score_updated_after_load_banner(self, percentage, elapsed_minutes):
        """Show banner message when score was updated after 5+ minutes on load"""
        try:
            window.console.log(f"üì¢ Showing score updated banner: {percentage:.1f}% after {elapsed_minutes:.1f}m")

            # Try to find review section to display message
            review_section = document.querySelector("[id^='reviewSection_']")
            if review_section:
                existing_msg = review_section.querySelector(".score-updated-after-load-msg")
                if existing_msg:
                    existing_msg.remove()

                msg = document.createElement("div")
                msg.className = "score-updated-after-load-msg"
                msg.style.cssText = """
                    background: linear-gradient(135deg, #d1fae5, #a7f3d0);
                    border: 2px solid #10b981;
                    border-radius: 12px;
                    padding: 20px;
                    margin: 16px 0;
                    animation: fadeIn 0.5s ease;
                    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                """

                elapsed_str = f"{int(elapsed_minutes)} minutes" if elapsed_minutes > 1 else f"{int(elapsed_minutes * 60)} seconds"

                msg.innerHTML = f"""
                    <div style="font-weight: 700; color: #065f46; font-size: 18px; margin-bottom: 10px;">
                        ‚úÖ Score Automatically Updated!
                    </div>
                    <div style="font-size: 16px; color: #047857; margin-bottom: 8px;">
                        <strong>Your Score: {percentage:.1f}%</strong>
                    </div>
                    <div style="font-size: 14px; color: #059669;">
                        Timer completed while app was closed ({elapsed_str} elapsed).
                        Your score has been recalculated and is now displayed in the banner above.
                    </div>
                """

                review_section.insertBefore(msg, review_section.firstChild)

                # Auto-remove after 15 seconds
                def remove_msg():
                    if msg and msg.parentNode:
                        msg.style.opacity = "0"
                        msg.style.transition = "opacity 0.5s"
                        def final_remove():
                            if msg and msg.parentNode:
                                msg.remove()
                        window.setTimeout(create_proxy(final_remove), 500)

                window.setTimeout(create_proxy(remove_msg), 15000)

                window.console.log("‚úÖ Score updated banner displayed")
            else:
                window.console.log("‚ÑπÔ∏è Review section not found - banner not displayed")

        except Exception as e:
            window.console.error(f"‚ö†Ô∏è Error showing score updated banner: {e}")
            import traceback
            window.console.error(traceback.format_exc())

    def _try_load_legacy_compressed_format(self):
      """Try loading from old format where everything was compressed together"""
      try:
          import brotli
          import json
          import base64

          stored = window.localStorage.getItem("problem_solver_data")
          if stored:
              # Decompress
              compressed = base64.b64decode(stored)
              json_str = brotli.decompress(compressed).decode('utf-8')
              data = json.loads(json_str)

              # Extract data
              self.current_problem_set_uuid = data.get("problem_set_id")
              self.problem_set = data.get("problem_set", [])

              # ‚úÖ CRITICAL FIX: Load old problem_states
              loaded_states = data.get("problem_states", {})
              self.problem_states = {}

              # Convert keys and validate structure
              for k, v in loaded_states.items():
                  prob_idx = int(k)

                  # ‚úÖ VALIDATE: Ensure each step has required fields
                  if isinstance(v, list):
                      validated_steps = []
                      for step_data in v:
                          if isinstance(step_data, dict):
                              # Ensure all required fields exist with proper defaults
                              validated_step = {
                                  "finished": step_data.get("finished", False),
                                  "correct": step_data.get("correct", False),
                                  "user_answers": step_data.get("user_answers", []),
                                  "attempts": step_data.get("attempts", 0),
                                  "structure_correct": step_data.get("structure_correct", False),
                                  "points": step_data.get("points", 100),
                                  "score": step_data.get("score", 0)
                              }
                              validated_steps.append(validated_step)

                      # ‚úÖ Only save if we have valid steps
                      if len(validated_steps) > 0:
                          self.problem_states[prob_idx] = validated_steps

              # ‚úÖ CRITICAL: If problem_states are empty or wrong, initialize from problem_set
              for prob_idx, problem in enumerate(self.problem_set):
                  if prob_idx not in self.problem_states or len(self.problem_states[prob_idx]) == 0:
                      steps = problem.get("steps", [])
                      if len(steps) > 0:
                          window.console.log(f"‚ö†Ô∏è Initializing problem_states for problem {prob_idx} ({len(steps)} steps)")
                          self.problem_states[prob_idx] = []
                          for step in steps:
                              self.problem_states[prob_idx].append({
                                  "finished": False,
                                  "correct": False,
                                  "user_answers": [],
                                  "attempts": 0,
                                  "structure_correct": False,
                                  "points": step.get("points", 100),
                                  "score": 0
                              })

              self.current_problem_index = data.get("current_problem_index")
              self._problem_set_description = data.get("description", "")

              window.console.log("‚úÖ Loaded from legacy compressed format")

              # Debug: Verify what we loaded
              for prob_idx, steps in self.problem_states.items():
                  window.console.log(f"  Problem {prob_idx}: {len(steps)} steps initialized")

              # Migrate to new format
              self.save_to_storage()
              window.console.log("‚úÖ Migrated to new storage format")

      except Exception as e:
          window.console.error(f"‚ö†Ô∏è Could not load legacy format: {e}")
          import traceback
          window.console.error(traceback.format_exc())
    def save_problem_to_storage(self, problem_idx):
        """Save a specific problem's state - FAST (uncompressed JSON)"""

        if problem_idx not in self.problem_states:
            window.console.warn(f"‚ö†Ô∏è Cannot save problem {problem_idx} - not in problem_states")
            return

        try:
            import json

            # ‚úÖ Only update problem_states in localStorage (fast!)
            clean_problem_states = {}
            for prob_idx, steps in self.problem_states.items():
                clean_problem_states[str(prob_idx)] = []
                for step in steps:
                    clean_step = {
                        "finished": step.get("finished", False),
                        "correct": step.get("correct", False),
                        "user_answers": step.get("user_answers", []),
                        "attempts": step.get("attempts", 0),
                        "structure_correct": step.get("structure_correct", False),
                        "points": step.get("points", 100),
                        "score": step.get("score", 0)
                    }
                    clean_problem_states[str(prob_idx)].append(clean_step)

            # Save just the states (no compression needed - it's small and fast!)
            window.localStorage.setItem("problem_solver_states", json.dumps(clean_problem_states))

            steps = self.problem_states[problem_idx]
            finished_count = sum(1 for step in steps if step.get("finished", False))
            total_steps = len(steps)
            window.console.log(f"üíæ Saved problem {problem_idx}: {finished_count}/{total_steps} finished")

        except Exception as e:
            window.console.error(f"‚ùå Error saving problem {problem_idx}: {e}")
    
    def load_problem(self, index, body_container=None):
      """Load a problem into the solve UI"""
      window.console.log(f"üìÇ Loading problem {index}")

      # ‚úÖ Clear mc-multiple shuffle storage for this problem
      # This ensures fresh shuffles when user starts a new problem
      if index < len(self.problem_set):
          problem = self.problem_set[index]
          steps = problem.get("steps", [])
          for step_idx in range(len(steps)):
              shuffle_key = f"mc_multiple_shuffle_{index}_{step_idx}"
              window.localStorage.removeItem(shuffle_key)
          window.console.log(f"üîÑ Cleared mc-multiple shuffle storage for problem {index}")

      # Get the container
      if body_container is None:
          body_container = document.querySelector(f"#problemBody{index}")

      if not body_container:
          window.console.error(f"‚ùå No container found for problem {index}")
          return

      # ‚úÖ GUARD: Check if already loading this problem
      if hasattr(self, '_currently_loading_problem') and self._currently_loading_problem == index:
          window.console.warn(f"‚ö†Ô∏è Already loading problem {index}, skipping duplicate call")
          return

      # ‚úÖ Check if container already has content and problem is loaded
      if body_container.children.length > 0 and self.current_problem_index == index:
          window.console.log(f"‚úÖ Problem {index} already loaded, skipping reload")
          return

      # Set loading flag
      self._currently_loading_problem = index
      window.console.log(f"üîí Set loading flag for problem {index}")

      container = body_container
      self.current_problem_index = index

      # Get problem data
      if index >= len(self.problem_set):
          window.console.error(f"‚ùå Problem {index} out of range")
          self._currently_loading_problem = None
          return

      problem = self.problem_set[index]
      steps = problem.get("steps", [])

      if len(steps) == 0:
          container.innerHTML = "<p style='color:#ef4444;'>‚ùå No steps found for this problem</p>"
          self._currently_loading_problem = None
          return

      # ============================================
      # ‚úÖ CHECK COMPLETION FROM problem_states (single source of truth)
      # ============================================

      is_complete = False
      finished_count = 0
      total_steps = len(steps)

      if index in self.problem_states:
          saved_state = self.problem_states[index]
          finished_count = sum(1 for step in saved_state if step.get("finished", False))

          window.console.log(f"Problem {index} completion check: {finished_count}/{total_steps} = {finished_count >= total_steps}")

          if finished_count >= total_steps and total_steps > 0:
              is_complete = True

      # ============================================
      # ‚úÖ IF COMPLETE: Show banner and RETURN
      # ============================================

      if is_complete:
          window.console.log(f"‚úÖ Problem {index} is complete, showing completion banner only")

          container.innerHTML = ""
          self.show_problem_completion_banner(index)

          # Hide attempt history
          history_container = document.querySelector(f"#globalHistory_{index}")
          if history_container:
              history_container.style.display = "none"

          # Render MathJax
          def render_mathjax(retry_count=0):
              try:
                  if hasattr(window, 'MathJax') and hasattr(window.MathJax, 'typesetPromise'):
                      window.MathJax.typesetPromise([container]).then(
                          create_proxy(lambda result: window.console.log("‚úÖ MathJax re-rendered"))
                      )
              except Exception as e:
                  window.console.error(f"MathJax error: {e}")

          window.setTimeout(create_proxy(render_mathjax), 100)

          self._currently_loading_problem = None
          window.console.log(f"üîì Cleared loading flag for problem {index}")
          return

      # ============================================
      # ‚úÖ INCOMPLETE - Create solve UI
      # ============================================

      window.console.log(f"‚è≥ Problem {index} is incomplete, creating solve UI")
      container.innerHTML = ""

      # ‚úÖ Check if user has started working on this problem
      has_started = False
      if index in self.problem_states:
          for step_state in self.problem_states[index]:
              # Check if any step has been worked on
              if (step_state.get("finished", False) or
                  step_state.get("attempts", 0) > 0 or
                  (step_state.get("user_answers") and len(step_state.get("user_answers", [])) > 0)):
                  has_started = True
                  window.console.log(f"‚úì Problem {index} has been started - hiding description")
                  break

      # ‚úÖ Add problem description ONLY if user hasn't started yet
      if not has_started:
          problem_description = problem.get("description", [])
          if problem_description and isinstance(problem_description, list):
              desc_html = self.render_content_blocks(problem_description)
              if desc_html.strip():
                  desc_container = document.createElement("div")
                  desc_container.className = "problem-description"
                  desc_container.style.cssText = """
                      background: #f0f9ff;
                      padding: 16px 20px;
                      border-radius: 12px;
                      border-left: 4px solid #3b82f6;
                      margin-bottom: 20px;
                      font-size: 15px;
                      line-height: 1.6;
                      color: #1e293b;
                  """
                  desc_container.innerHTML = f"<div style='font-weight:600;margin-bottom:8px;color:#1e40af;'>üìã Problem Description:</div>{desc_html}"
                  container.appendChild(desc_container)
                  window.console.log("‚úÖ Added problem description to solve view (first time)")
      else:
          window.console.log("‚äò Problem description hidden (problem already started)")

      # Global attempt history container
      global_history_div = document.createElement("div")
      global_history_div.id = f"globalHistory_{index}"
      global_history_div.className = "panel"
      global_history_div.style.cssText = "background:#f8fafc;margin-bottom:16px;display:none;max-height:400px;overflow-y:auto;padding:12px;border-radius:8px;"

      if index in self.problem_global_histories:
          saved_state = self.problem_global_histories[index]
          global_history_div.innerHTML = saved_state.get("html", "<div style='font-weight:700;margin-bottom:10px;font-size:16px;'>üìù All Attempts History:</div>")
          if saved_state.get("visible", False):
              global_history_div.style.display = "block"
      else:
          global_history_div.innerHTML = "<div style='font-weight:700;margin-bottom:10px;font-size:16px;'>üìù All Attempts History:</div>"

      container.appendChild(global_history_div)

      self.global_attempt_history = []
      self.solve_state = []

      # ‚úÖ Initialize problem_states for this problem if needed
      if index not in self.problem_states:
          self.problem_states[index] = []
          for step in steps:
              step_type = step.get("step_type", "math-expression")
              # Normalize step-by-step to math-expression
              if step_type == "step-by-step":
                  step_type = "math-expression"
              self.problem_states[index].append({
                  "finished": False,
                  "correct": False,
                  "user_answers": [],
                  "attempts": 0,
                  "structure_correct": False,
                  "points": step.get("points", 100),
                  "score": 0,
                  "step_type": step_type
              })
          window.console.log(f"‚úÖ Initialized problem_states for problem {index} with {len(steps)} steps")
          # Save immediately
          self.save_problem_to_storage(index)
      elif len(self.problem_states[index]) != len(steps):
          # ‚úÖ FIX: Mismatch between saved state and actual steps
          window.console.warn(f"‚ö†Ô∏è Problem {index} has {len(self.problem_states[index])} saved steps but {len(steps)} actual steps - reinitializing")
          self.problem_states[index] = []
          for step in steps:
              step_type = step.get("step_type", "math-expression")
              # Normalize step-by-step to math-expression
              if step_type == "step-by-step":
                  step_type = "math-expression"
              self.problem_states[index].append({
                  "finished": False,
                  "correct": False,
                  "user_answers": [],
                  "attempts": 0,
                  "structure_correct": False,
                  "points": step.get("points", 100),
                  "score": 0,
                  "step_type": step_type
              })
          self.save_problem_to_storage(index)

      # Create step UI
      for step_idx, step_data in enumerate(steps):
          step_div = document.createElement("div")
          step_div.className = "panel step"
          step_div.id = f"step{index}_{step_idx}"

          step_type = step_data.get("step_type", "math-expression")
          if step_type == "step-by-step":
              step_type = "math-expression"

          window.console.log(f"Creating step {step_idx} with type: {step_type}")

          # Render description
          step_desc = step_data.get("description", [])
          desc_html = self.render_content_blocks(step_desc)

          # Create UI based on type
          if step_type == "math-expression":
              self.create_math_expression_ui(step_div, index, step_idx, step_data, desc_html, len(steps))
          elif step_type == "multiple-choice-single":
              self.create_mc_single_ui(step_div, index, step_idx, step_data, desc_html, len(steps))
          elif step_type == "multiple-choice-multiple":
              self.create_mc_multiple_ui(step_div, index, step_idx, step_data, desc_html, len(steps))
          elif step_type == "multi-mc":
              self.create_multi_mc_ui(step_div, index, step_idx, step_data, desc_html, len(steps))
          elif step_type == "true-false":
              self.create_truefalse_ui(step_div, index, step_idx, step_data, desc_html, len(steps))
          elif step_type == "fill-blank":
              # Unified handling for both single-blank and multi-blank
              window.console.log(f"üìù Creating fill-blank UI for step {step_idx}")
              must_correct = step_data.get("requireCorrect", False)
              must_correct_badge = "üîí Must be correct" if must_correct else ""
              self.create_fill_blank_ui(step_div, index, step_idx, step_data, desc_html, len(steps), must_correct_badge)
          else:
              window.console.error(f"Unknown step type: {step_type}")
              continue

          container.appendChild(step_div)

          # ‚úÖ Get saved data from problem_states (single source of truth)
          saved_data = self.problem_states[index][step_idx] if step_idx < len(self.problem_states[index]) else {}

          window.console.log(f"Step {step_idx} saved data: finished={saved_data.get('finished')}, correct={saved_data.get('correct')}")

          # ‚úÖ Create step object with data from problem_states
          step_obj = {
              "step": step_data,
              "step_data": step_data,
              "container": step_div,
              "step_type": step_type,
              "attempts": saved_data.get("attempts", 0),
              "finished": saved_data.get("finished", False),
              "correct": saved_data.get("correct", False),
              "structure_correct": saved_data.get("structure_correct", False),
              "user_answers": saved_data.get("user_answers", [])
          }

          self.solve_state.append(step_obj)

      # ‚úÖ Store solve_state for this problem
      self.solve_states[index] = self.solve_state
      window.console.log(f"‚úÖ Stored solve_state for problem {index} with {len(self.solve_state)} steps")

      # Find and show first unfinished step
      first_unfinished_idx = None
      for i, step_obj in enumerate(self.solve_state):
          if not step_obj["finished"]:
              first_unfinished_idx = i
              break

      if first_unfinished_idx is None:
          first_unfinished_idx = 0

      window.console.log(f"üìç First unfinished step: {first_unfinished_idx}")

      # Hide all, show first unfinished
      for i, step in enumerate(self.solve_state):
          if i == first_unfinished_idx:
              step["container"].style.display = "block"
              step["container"].classList.add("active")
          else:
              step["container"].style.display = "none"
              step["container"].classList.remove("active")

      window.console.log(f"‚úÖ Showing step {first_unfinished_idx}")

      # ‚úÖ Start timer for the first shown step
      self.start_step_timer(index, first_unfinished_idx, is_first_attempt=True)
      window.console.log(f"‚è±Ô∏è Started timer for step {first_unfinished_idx}")

      # Scroll to step
      def scroll_to_step():
          target_step = self.solve_state[first_unfinished_idx]["container"]
          if target_step:
              target_step.scrollIntoView({'behavior': 'smooth', 'block': 'start'})
              window.console.log(f"üìú Scrolled to step {first_unfinished_idx}")

      window.setTimeout(create_proxy(scroll_to_step), 300)

      # Update progress
      def update_after_load():
          self.update_problem_progress(index)
      window.setTimeout(create_proxy(update_after_load), 100)

      # Render MathJax
      def render_mathjax(retry_count=0):
          max_retries = 5
          try:
              if hasattr(window, 'MathJax') and hasattr(window.MathJax, 'typesetPromise'):
                  window.console.log(f"üé® Rendering MathJax (attempt {retry_count + 1})...")
                  window.MathJax.typesetPromise([container]).then(
                      create_proxy(lambda result: window.console.log("‚úÖ MathJax rendered successfully"))
                  ).catch(
                      create_proxy(lambda error: window.console.error(f"MathJax render error: {error}"))
                  )
              else:
                  if retry_count < max_retries:
                      window.console.warn(f"‚ö†Ô∏è MathJax not ready yet, retrying in 300ms... (attempt {retry_count + 1}/{max_retries})")
                      window.setTimeout(create_proxy(lambda: render_mathjax(retry_count + 1)), 300)
                  else:
                      window.console.error("‚ùå MathJax failed to load after maximum retries")
          except Exception as e:
              window.console.error(f"MathJax render exception: {e}")
              if retry_count < max_retries:
                  window.setTimeout(create_proxy(lambda: render_mathjax(retry_count + 1)), 300)

      window.setTimeout(create_proxy(lambda: render_mathjax(0)), 500)

      # ‚úÖ Clear loading flag
      self._currently_loading_problem = None
      window.console.log(f"üîì Cleared loading flag for problem {index}")

    def render_content_blocks(self, blocks):
      """Render Quill content blocks to HTML"""
      if not blocks or not isinstance(blocks, list):
          return ""

      html_parts = []
      for block in blocks:
          if not isinstance(block, dict):
              continue

          block_type = block.get("type", "")

          if block_type == "text":
              text = block.get("value", "")
              html_parts.append(text.replace('\n', '<br>'))

          elif block_type == "line_break":
              html_parts.append("<br>")

          elif block_type == "mathstring":
              # ‚úÖ Handle mathstring blocks (the actual export format)
              mode = block.get("mode", "")
              text = block.get("text", "")

              if mode == "latex":
                  html_parts.append(f"\\({text}\\)")
              elif mode == "asciimath":
                  html_parts.append(f"`{text}`")

          elif block_type == "image":
              src = block.get("src", "")
              alt = block.get("alt", "")
              if src:
                  html_parts.append(f'<img src="{html.escape(src)}" alt="{html.escape(alt)}" style="max-width:100%;height:auto;display:inline-block;margin:4px;border-radius:4px;">')

      return "".join(html_parts)
    
    def create_math_expression_ui(self, step_div, index, step_idx, step_data, desc_html, total_steps):
      """Create UI for math expression problems with submit and finalize buttons"""
      must_correct = step_data.get("requireCorrect", False)

      # Badge for must_correct
      must_correct_badge = ""
      if must_correct:
          must_correct_badge = "<span style='background:#fef3c7;color:#b45309;padding:4px 8px;border-radius:4px;font-size:12px;margin-left:8px;'>‚ö†Ô∏è Must be correct</span>"

      step_div.innerHTML = f"""
      <div style='font-weight:700;margin-bottom:8px;'>
          Step <span class='step-number-display'>{step_idx+1}</span> of {total_steps} {must_correct_badge}
      </div>
      <div class='step-description'>{desc_html}</div>
      <div style='margin-top:12px;'>
        <div style='font-weight:700;margin-bottom:8px;'>Your Answer:</div>
        <div style='border:2px solid #e6eef8;border-radius:8px;padding:10px;background:#fff;'>
          <div class='math-input step-answer'></div>
        </div>
        <div style='display:flex;flex-direction:column;gap:8px;margin-top:12px;'>
          <button class='btn submit-step'>Submit Answer</button>
          <button class='btn finalize-step' disabled style='opacity:0.5;'>Finalize Step</button>
          <button class='btn next-step' style='display:none;background:#10b981;'>Next Step ‚Üí</button>
        </div>
      </div>
      <div class='step-feedback'></div>
      <div class='attempts-history' style='display:none;'></div>
      """

      # Initialize MathQuill
      if self.MQ:
          answer_elem = step_div.querySelector(".step-answer")
          answer_field = self.MQ.MathField(answer_elem)

          # Store reference for keyboard toggling
          answer_elem.mathquill = answer_field

          # Disable soft keyboard for touch devices (conditionally)
          self.disable_soft_keyboard(answer_field)

          # ‚úÖ Build and insert minimal keyboard based on expected structure
          expected_structure = step_data.get('expected_structure')
          buttons_needed = self.build_minimal_keyboard_from_structure(expected_structure, step_data)

          keyboard_html = '<div class="minimal-keyboard" style="margin-top:12px;"><div style="display:grid;grid-template-columns:repeat(5,1fr);gap:4px;padding:8px;background:#f8fafc;border-radius:8px;border:1px solid #e2e8f0;">'
          for btn in buttons_needed:
              keyboard_html += self.create_keyboard_button_html(btn)
          keyboard_html += '</div></div>'

          answer_container = step_div.querySelector(".step-answer").parentElement
          keyboard_container = document.createElement("div")
          keyboard_container.innerHTML = keyboard_html
          answer_container.appendChild(keyboard_container)

          # Attach event handlers to keyboard buttons
          keyboard_btns = answer_container.querySelectorAll(".minimal-keyboard .input-btn")
          for i in range(keyboard_btns.length):
              btn = keyboard_btns[i]
              action = btn.getAttribute("data-action")
              if action:
                  def make_handler(mq, act):
                      def handler(e):
                          e.preventDefault()
                          KeyboardInputHandler.handle_action(mq, act)
                      return handler
                  btn.addEventListener("click", create_proxy(make_handler(answer_field, action)))

          window.console.log(f"‚úÖ Minimal keyboard created with {len(buttons_needed)} buttons")
      else:
          answer_field = None

      step_div.answer_mf = answer_field
      step_div.step_data = step_data

      # Submit button - checks correctness only
      submit_btn = step_div.querySelector(".submit-step")
      if submit_btn:
          def submit_handler(e):
              self.submit_math_expression(step_idx)
          submit_btn.addEventListener("click", create_proxy(submit_handler))

      # Finalize button - checks structure
      finalize_btn = step_div.querySelector(".finalize-step")
      if finalize_btn:
          def finalize_handler(e):
              self.finalize_math_expression(step_idx)
          finalize_btn.addEventListener("click", create_proxy(finalize_handler))

      # Next button
      next_btn = step_div.querySelector(".next-step")
      if next_btn:
          def next_handler(e):
              self.next_step(step_idx)
          next_btn.addEventListener("click", create_proxy(next_handler))
    
    def create_mc_single_ui(self, step_div, index, step_idx, step_data, desc_html, total_steps):
      """Create UI for multiple choice single answer"""
      options = step_data.get("options", [])
      must_correct = step_data.get("requireCorrect", False)  # ‚úÖ NEW

      # ‚úÖ NEW: Badge for must_correct
      must_correct_badge = ""
      if must_correct:
          must_correct_badge = "<span style='background:#fef3c7;color:#b45309;padding:4px 8px;border-radius:4px;font-size:12px;margin-left:8px;'>‚ö†Ô∏è Must be correct</span>"

      options_html = ""
      for opt in options:
          label = opt.get("label", "")
          content_blocks = opt.get("content", [])
          content_html = self.render_content_blocks(content_blocks)

          options_html += f"""
          <label class='mc-option' data-label='{label}'>
            <input type='radio' name='mc_single_{step_idx}' value='{label}'>
            <span>{content_html}</span>
          </label>
          """

      step_div.innerHTML = f"""
      <div style='font-weight:700;margin-bottom:8px;'>
          Step <span class='step-number-display'>{step_idx+1}</span> of {total_steps} {must_correct_badge}
      </div>
      <div class='step-description'>{desc_html}</div>
      <div style='margin-top:12px;'>
        <div style='font-weight:700;margin-bottom:8px;'>Select one answer:</div>
        {options_html}
        <button class='btn submit-step' style='margin-top:12px;'>Submit Answer</button>
        <button class='btn next-step' style='display:none;background:#10b981;'>Next Step ‚Üí</button>
      </div>
      <div id='stepFeedback{index}_{step_idx}' class='step-feedback'></div>
      """

      # Add click handlers to options
      option_labels = step_div.querySelectorAll(".mc-option")
      for i in range(option_labels.length):
          option = option_labels[i]
          def make_option_handler(opt):
              def handler(e):
                  radio = opt.querySelector("input[type='radio']")
                  if radio:
                      radio.checked = True
                  all_opts = step_div.querySelectorAll(".mc-option")
                  for j in range(all_opts.length):
                      all_opts[j].classList.remove("selected")
                  opt.classList.add("selected")
              return handler
          option.addEventListener("click", create_proxy(make_option_handler(option)))

      # Submit button
      submit_btn = step_div.querySelector(".submit-step")
      if submit_btn:
          def submit_handler(e):
              self.submit_mc_single(step_idx, step_data)
          submit_btn.addEventListener("click", create_proxy(submit_handler))

      # Next button
      next_btn = step_div.querySelector(".next-step")
      if next_btn:
          def next_handler(e):
              self.next_step(step_idx)
          next_btn.addEventListener("click", create_proxy(next_handler))
    
    def create_mc_multiple_ui(self, step_div, index, step_idx, step_data, desc_html, total_steps):
      """Create UI for multiple choice multiple answers"""
      options = step_data.get("options", [])
      must_correct = step_data.get("requireCorrect", False)  # ‚úÖ NEW

      # ‚úÖ NEW: Check localStorage for existing shuffle first
      shuffle_key = f"mc_multiple_shuffle_{index}_{step_idx}"
      stored_shuffle = window.localStorage.getItem(shuffle_key)

      if stored_shuffle:
          # Reuse existing shuffle to preserve user experience
          import json
          stored_data = json.loads(stored_shuffle)

          # Handle both old format (just labels) and new format (dict with labels and visible_correct)
          if isinstance(stored_data, list):
              # Old format - just labels
              stored_labels = stored_data
          else:
              # New format - dict with labels and visible_correct
              stored_labels = stored_data.get("labels", [])

          options = [opt for opt in options if opt.get("label", "") in stored_labels]
          # Restore original order from stored shuffle
          options.sort(key=lambda opt: stored_labels.index(opt.get("label", "")))
          window.console.log(f"‚ôªÔ∏è  MC-Multiple reusing stored shuffle: {stored_labels}")
      elif len(options) > 3:
          # First time: Shuffle algorithm for mc-multiple with >3 options
          # Display (total - 1) options, ensuring at least 2 correct answers are included
          import random
          import json
          correct_answers = set(step_data.get("correct_answers", []))

          # Separate correct and incorrect options
          correct_opts = [opt for opt in options if opt.get("label", "") in correct_answers]
          incorrect_opts = [opt for opt in options if opt.get("label", "") not in correct_answers]

          num_correct = len(correct_opts)
          num_to_display = len(options) - 1

          # Ensure at least 2 correct options are included
          if num_correct >= 2:
              # Determine how many correct and incorrect to include
              num_correct_to_include = min(num_correct, max(2, num_to_display - len(incorrect_opts)))
              num_incorrect_to_include = num_to_display - num_correct_to_include

              # Shuffle and select
              random.shuffle(correct_opts)
              random.shuffle(incorrect_opts)

              selected_correct = correct_opts[:num_correct_to_include]
              selected_incorrect = incorrect_opts[:num_incorrect_to_include]

              # Combine and shuffle again for display
              options = selected_correct + selected_incorrect
              random.shuffle(options)

              # Store the shuffled labels AND visible correct answers in localStorage
              shuffled_labels = [opt.get("label", "") for opt in options]
              visible_correct = [opt.get("label", "") for opt in options if opt.get("label", "") in correct_answers]

              shuffle_data = {
                  "labels": shuffled_labels,
                  "visible_correct": visible_correct
              }
              window.localStorage.setItem(shuffle_key, json.dumps(shuffle_data))

              window.console.log(f"üîÄ MC-Multiple shuffle: {len(step_data.get('options', []))} ‚Üí {len(options)} options ({len(visible_correct)} correct visible)")

      # üîç DEBUG: Log container state BEFORE recreation
      existing_checkboxes = step_div.querySelectorAll(f"input[name='mc_multiple_{step_idx}']")
      window.console.log(f"üîç BEFORE innerHTML: {existing_checkboxes.length} checkboxes in container")
      window.console.log(f"üîç Container element: {step_div.tagName}, id={step_div.id if step_div.id else 'no-id'}, class={step_div.className}")

      # ‚úÖ NEW: Badge for must_correct
      must_correct_badge = ""
      if must_correct:
          must_correct_badge = "<span style='background:#fef3c7;color:#b45309;padding:4px 8px;border-radius:4px;font-size:12px;margin-left:8px;'>‚ö†Ô∏è Must be correct</span>"

      options_html = ""
      for opt in options:
          label = opt.get("label", "")
          content_blocks = opt.get("content", [])
          content_html = self.render_content_blocks(content_blocks)

          options_html += f"""
          <label class='mc-option' data-label='{label}'>
            <input type='checkbox' name='mc_multiple_{step_idx}' value='{label}'>
            <span>{content_html}</span>
          </label>
          """

      step_div.innerHTML = f"""
      <div style='font-weight:700;margin-bottom:8px;'>
          Step <span class='step-number-display'>{step_idx+1}</span> of {total_steps} {must_correct_badge}
      </div>
      <div class='step-description'>{desc_html}</div>
      <div style='margin-top:12px;'>
        <div style='font-weight:700;margin-bottom:8px;'>Select all correct answers:</div>
        {options_html}
        <button class='btn submit-step' style='margin-top:12px;'>Submit Answer</button>
        <button class='btn next-step' style='display:none;background:#10b981;'>Next Step ‚Üí</button>
      </div>
      <div id='stepFeedback{index}_{step_idx}' class='step-feedback'></div>
      """

      # üîç DEBUG: Log container state AFTER recreation
      new_checkboxes = step_div.querySelectorAll(f"input[name='mc_multiple_{step_idx}']")
      window.console.log(f"üîç AFTER innerHTML: {new_checkboxes.length} checkboxes in container")

      # Add click handlers
      option_labels = step_div.querySelectorAll(".mc-option")
      for i in range(option_labels.length):
          option = option_labels[i]
          def make_option_handler(opt):
              def handler(e):
                  checkbox = opt.querySelector("input[type='checkbox']")
                  if not checkbox:
                      return

                  # If clicking directly on the checkbox, let it handle itself
                  # Otherwise, toggle it manually
                  if e.target.tagName.upper() != "INPUT":
                      e.preventDefault()
                      checkbox.checked = not checkbox.checked

                  # Update visual state based on checkbox state
                  if checkbox.checked:
                      opt.classList.add("selected")
                  else:
                      opt.classList.remove("selected")
              return handler
          option.addEventListener("click", create_proxy(make_option_handler(option)))

      submit_btn = step_div.querySelector(".submit-step")
      if submit_btn:
          def submit_handler(e):
              self.submit_mc_multiple(step_idx, step_data)
          submit_btn.addEventListener("click", create_proxy(submit_handler))

      next_btn = step_div.querySelector(".next-step")
      if next_btn:
          def next_handler(e):
              self.next_step(step_idx)
          next_btn.addEventListener("click", create_proxy(next_handler))

    def create_fill_blank_ui(self, step_div, index, step_idx, step_data, desc_html, total_steps, must_correct_badge):
      """Create UI for fill-in-the-blank questions (both single and multi-blank)"""
      import html as html_module

      # Use unified method to detect blank mode
      is_multi_blank = self._detect_blank_mode(step_data)
      correct_answers = step_data.get("correct_answers", {})

      if is_multi_blank:
          window.console.log(f"üîß Creating Multi-blank UI for step {step_idx}")
          
          # Replace {blank} with inline text inputs
          if isinstance(correct_answers, dict):
              labels = sorted(correct_answers.keys())
              for label in labels:
                  # Create inline input for each blank
                  input_html = f"""<input
                      type='text'
                      class='fill-blank-input fill-blank-{label}'
                      data-blank-label='{label}'
                      style='display:inline-block;min-width:150px;max-width:250px;padding:8px 12px;
                             border:2px solid #0b6efd;border-radius:6px;font-size:16px;
                             margin:0 4px;vertical-align:middle;'
                      placeholder='({label})'
                  />"""
                  # Replace first occurrence of {blank} with the input field
                  desc_html = desc_html.replace("{blank}", input_html, 1)
          else:
              # Fallback: just replace with single input
              input_html = f"""<input
                  type='text'
                  class='fill-blank-input'
                  style='display:inline-block;min-width:150px;max-width:250px;padding:8px 12px;
                         border:2px solid #0b6efd;border-radius:6px;font-size:16px;
                         margin:0 4px;vertical-align:middle;'
                  placeholder='answer'
              />"""
              desc_html = desc_html.replace("{blank}", input_html)
      else:
          window.console.log(f"üîß Creating Single-blank UI for step {step_idx}")
          
          # Replace ___ or {blank} with inline text input
          input_html = f"""<input
              type='text'
              class='fill-blank-input'
              style='display:inline-block;min-width:150px;max-width:250px;padding:8px 12px;
                     border:2px solid #0b6efd;border-radius:6px;font-size:16px;
                     margin:0 4px;vertical-align:middle;'
              placeholder='answer'
          />"""
          
          # Replace both ___ and {blank} with input field
          if "___" in desc_html:
              desc_html = desc_html.replace("___", input_html, 1)
          elif "{blank}" in desc_html:
              desc_html = desc_html.replace("{blank}", input_html, 1)
          else:
              # No placeholder found, add input at the end
              desc_html += f"<br><br>{input_html}"

      html_content = f"""
          <div class='step-header'>
              <div style='font-weight:700;font-size:18px;margin-bottom:12px;'>
                  Step <span class='step-number-display'>{step_idx + 1}</span> of {total_steps} {must_correct_badge}
              </div>
          </div>

          <div class='step-description' style='font-size:16px;line-height:2.5;'>
              {desc_html}
          </div>

          <div style='margin-top:20px;'>
              <button id='submitBtn{step_idx}' class='btn-primary' style='padding:10px 24px;'>
                  {'Submit Answers' if is_multi_blank else 'Submit Answer'}
              </button>
          </div>

          <div id='stepFeedback{index}_{step_idx}'></div>
      """

      # Set innerHTML
      step_div.innerHTML = html_content
      window.console.log(f"üìù Fill-blank HTML set for step {step_idx} ({'multi' if is_multi_blank else 'single'}-blank mode)")

      # Wire up submit button
      submit_btn = step_div.querySelector(f"#submitBtn{step_idx}")

      if submit_btn:
          window.console.log(f"‚úÖ Found submit button for fill-blank step {step_idx}")

          def submit_handler(event):
              window.console.log(f"üîò Fill-blank submit button clicked for step {step_idx}")
              try:
                  self.submit_fill_blank(step_idx, step_data)
              except Exception as e:
                  window.console.error(f"Error in submit handler: {e}")
                  import traceback
                  window.console.error(traceback.format_exc())

          submit_btn.addEventListener("click", create_proxy(submit_handler))
          window.console.log(f"‚úÖ Handler attached for fill-blank step {step_idx}")
      else:
          window.console.error(f"‚ùå Submit button NOT FOUND for fill-blank step {step_idx}")

      window.console.log(f"‚úÖ Fill-blank UI creation complete for step {step_idx}")

    def create_multi_mc_ui(self, step_div, index, step_idx, step_data, desc_html, total_steps):
      """Create UI for multi-mc (fill-blank with inline dropdown selectors)"""
      import re

      window.console.log(f"üîß Creating multi-mc UI for step {step_idx}")

      blanks = step_data.get("blanks", {})
      window.console.log(f"üìã Blanks data: {blanks}")

      must_correct = step_data.get("requireCorrect", False)

      # Badge for must_correct
      must_correct_badge = ""
      if must_correct:
          must_correct_badge = "<span style='background:#fef3c7;color:#b45309;padding:4px 8px;border-radius:4px;font-size:12px;margin-left:8px;'>‚ö†Ô∏è Must be correct</span>"

      # Parse desc_html to find {blank} placeholders and replace with dropdowns
      # Count blanks in description
      blank_count = len(re.findall(r'\{blank\}', desc_html))

      # Replace each {blank} with a dropdown
      modified_desc = desc_html
      blank_index = 0
      blank_labels = sorted(blanks.keys())

      for i in range(blank_count):
          if i < len(blank_labels):
              label = blank_labels[i]
              blank_data = blanks[label]
              options = blank_data.get("options", [])

              # Build dropdown HTML
              options_html = "<option value=''>--</option>"
              for opt in options:
                  options_html += f"<option value='{opt}'>{opt}</option>"

              dropdown_html = f"""<select class='multi-mc-dropdown' data-blank-label='{label}' data-step-idx='{step_idx}' style='padding:4px 8px; border:2px solid #0b6efd; border-radius:4px; font-size:14px; background:white;'>{options_html}</select>"""

              # Replace first occurrence of {blank}
              modified_desc = modified_desc.replace('{blank}', dropdown_html, 1)

      step_div.innerHTML = f"""
      <div style='font-weight:700;margin-bottom:8px;'>
          Step <span class='step-number-display'>{step_idx+1}</span> of {total_steps} {must_correct_badge}
      </div>
      <div class='step-description' style='font-size:16px; line-height:1.8;'>{modified_desc}</div>
      <div style='margin-top:20px;'>
        <button class='btn submit-step'>Submit Answer</button>
        <button class='btn next-step' style='display:none;background:#10b981;'>Next Step ‚Üí</button>
      </div>
      <div id='stepFeedback{index}_{step_idx}' class='step-feedback'></div>
      """

      # Submit button
      submit_btn = step_div.querySelector(".submit-step")
      window.console.log(f"üìã Submit button found: {submit_btn is not None}")
      if submit_btn:
          def submit_handler(e):
              window.console.log(f"üñ±Ô∏è Submit button clicked for step {step_idx}")
              self.submit_multi_mc(step_idx, step_data)
          submit_btn.addEventListener("click", create_proxy(submit_handler))
          window.console.log(f"‚úÖ Event handler attached to submit button")

      # Next button
      next_btn = step_div.querySelector(".next-step")
      if next_btn:
          def next_handler(e):
              self.next_step(step_idx)
          next_btn.addEventListener("click", create_proxy(next_handler))

    def create_truefalse_ui(self, step_div, index, step_idx, step_data, desc_html, total_steps):
      """Create true/false UI"""

      window.console.log(f"üîß Creating True/False UI for step {step_idx}")

      html = f"""
          <div class='step-header'>
              <div style='font-weight:700;font-size:18px;margin-bottom:12px;'>Step <span class='step-number-display'>{step_idx + 1}</span> of {total_steps}</div>
          </div>

          <div class='step-description'>
              {desc_html}
          </div>

          <div class='tf-options' style='margin:20px 0;'>
              <label style='display:block;padding:12px;border:2px solid #cbd5e1;border-radius:8px;margin-bottom:12px;cursor:pointer;'>
                  <input type='radio' name='tf_{step_idx}' value='true' style='margin-right:8px;'>
                  <span style='font-size:16px;'>True</span>
              </label>
              <label style='display:block;padding:12px;border:2px solid #cbd5e1;border-radius:8px;cursor:pointer;'>
                  <input type='radio' name='tf_{step_idx}' value='false' style='margin-right:8px;'>
                  <span style='font-size:16px;'>False</span>
              </label>
          </div>

          <div style='margin-top:20px;'>
              <button id='submitBtn{step_idx}' class='btn-primary' style='padding:10px 24px;'>
                  Submit Answer
              </button>
          </div>

          <div id='stepFeedback{index}_{step_idx}'></div>
      """

      step_div.innerHTML = html
      window.console.log(f"üìù HTML set for step {step_idx}")

      # ‚úÖ CRITICAL: Attach handler IMMEDIATELY (no setTimeout)
      submit_btn = step_div.querySelector(f"#submitBtn{step_idx}")

      if submit_btn:
          window.console.log(f"üîç Found button immediately after innerHTML")

          def submit_handler(event):
              window.console.log(f"üîò True/False submit button clicked for step {step_idx}")
              try:
                  self.submit_true_false(step_idx, step_data)
                  window.console.log("‚úÖ submit_true_false completed")
              except Exception as e:
                  window.console.error(f"‚ùå Error: {e}")
                  import traceback
                  window.console.error(traceback.format_exc())

          submit_btn.onclick = create_proxy(submit_handler)
          window.console.log(f"‚úÖ Handler attached, onclick={submit_btn.onclick}")

          # Verify it stuck
          if submit_btn.onclick:
              window.console.log(f"‚úÖ‚úÖ VERIFIED: Handler is attached!")
          else:
              window.console.error(f"‚ùå‚ùå FAILED: Handler didn't stick!")
      else:
          window.console.error(f"‚ùå Button not found immediately after innerHTML")

      window.console.log(f"‚úÖ True/False UI complete for step {step_idx}")
    
    def finalize_math_expression(self, step_idx):
      """Handle finalization for math expression problems - checks structure"""
      window.console.log(f"üîç Finalize step: problem {self.current_problem_index}, step {step_idx}")

      # ‚úÖ Animate step numbers when finalize is clicked
      self._animate_step_numbers()

      if step_idx >= len(self.solve_state):
          window.console.error(f"‚ùå Invalid state")
          window.alert("Error: Invalid step state. Please reload the problem.")
          return

      step = self.solve_state[step_idx]
      step_data = step.get("step_data") or step.get("step", {})
      container = step["container"]

      # ‚úÖ Check if answer is correct before allowing finalization
      if not step.get("correct"):
          must_correct = step_data.get("requireCorrect", False)
          if must_correct:
              self.show_feedback(step_idx, "‚ùå Submit correct answer first. This step requires the correct answer to proceed.", "#b91c1c")
          else:
              self.show_feedback(step_idx, "‚ùå Submit correct answer first", "#b91c1c")
          return

      # Get stored parsed expressions from submit
      parsed_user = step.get("parsed_user_answer")
      parsed_expected = step.get("parsed_expected_answer")

      if parsed_user is None or parsed_expected is None:
          self.show_feedback(step_idx, "‚ö†Ô∏è Could not validate structure. Finalized (no structure check).", "#92400e")
          self._finalize_step_ui(step_idx)
          return

      # Get expected structure from step data
      expected_struct = step_data.get("expected_structure")

      if not expected_struct:
          window.console.warn("‚ö†Ô∏è No expected_structure, finalizing without structure check")
          self._finalize_step_ui(step_idx)
          return

      # Extract user structure from parsed expression
      try:
          user_struct = self.math_parser.extract_structure(parsed_user)

          window.console.log("=" * 60)
          window.console.log("üìä STRUCTURE COMPARISON")
          window.console.log("=" * 60)
          window.console.log(f"Expected structure:")
          window.console.log(f"  Operators: {expected_struct.get('operators', {})}")
          window.console.log(f"  Operands: {expected_struct.get('operands', {})}")
          window.console.log(f"  Matrix ops: {expected_struct.get('matrix_ops', [])}")
          window.console.log(f"User structure:")
          window.console.log(f"  Operators: {user_struct.get('operators', {})}")
          window.console.log(f"  Operands: {user_struct.get('operands', {})}")
          window.console.log(f"  Matrix ops: {user_struct.get('matrix_ops', [])}")
          window.console.log("=" * 60)

      except Exception as e:
          window.console.error(f"‚ùå Structure extraction error: {e}")
          import traceback
          window.console.error(traceback.format_exc())

          self.show_feedback(step_idx, "‚ö†Ô∏è Error analyzing structure. Finalized (no structure check).", "#92400e")
          self._finalize_step_ui(step_idx)
          return

      # Track finalize attempts
      if not step.get("finalize_attempts"):
          step["finalize_attempts"] = 0
      step["finalize_attempts"] += 1

      # Compare structures
      same_operators = user_struct.get("operators", {}) == expected_struct.get("operators", {})
      same_operands = user_struct.get("operands", {}) == expected_struct.get("operands", {})
      same_matrix_ops = user_struct.get("matrix_ops", []) == expected_struct.get("matrix_ops", [])

      same_structure = same_operators and same_operands and same_matrix_ops

      window.console.log(f"  Operators match: {same_operators}")
      window.console.log(f"  Operands match: {same_operands}")
      window.console.log(f"  Matrix ops match: {same_matrix_ops}")
      window.console.log(f"üéØ Structure match result: {same_structure}")

      if same_structure:
          # ‚úÖ SUCCESS - finalize and proceed
          window.console.log("‚úÖ STRUCTURE MATCH - Finalizing step")

          step["structure_correct"] = True

          # ‚úÖ CRITICAL: Update problem_states
          current_prob_idx = self.current_problem_index
          if current_prob_idx is not None and current_prob_idx in self.problem_states:
              if step_idx < len(self.problem_states[current_prob_idx]):
                  self.problem_states[current_prob_idx][step_idx]["structure_correct"] = True
                  window.console.log(f"‚úÖ Updated problem_states: structure_correct=True")

          # ‚è±Ô∏è Stop timer and get total elapsed time for this step
          time_taken = 0
          if current_prob_idx is not None:
              time_taken = self.end_step_timer(current_prob_idx, step_idx, is_first_attempt=False)
              if time_taken is None:
                  time_taken = 0
              window.console.log(f"‚è±Ô∏è Step {step_idx} total time (finalize): {time_taken:.1f}s")

          self.show_feedback(step_idx, "‚úÖ Finalized ‚Äî your solution method matches perfectly!", "#059669")

          # Disable buttons
          finalize_btn = container.querySelector(".finalize-step")
          if finalize_btn:
              finalize_btn.disabled = True
              finalize_btn.style.opacity = "0.5"

          submit_btn = container.querySelector(".submit-step")
          if submit_btn:
              submit_btn.disabled = True
              submit_btn.style.opacity = "0.5"

          # Show next button
          next_btn = container.querySelector(".next-step")
          if next_btn:
              next_btn.style.display = "block"

          # ‚úÖ Add to global history with actual elapsed time
          user_latex = step.get("last_correct_latex", "")
          self.add_to_global_history(step_idx, user_latex, True, time_taken, "finalize")

          # ‚úÖ Mark step as finished (this will update problem_states and check completion)
          self._mark_step_finished(step_idx)

      else:
          # ‚ùå FAILED - keep trying
          window.console.log("‚ùå STRUCTURE MISMATCH - Not finalizing")

          step["finished"] = False
          step["structure_correct"] = False

          # ‚úÖ CRITICAL: Update problem_states too
          current_prob_idx = self.current_problem_index
          if current_prob_idx is not None and current_prob_idx in self.problem_states:
              if step_idx < len(self.problem_states[current_prob_idx]):
                  self.problem_states[current_prob_idx][step_idx]["finished"] = False
                  self.problem_states[current_prob_idx][step_idx]["structure_correct"] = False
                  window.console.log(f"‚úÖ Updated problem_states: structure_correct=False")

          # ‚è±Ô∏è Get elapsed time (but don't stop timer since user will try again)
          time_taken = 0
          if current_prob_idx is not None:
              time_summary = self.get_step_time_summary(current_prob_idx, step_idx)
              time_taken = time_summary.get("total_time", 0)
              window.console.log(f"‚è±Ô∏è Step {step_idx} elapsed time so far (failed finalize): {time_taken:.1f}s")

          # Build detailed feedback
          msg_parts = [f"‚ùå Attempt {step['finalize_attempts']}: Structure mismatch.<br><br>"]

          if not same_operators and not same_operands:
              msg_parts.append(
                  "<strong>Both operations and values differ.</strong><br>"
                  f"<small>Expected: ops={expected_struct.get('operators', {})}, vals={expected_struct.get('operands', {})}</small><br>"
                  f"<small>Yours: ops={user_struct.get('operators', {})}, vals={user_struct.get('operands', {})}</small><br><br>"
              )
          elif not same_operators:
              msg_parts.append(
                  "<strong>Same values, different method.</strong><br>"
                  f"<small>Expected operators: {expected_struct.get('operators', {})}</small><br>"
                  f"<small>Your operators: {user_struct.get('operators', {})}</small><br><br>"
              )
          elif not same_operands:
              msg_parts.append(
                  "<strong>Correct operations, different values.</strong><br>"
                  f"<small>Expected values: {expected_struct.get('operands', {})}</small><br>"
                  f"<small>Your values: {user_struct.get('operands', {})}</small><br><br>"
              )

          if not same_matrix_ops:
              msg_parts.append(
                  "<strong>üî¢ Matrix operations differ:</strong><br>"
                  f"<small>Expected: {expected_struct.get('matrix_ops', [])}</small><br>"
                  f"<small>Yours: {user_struct.get('matrix_ops', [])}</small><br><br>"
              )

          msg_parts.append("<strong>üí° Try a different approach and click Finalize again.</strong>")
          msg = "".join(msg_parts)

          self.show_feedback(step_idx, msg, "#dc2626")

          # ‚úÖ Add failed finalize to global history with elapsed time
          user_latex = step.get("last_correct_latex", "")
          self.add_to_global_history(step_idx, user_latex, False, time_taken, "finalize")

          finalize_btn = container.querySelector(".finalize-step")
          if finalize_btn:
              finalize_btn.disabled = True
              finalize_btn.style.opacity = "0.5"

          # Enable submit button again
          submit_btn = container.querySelector(".submit-step")
          if submit_btn:
              submit_btn.disabled = False
              submit_btn.style.opacity = "1"

          # Save state (but don't mark as finished)
          self.save_to_storage()

    def _mark_step_finished(self, step_idx):
      """Mark a step as finished and trigger all related updates"""
      current_prob_idx = self.current_problem_index

      if current_prob_idx is None:
          window.console.error("‚ùå No current problem index")
          return

      # ‚úÖ Update solve_state (UI state)
      if step_idx >= len(self.solve_state):
          window.console.error(f"‚ùå Invalid step_idx: {step_idx}")
          return

      step = self.solve_state[step_idx]
      step["finished"] = True

      # ‚úÖ CRITICAL: Update problem_states (persisted state)
      if current_prob_idx in self.problem_states and step_idx < len(self.problem_states[current_prob_idx]):
          self.problem_states[current_prob_idx][step_idx]["finished"] = True
          self.problem_states[current_prob_idx][step_idx]["correct"] = step.get("correct", False)
          self.problem_states[current_prob_idx][step_idx]["user_answers"] = step.get("user_answers", [])
          self.problem_states[current_prob_idx][step_idx]["structure_correct"] = step.get("structure_correct", False)
          window.console.log(f"‚úÖ Updated problem_states for problem {current_prob_idx}, step {step_idx}")

      # Debug: Log all step statuses
      window.console.log("=" * 50)
      window.console.log(f"‚úÖ Step {step_idx} marked as finished")
      window.console.log(f"Current solve_state status:")
      for i, s in enumerate(self.solve_state):
          status = "‚úÖ DONE" if s.get("finished", False) else "‚è≥ TODO"
          window.console.log(f"  Step {i}: {status}")
      window.console.log("=" * 50)

      # IMPORTANT: Save to storage FIRST so problem_states is persisted
      self.save_to_storage()

      # Then update UI
      if current_prob_idx is not None:
          self.update_problem_progress(current_prob_idx)

      # ‚úÖ NEW: Check if this problem is now complete and handle accordingly
      self._check_problem_completion_and_show_next_step(step_idx)
      
    def update_problem_progress(self, problem_idx):
      """Update the progress summary in the problem accordion header"""
      if problem_idx >= len(self.problem_set):
          return

      # Get the problem
      problem = self.problem_set[problem_idx]
      title = problem.get("title", f"Problem {problem_idx+1}")
      steps = problem.get("steps", [])
      total = len(steps)

      # Count finished steps
      if problem_idx == self.current_problem_index and hasattr(self, 'solve_state'):
          # Use current solve_state
          finished = sum(1 for s in self.solve_state if s.get("finished", False))
          window.console.log(f"üìä Counting from solve_state: {finished}/{total}")
      elif problem_idx in self.problem_states:
          # Use saved state
          finished = sum(1 for s in self.problem_states[problem_idx] if s.get("finished", False))
          window.console.log(f"üìä Counting from problem_states: {finished}/{total}")
      else:
          finished = 0
          window.console.log(f"üìä No state found, defaulting to 0/{total}")

      window.console.log(f"üìä Problem {problem_idx} progress: {finished}/{total} steps finished")

      # Update the UI
      accordion = document.querySelector(f".accordion-problem[data-index='{problem_idx}']")
      if not accordion:
          window.console.error(f"‚ùå Accordion not found for problem {problem_idx}")
          return

      header = accordion.querySelector(".accordion-header")
      if not header:
          window.console.error(f"‚ùå Header not found for problem {problem_idx}")
          return

      is_done = finished == total and total > 0

      if is_done:
          # ‚úÖ Problem completed - show non-math count immediately

          # Count must-not-be-correct questions (where must_correct is False)
          non_math_count = 0
          for step in steps:
              if step.get("requireCorrect") == False:
                  non_math_count += 1

          window.console.log(f"Problem {problem_idx} completed with {non_math_count} non-math questions")

          # Build completion message with non-math count
          if non_math_count > 0:
              header.innerHTML = f"""
              <span>{problem_idx+1}. {html.escape(title)}</span>
              <span class='progress-summary' style='color:#059669;display:flex;align-items:center;gap:8px;'>
                  <span style='font-size:20px;'>üéâ</span>
                  <span style='font-weight:700;'>Completed! (non-math: {non_math_count})</span>
              </span>
              """
          else:
              header.innerHTML = f"""
              <span>{problem_idx+1}. {html.escape(title)}</span>
              <span class='progress-summary' style='color:#059669;display:flex;align-items:center;gap:8px;'>
                  <span style='font-size:20px;'>üéâ</span>
                  <span style='font-weight:700;'>Completed!</span>
              </span>
              """

          header.style.background = "#f0fdf4"
          accordion.classList.add("finished")

          window.console.log(f"‚úÖ Problem {problem_idx} marked as completed (non-math: {non_math_count})")
      else:
          # ‚úÖ Problem incomplete - show progress
          progress_color = "#6b7280"

          header.innerHTML = f"""
          <span>{problem_idx+1}. {html.escape(title)}</span>
          <span class='progress-summary' style='color:{progress_color}'>‚úÖ {finished}/{total} completed</span>
          """

          header.style.background = "#f0f4ff"
          accordion.classList.remove("finished")

          window.console.log(f"‚úÖ Updated progress display to: {finished}/{total}")
    
    def finalize_step(self, step_idx):
        """Finalize a step - marks it as finished and saves to storage"""
        window.console.log(f"üîç Finalize step: problem {self.current_problem_index}, step {step_idx}")

        # Get current problem index
        current_prob_idx = self.current_problem_index
        if current_prob_idx is None:
            window.console.error("‚ùå No current problem index")
            return

        # ‚úÖ CRITICAL: Mark step as finished in problem_states FIRST
        if current_prob_idx in self.problem_states:
            if step_idx < len(self.problem_states[current_prob_idx]):
                self.problem_states[current_prob_idx][step_idx]["finished"] = True
                window.console.log(f"‚úÖ Step {step_idx} marked as finished in problem_states")

        # ‚úÖ Mark step as finished in solve_state
        if current_prob_idx in self.solve_states:
            solve_state = self.solve_states[current_prob_idx]
            if step_idx < len(solve_state):
                solve_state[step_idx]["finished"] = True
                window.console.log(f"‚úÖ Step {step_idx} marked as finished in solve_state")

        # ‚úÖ CRITICAL: Save to storage IMMEDIATELY
        self.save_to_storage()
        window.console.log("üíæ Completion saved to storage")

        # Update progress display
        self.update_problem_progress(current_prob_idx)

        # Hide finalize button
        finalize_btn = document.querySelector(f"#finalizeBtn{step_idx}")
        if finalize_btn:
            finalize_btn.style.display = "none"

        # Show finalized message
        feedback_div = document.querySelector(f"#stepFeedback{current_prob_idx}_{step_idx}")
        if feedback_div:
            feedback_div.innerHTML = """
                <div style='background:#dbeafe;color:#1e40af;padding:16px;border-radius:8px;text-align:center;margin-top:12px;'>
                    <div style='font-size:20px;margin-bottom:8px;'>üîí</div>
                    <div style='font-weight:700;margin-bottom:4px;'>Step Finalized!</div>
                    <div style='font-size:14px;'>Your answer has been locked in.</div>
                </div>
            """

        # ‚úÖ Check completion status
        window.console.log("üîç Checking completion status...")

        # Count finished steps
        finished_count = self.count_finished_steps(current_prob_idx)
        total_steps = len(self.problem_states[current_prob_idx])

        window.console.log(f"Problem {current_prob_idx}: {finished_count}/{total_steps} steps finished")

        if finished_count >= total_steps:
            # This problem is complete!
            window.console.log(f"‚úÖ Problem {current_prob_idx} is now complete!")

            # ‚úÖ Save again to ensure completion is recorded
            self.save_to_storage()

            # Show completion banner
            self.show_problem_completion_banner(current_prob_idx)

            # ‚úÖ Check if ALL problems are complete
            if self._all_problems_complete():
                window.console.log("üéâ ALL PROBLEMS COMPLETE! Showing review...")

                # Small delay to let user see the completion message
                def show_review_delayed():
                    self.show_review_section()

                window.setTimeout(create_proxy(show_review_delayed), 1500)
            else:
                # Show which problems remain
                remaining = []
                for prob_idx in self.problem_states.keys():
                    if not self.is_problem_complete(prob_idx):
                        remaining.append(prob_idx + 1)

                window.console.log(f"Problems remaining: {remaining}")
        else:
            # Continue to next step in this problem
            window.console.log(f"Problem {current_prob_idx} not complete yet, continuing...")

            # Find and show next unfinished step
            next_step_idx = None
            for i, step_data in enumerate(self.problem_states[current_prob_idx]):
                if not step_data.get("finished", False):
                    next_step_idx = i
                    break

            if next_step_idx is not None:
                window.console.log(f"üìç Next unfinished step: {next_step_idx}")

                # ‚úÖ Stop timer for the finalized step
                elapsed = self.end_step_timer(current_prob_idx, step_idx, is_first_attempt=True)
                window.console.log(f"‚è±Ô∏è Stopped timer for step {step_idx} (elapsed: {elapsed:.1f}s)")

                # ‚úÖ Start timer for next step
                self.start_step_timer(current_prob_idx, next_step_idx, is_first_attempt=True)
                window.console.log(f"‚è±Ô∏è Started timer for step {next_step_idx}")

                # ‚úÖ Use next_step function with animations
                self.next_step(step_idx)

                      
    def show_problem_completion_banner(self, prob_idx):
        """Show a banner when a problem is completed"""
        # Find the problem body
        problem_body = document.querySelector(f"#problemBody{prob_idx}")
        if not problem_body:
            return

        # Remove any existing banner
        existing_banner = document.querySelector(f"#completionBanner_{prob_idx}")
        if existing_banner:
            existing_banner.remove()

        # Create completion banner
        banner = document.createElement("div")
        banner.id = f"completionBanner_{prob_idx}"
        banner.style.cssText = """
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
            text-align: center;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
        """

        # Calculate this problem's score
        total_score, max_score, problem_scores = self.calculate_total_score()
        prob_score_info = problem_scores.get(prob_idx, {'score': 0, 'max_score': 0, 'percentage': 0})

        banner.innerHTML = f"""
            <div style="font-size: 32px; margin-bottom: 8px;">üéâ</div>
            <div style="font-size: 20px; font-weight: 700; margin-bottom: 8px;">
                Problem {prob_idx + 1} Complete!
            </div>
            <!--
            <div style="font-size: 16px; opacity: 0.9;">
                Score: {prob_score_info['percentage']:.1f}% ({prob_score_info['score']:.1f}/{prob_score_info['max_score']:.1f} points)
            </div>
            -->
        """

        # Insert at top of problem body
        if problem_body.firstChild:
            problem_body.insertBefore(banner, problem_body.firstChild)
        else:
            problem_body.appendChild(banner)

        window.console.log(f"‚úÖ Completion banner shown for problem {prob_idx}")
    
    def test_state_update(self):
      """Diagnostic: Test if problem_states updates work"""
      window.console.log("üß™ TESTING STATE UPDATE...")

      # Test updating problem 0, step 0
      if 0 in self.problem_states and len(self.problem_states[0]) > 0:
          window.console.log(f"Before: problem_states[0][0] = {self.problem_states[0][0]}")

          # Try to update
          self.problem_states[0][0]["finished"] = True
          self.problem_states[0][0]["correct"] = True

          window.console.log(f"After: problem_states[0][0] = {self.problem_states[0][0]}")

          # Try to save
          self.save_to_storage()

          window.console.log("üß™ Test complete - check if save shows 1/6 finished")
      else:
          window.console.log("‚ùå problem_states[0] doesn't exist")
    # ============================================
    # ALL SUBMIT METHODS - UNIFIED STATE MANAGEMENT
    # ============================================

    def submit_mc_single(self, step_idx, step_data):
        """Submit multiple choice single answer"""
        current_prob_idx = self.current_problem_index
        if current_prob_idx is None:
            window.console.error("‚ùå No current problem index")
            return

        # Get selected answer
        selected = document.querySelector(f"input[name='mc_single_{step_idx}']:checked")
        if not selected:
            window.console.warn("No answer selected")

            # Show warning - query within current problem container
            problem_container = document.querySelector(f".accordion-problem[data-index='{current_prob_idx}']")
            feedback_div = problem_container.querySelector(f"#stepFeedback{current_prob_idx}_{step_idx}") if problem_container else None
            if feedback_div:
                feedback_div.innerHTML = """
                    <div style='background:#fef2f2;color:#dc2626;padding:12px;border-radius:8px;margin-top:12px;'>
                        ‚ö†Ô∏è Please select an answer
                    </div>
                """
            return

        user_answer = selected.value
        correct_answer = step_data.get("correct_answer", "")
        is_correct = (user_answer == correct_answer)
        must_correct = step_data.get("requireCorrect", False)
        score_percentage = 100.0 if is_correct else 0.0

        window.console.log(f"MC Single: user={user_answer}, correct={correct_answer}, is_correct={is_correct}, score={score_percentage:.1f}%, must_correct={must_correct}")

        # ‚è±Ô∏è Get elapsed time for this attempt
        import js
        current_time = js.Date.now()
        time_taken = 0
        if hasattr(self, 'step_timers') and current_prob_idx in self.step_timers:
            step_time = self.step_timers[current_prob_idx].get(step_idx, {})
            start_time = step_time.get("start", None)
            if start_time:
                time_taken = (current_time - start_time) / 1000.0  # Convert to seconds

        # ‚úÖ CRITICAL: Update BOTH solve_state AND problem_states
        if current_prob_idx in self.solve_states and step_idx < len(self.solve_states[current_prob_idx]):
            self.solve_states[current_prob_idx][step_idx]["finished"] = True
            self.solve_states[current_prob_idx][step_idx]["correct"] = is_correct
            self.solve_states[current_prob_idx][step_idx]["score"] = score_percentage
            self.solve_states[current_prob_idx][step_idx]["user_answers"] = [user_answer]
            window.console.log(f"‚úÖ Updated solve_state: Step {step_idx}, finished=True, score={score_percentage:.1f}%")

        # ‚úÖ CRITICAL: Update problem_states (persisted state)
        if current_prob_idx in self.problem_states and step_idx < len(self.problem_states[current_prob_idx]):
            self.problem_states[current_prob_idx][step_idx]["finished"] = True
            self.problem_states[current_prob_idx][step_idx]["correct"] = is_correct
            self.problem_states[current_prob_idx][step_idx]["score"] = score_percentage
            self.problem_states[current_prob_idx][step_idx]["user_answers"] = [user_answer]
            attempts = self.problem_states[current_prob_idx][step_idx].get("attempts", 0)
            self.problem_states[current_prob_idx][step_idx]["attempts"] = attempts + 1

            # ‚úÖ Add to attempt_history array
            if "attempt_history" not in self.problem_states[current_prob_idx][step_idx]:
                self.problem_states[current_prob_idx][step_idx]["attempt_history"] = []

            attempt_entry = {
                "timestamp": current_time,
                "time_taken": time_taken,
                "correct": is_correct,
                "score": score_percentage,
                "user_answer": user_answer
            }
            self.problem_states[current_prob_idx][step_idx]["attempt_history"].append(attempt_entry)

            window.console.log(f"‚úÖ Updated problem_states: Problem {current_prob_idx}, Step {step_idx}, finished=True, correct={is_correct}, score={score_percentage:.1f}%, time={time_taken:.1f}s")

        # Mark step as finished
        window.console.log("==================================================")
        window.console.log(f"‚úÖ Step {step_idx} marked as finished")
        window.console.log("Current solve_state status:")
        for i, step in enumerate(self.solve_states[current_prob_idx]):
            status = "‚úÖ DONE" if step.get("finished") else "‚è≥ TODO"
            window.console.log(f"  Step {i}: {status}")
        window.console.log("==================================================")

        # ‚úÖ CRITICAL: Check requireCorrect BEFORE showing feedback
        # This ensures blocking happens even if feedback_div is not found
        if not is_correct and must_correct:
            window.console.log("üö´ BLOCKING PROGRESSION: requireCorrect=True and answer is incorrect")
            # Show flashing notification
            self.show_notification("‚ùå Incorrect! This step requires the correct answer.", "error")
            # Reset finished status if must be correct
            if current_prob_idx in self.solve_states and step_idx < len(self.solve_states[current_prob_idx]):
                self.solve_states[current_prob_idx][step_idx]["finished"] = False
                window.console.log(f"‚úÖ Reset solve_states[{current_prob_idx}][{step_idx}]['finished'] = False")
            if current_prob_idx in self.problem_states and step_idx < len(self.problem_states[current_prob_idx]):
                self.problem_states[current_prob_idx][step_idx]["finished"] = False
                window.console.log(f"‚úÖ Reset problem_states[{current_prob_idx}][{step_idx}]['finished'] = False")

            # üîÑ RESHUFFLE OPTIONS
            if "options" in step_data and len(step_data["options"]) > 0:
                window.console.log("üîÑ Reshuffling MC options")
                self.shuffle_array(step_data["options"])

                # Recreate the UI with shuffled options
                if current_prob_idx in self.solve_states and step_idx < len(self.solve_states[current_prob_idx]):
                    container = self.solve_states[current_prob_idx][step_idx].get("container")
                    if container:
                        # Get problem data to get total steps
                        problem = self.problem_set[current_prob_idx]
                        total_steps = len(problem.get("steps", []))
                        desc_html = self.render_content_blocks(step_data.get("description", []))

                        # Recreate mc-single UI with shuffled options
                        self.create_mc_single_ui(container, step_idx, step_data, desc_html, total_steps)
                        window.console.log("‚úÖ Recreated MC-Single UI with shuffled options")

                        # Store step_data reference for future submits
                        container.step_data = step_data

            # ‚úÖ ALWAYS show feedback - find or create feedback div within current problem
            problem_container = document.querySelector(f".accordion-problem[data-index='{current_prob_idx}']")
            if not problem_container:
                window.console.error(f"‚ùå Problem container not found for problem {current_prob_idx}")
                self.save_to_storage()
                return

            feedback_div = problem_container.querySelector(f"#stepFeedback{current_prob_idx}_{step_idx}")
            window.console.log(f"üîç MC-Single: Looking for #stepFeedback{step_idx}, found: {feedback_div is not None}")

            if not feedback_div:
                # Try to find step container
                if current_prob_idx in self.solve_states and step_idx < len(self.solve_states[current_prob_idx]):
                    container = self.solve_states[current_prob_idx][step_idx].get("container")
                    window.console.log(f"üîç MC-Single: Container found: {container is not None}")
                    if container:
                        # Create feedback div
                        feedback_div = document.createElement("div")
                        feedback_div.id = f"stepFeedback{current_prob_idx}_{step_idx}"
                        feedback_div.className = "step-feedback"
                        container.appendChild(feedback_div)
                        window.console.log(f"‚úÖ Created feedback div for step {step_idx}")

            if feedback_div:
                window.console.log("üìù MC-Single: Building error message...")
                # Build error message with optional hint
                error_html = """
                    <div class='flash-incorrect' style='background:#fef2f2;color:#dc2626;padding:12px;border-radius:8px;margin-top:12px;font-weight:600;'>
                        ‚ùå Incorrect. This step requires the correct answer. Please try again.
                    </div>
                """

                # Add hint if available
                hint = step_data.get("hint", "")
                window.console.log(f"üìù MC-Single: Hint available: {bool(hint)}")
                if hint:
                    hint_blocks = hint if isinstance(hint, list) else [{"type": "text", "content": hint}]
                    hint_html = self.render_content_blocks(hint_blocks)
                    error_html += f"""
                        <div style='background:#eff6ff;color:#1e40af;padding:12px;border-radius:8px;margin-top:8px;'>
                            üí° <strong>Hint:</strong> {hint_html}
                        </div>
                    """
                    window.console.log("‚úÖ Displaying hint for MC-Single")

                window.console.log(f"üìù MC-Single: Setting feedback innerHTML (length: {len(error_html)})")
                # Set innerHTML without flash class initially
                temp_html = error_html.replace("flash-incorrect", "temp-no-flash")
                feedback_div.innerHTML = temp_html

                # Trigger animation by adding flash class after element is rendered
                def trigger_flash():
                    elem = feedback_div.querySelector(".temp-no-flash")
                    if elem:
                        elem.classList.remove("temp-no-flash")
                        elem.classList.add("flash-incorrect")
                window.setTimeout(create_proxy(trigger_flash), 50)

                # Remove flashing class after animation completes
                def remove_flash_mc_single():
                    flash_div = feedback_div.querySelector(".flash-incorrect")
                    if flash_div:
                        flash_div.classList.remove("flash-incorrect")
                window.setTimeout(create_proxy(remove_flash_mc_single), 3000)
                window.console.log("‚úÖ MC-Single: Displayed requireCorrect error message to user")
                window.console.log(f"üìù MC-Single: feedback_div.innerHTML now has {len(feedback_div.innerHTML)} characters")
            else:
                window.console.warn("‚ö†Ô∏è MC-Single: Could not display feedback - no container found")

            self.save_to_storage()
            window.console.log("üö´ RETURNING EARLY - User must submit correct answer to proceed")
            return

        # Show feedback for non-requireCorrect questions
        feedback_div = document.querySelector(f"#stepFeedback{current_prob_idx}_{step_idx}")
        window.console.log(f"üîç MC-Single: Post-blocking feedback lookup, found: {feedback_div is not None}")

        if feedback_div:
            if is_correct:
                feedback_div.innerHTML = """
                    <div style='background:#dcfce7;color:#16a34a;padding:12px;border-radius:8px;margin-top:12px;font-weight:600;'>
                        ‚úÖ Correct!
                    </div>
                """
            else:
                feedback_div.innerHTML = f"""
                    <div class='flash-incorrect' style='background:#fef2f2;color:#dc2626;padding:12px;border-radius:8px;margin-top:12px;'>
                        ‚ùå Incorrect. The correct answer was: {correct_answer}
                    </div>
                """
                
                # Remove flashing class after animation completes
                def remove_flash_mc_single_normal():
                    flash_div = feedback_div.querySelector(".flash-incorrect")
                    if flash_div:
                        flash_div.classList.remove("flash-incorrect")
                window.setTimeout(create_proxy(remove_flash_mc_single_normal), 3000)
        else:
            window.console.warn(f"‚ö†Ô∏è MC-Single: Feedback div not found for non-blocking case")

        # Save and check completion
        self.save_to_storage()
        window.console.log("‚úÖ Proceeding to check completion and show next step")
        self._check_problem_completion_and_show_next_step(step_idx)


    def submit_mc_multiple(self, step_idx, step_data):
        """Submit multiple choice multiple answers"""
        current_prob_idx = self.current_problem_index
        if current_prob_idx is None:
            window.console.error("‚ùå No current problem index")
            return

        window.console.log(f"üîç submit_mc_multiple called with step_idx={step_idx}")

        # Get the step container to scope the checkbox query
        selector = f"#step{current_prob_idx}_{step_idx}"
        window.console.log(f"üîç Looking for container with selector: {selector}")
        step_div = document.querySelector(selector)

        if not step_div:
            window.console.error(f"‚ùå Step container not found for step {step_idx}")
            # Debug: show all step divs
            all_steps = document.querySelectorAll("[id^='step']")
            window.console.log(f"üîç Found {all_steps.length} elements with id starting with 'step'")
            for i in range(all_steps.length):
                window.console.log(f"  - {all_steps[i].id}")
            return

        window.console.log(f"‚úÖ Found step_div: id={step_div.id}, tagName={step_div.tagName}")
        window.console.log(f"üîç step_div innerHTML length: {len(step_div.innerHTML)}")

        # Debug: show all inputs in the step_div
        all_inputs = step_div.querySelectorAll("input")
        window.console.log(f"üîç Total inputs in step_div: {all_inputs.length}")
        for i in range(all_inputs.length):
            inp = all_inputs[i]
            window.console.log(f"  - type={inp.type}, name={inp.name}, value={inp.value}, checked={inp.checked}")

        # Get all selected answers (scoped to this step)
        checkbox_selector = f"input[name='mc_multiple_{step_idx}']"
        window.console.log(f"üîç Looking for checkboxes with selector: {checkbox_selector}")
        all_checkboxes = step_div.querySelectorAll(checkbox_selector)
        checkboxes = step_div.querySelectorAll(f"{checkbox_selector}:checked")

        window.console.log(f"üîç MC-Multiple Debug:")
        window.console.log(f"  Total checkboxes found: {all_checkboxes.length}")
        window.console.log(f"  Checked checkboxes found: {checkboxes.length}")

        user_answers = set()
        for i in range(checkboxes.length):
            user_answers.add(checkboxes[i].value)
            window.console.log(f"  ‚úì Checked: {checkboxes[i].value}")

        if len(user_answers) == 0:
            window.console.warn("No answers selected")

            # Show warning
            feedback_div = document.querySelector(f"#stepFeedback{current_prob_idx}_{step_idx}")
            if feedback_div:
                feedback_div.innerHTML = """
                    <div style='background:#fef2f2;color:#dc2626;padding:12px;border-radius:8px;margin-top:12px;'>
                        ‚ö†Ô∏è Please select at least one answer
                    </div>
                """
            return

        # ‚úÖ Get correct answers - use visible correct answers if shuffled
        correct_answers = set(step_data.get("correct_answers", []))

        # Check if we have stored shuffle data with visible correct answers
        shuffle_key = f"mc_multiple_shuffle_{current_prob_idx}_{step_idx}"
        stored_shuffle = window.localStorage.getItem(shuffle_key)

        if stored_shuffle:
            import json
            stored_data = json.loads(stored_shuffle)
            if isinstance(stored_data, dict) and "visible_correct" in stored_data:
                # Use only the visible correct answers for grading
                visible_correct = set(stored_data["visible_correct"])
                original_correct = correct_answers
                correct_answers = visible_correct
                window.console.log(f"‚úÖ Using visible correct answers for grading:")
                window.console.log(f"   Original: {original_correct}")
                window.console.log(f"   Visible:  {visible_correct}")

        is_correct = (user_answers == correct_answers)
        must_correct = step_data.get("requireCorrect", False)

        # ‚úÖ Calculate proportional score with partial credit
        all_options = step_data.get("options", [])
        all_labels = set([opt.get("label", "") for opt in all_options])
        incorrect_labels = all_labels - correct_answers

        num_correct = len(correct_answers)
        num_incorrect = len(incorrect_labels)

        points_per_correct = 100.0 / num_correct if num_correct > 0 else 0.0
        penalty_per_incorrect = 100.0 / num_incorrect if num_incorrect > 0 else 0.0

        score_percentage = 0.0
        for label in user_answers:
            if label in correct_answers:
                score_percentage += points_per_correct
            elif label in incorrect_labels:
                score_percentage -= penalty_per_incorrect

        score_percentage = max(0.0, min(100.0, score_percentage))

        window.console.log(f"MC Multiple: user={user_answers}, correct={correct_answers}, score={score_percentage:.1f}%, is_correct={is_correct}")

        # ‚è±Ô∏è Get elapsed time for this attempt
        import js
        current_time = js.Date.now()
        time_taken = 0
        if hasattr(self, 'step_timers') and current_prob_idx in self.step_timers:
            step_time = self.step_timers[current_prob_idx].get(step_idx, {})
            start_time = step_time.get("start", None)
            if start_time:
                time_taken = (current_time - start_time) / 1000.0  # Convert to seconds

        # ‚úÖ CRITICAL: Update BOTH solve_state AND problem_states
        if current_prob_idx in self.solve_states and step_idx < len(self.solve_states[current_prob_idx]):
            self.solve_states[current_prob_idx][step_idx]["finished"] = True
            self.solve_states[current_prob_idx][step_idx]["correct"] = is_correct
            self.solve_states[current_prob_idx][step_idx]["score"] = score_percentage
            self.solve_states[current_prob_idx][step_idx]["user_answers"] = list(user_answers)
            window.console.log(f"‚úÖ Updated solve_state: Step {step_idx}, finished=True, score={score_percentage:.1f}%")

        # ‚úÖ CRITICAL: Update problem_states (persisted state)
        if current_prob_idx in self.problem_states and step_idx < len(self.problem_states[current_prob_idx]):
            self.problem_states[current_prob_idx][step_idx]["finished"] = True
            self.problem_states[current_prob_idx][step_idx]["correct"] = is_correct
            self.problem_states[current_prob_idx][step_idx]["score"] = score_percentage
            self.problem_states[current_prob_idx][step_idx]["user_answers"] = list(user_answers)
            attempts = self.problem_states[current_prob_idx][step_idx].get("attempts", 0)
            self.problem_states[current_prob_idx][step_idx]["attempts"] = attempts + 1

            # ‚úÖ Add to attempt_history array
            if "attempt_history" not in self.problem_states[current_prob_idx][step_idx]:
                self.problem_states[current_prob_idx][step_idx]["attempt_history"] = []

            attempt_entry = {
                "timestamp": current_time,
                "time_taken": time_taken,
                "correct": is_correct,
                "score": score_percentage,
                "user_answer": list(user_answers)
            }
            self.problem_states[current_prob_idx][step_idx]["attempt_history"].append(attempt_entry)

            window.console.log(f"‚úÖ Updated problem_states: Problem {current_prob_idx}, Step {step_idx}, finished=True, correct={is_correct}, score={score_percentage:.1f}%, time={time_taken:.1f}s")

        # Mark step as finished
        window.console.log("==================================================")
        window.console.log(f"‚úÖ Step {step_idx} marked as finished")
        window.console.log("Current solve_state status:")
        for i, step in enumerate(self.solve_states[current_prob_idx]):
            status = "‚úÖ DONE" if step.get("finished") else "‚è≥ TODO"
            window.console.log(f"  Step {i}: {status}")
        window.console.log("==================================================")

        # ‚úÖ CRITICAL: Check requireCorrect BEFORE showing feedback
        # This ensures blocking happens even if feedback_div is not found
        if not is_correct and must_correct:
            window.console.log("üö´ BLOCKING PROGRESSION: requireCorrect=True and answer is incorrect")
            # Reset finished status if must be correct
            if current_prob_idx in self.solve_states and step_idx < len(self.solve_states[current_prob_idx]):
                self.solve_states[current_prob_idx][step_idx]["finished"] = False
                window.console.log(f"‚úÖ Reset solve_states[{current_prob_idx}][{step_idx}]['finished'] = False")
            if current_prob_idx in self.problem_states and step_idx < len(self.problem_states[current_prob_idx]):
                self.problem_states[current_prob_idx][step_idx]["finished"] = False
                window.console.log(f"‚úÖ Reset problem_states[{current_prob_idx}][{step_idx}]['finished'] = False")

            # üîÑ RESHUFFLE OPTIONS
            if "options" in step_data and len(step_data["options"]) > 0:
                window.console.log("üîÑ Reshuffling MC options")

                # ‚úÖ Clear stored shuffle to force fresh shuffle
                shuffle_key = f"mc_multiple_shuffle_{current_prob_idx}_{step_idx}"
                window.localStorage.removeItem(shuffle_key)
                window.console.log(f"üîÑ Cleared stored shuffle for fresh attempt (requireCorrect)")

                self.shuffle_array(step_data["options"])

                # Recreate the UI with shuffled options
                if current_prob_idx in self.solve_states and step_idx < len(self.solve_states[current_prob_idx]):
                    container = self.solve_states[current_prob_idx][step_idx].get("container")
                    if container:
                        # Get problem data to get total steps
                        problem = self.problem_set[current_prob_idx]
                        total_steps = len(problem.get("steps", []))
                        desc_html = self.render_content_blocks(step_data.get("description", []))

                        # Recreate mc-multiple UI with shuffled options
                        self.create_mc_multiple_ui(container, current_prob_idx, step_idx, step_data, desc_html, total_steps)
                        window.console.log("‚úÖ Recreated MC-Multiple UI with shuffled options")

            # ‚úÖ ALWAYS show feedback - find or create feedback div
            # Scope to current problem container
            problem_container = document.querySelector(f".accordion-problem[data-index='{current_prob_idx}']")
            feedback_div = problem_container.querySelector(f"#stepFeedback{current_prob_idx}_{step_idx}") if problem_container else None
            if not feedback_div:
                # Try to find step container
                if current_prob_idx in self.solve_states and step_idx < len(self.solve_states[current_prob_idx]):
                    container = self.solve_states[current_prob_idx][step_idx].get("container")
                    if container:
                        # Create feedback div
                        feedback_div = document.createElement("div")
                        feedback_div.id = f"stepFeedback{current_prob_idx}_{step_idx}"
                        feedback_div.className = "step-feedback"
                        container.appendChild(feedback_div)
                        window.console.log(f"‚úÖ Created feedback div for step {step_idx}")

            if feedback_div:
                # Build error message with optional hint
                error_html = """
                    <div class='flash-incorrect' style='background:#fef2f2;color:#dc2626;padding:12px;border-radius:8px;margin-top:12px;font-weight:600;'>
                        ‚ùå Incorrect. This step requires the correct answer. Please try again.
                    </div>
                """

                # Add hint if available
                hint = step_data.get("hint", "")
                if hint:
                    hint_blocks = hint if isinstance(hint, list) else [{"type": "text", "content": hint}]
                    hint_html = self.render_content_blocks(hint_blocks)
                    error_html += f"""
                        <div style='background:#eff6ff;color:#1e40af;padding:12px;border-radius:8px;margin-top:8px;'>
                            üí° <strong>Hint:</strong> {hint_html}
                        </div>
                    """
                    window.console.log("‚úÖ Displaying hint for MC-Multiple")

                # Set innerHTML without flash class initially
                temp_html = error_html.replace("flash-incorrect", "temp-no-flash")
                feedback_div.innerHTML = temp_html

                # Trigger animation by adding flash class after element is rendered
                def trigger_flash():
                    elem = feedback_div.querySelector(".temp-no-flash")
                    if elem:
                        elem.classList.remove("temp-no-flash")
                        elem.classList.add("flash-incorrect")
                window.setTimeout(create_proxy(trigger_flash), 50)

                # Remove flashing class after animation completes
                def remove_flash_mc_req():
                    flash_div = feedback_div.querySelector(".flash-incorrect")
                    if flash_div:
                        flash_div.classList.remove("flash-incorrect")
                window.setTimeout(create_proxy(remove_flash_mc_req), 3000)
                window.console.log("‚úÖ Displayed requireCorrect error message to user")
            else:
                window.console.warn("‚ö†Ô∏è Could not display feedback - no container found")

            self.save_to_storage()
            window.console.log("üö´ RETURNING EARLY - User must submit correct answer to proceed")
            return

        # Show feedback - query within current problem container
        problem_container = document.querySelector(f".accordion-problem[data-index='{current_prob_idx}']")
        feedback_div = problem_container.querySelector(f"#stepFeedback{current_prob_idx}_{step_idx}") if problem_container else None
        if feedback_div:
            if is_correct:
                feedback_div.innerHTML = """
                    <div style='background:#dcfce7;color:#16a34a;padding:12px;border-radius:8px;margin-top:12px;font-weight:600;'>
                        ‚úÖ Correct!
                    </div>
                """
            else:
                correct_list = ", ".join(sorted(correct_answers))
                feedback_div.innerHTML = f"""
                    <div class='flash-incorrect' style='background:#fef2f2;color:#dc2626;padding:12px;border-radius:8px;margin-top:12px;'>
                        ‚ùå Incorrect. The correct answers were: {correct_list}
                    </div>
                """
                
                # Remove flashing class after animation completes
                def remove_flash_mc_normal():
                    flash_div = feedback_div.querySelector(".flash-incorrect")
                    if flash_div:
                        flash_div.classList.remove("flash-incorrect")
                window.setTimeout(create_proxy(remove_flash_mc_normal), 3000)

        # Save and check completion
        self.save_to_storage()
        window.console.log("‚úÖ Proceeding to check completion and show next step")
        self._check_problem_completion_and_show_next_step(step_idx)

    def submit_multi_mc(self, step_idx, step_data):
        """Submit multi-mc (fill-blank with dropdown answers)"""
        window.console.log(f"üîß submit_multi_mc called for step {step_idx}")

        current_prob_idx = self.current_problem_index
        if current_prob_idx is None:
            window.console.error("‚ùå No current problem index")
            return

        # Get all blanks
        blanks = step_data.get("blanks", {})
        window.console.log(f"üìã Blanks: {blanks}")

        # Query for dropdowns specific to this step only
        dropdowns = document.querySelectorAll(f'.multi-mc-dropdown[data-step-idx="{step_idx}"]')
        window.console.log(f"üìã Found {dropdowns.length} dropdowns for step {step_idx}")

        # Collect user answers
        user_answers = {}
        all_answered = True
        for i in range(dropdowns.length):
            dropdown = dropdowns[i]
            label = dropdown.getAttribute("data-blank-label")
            selected_value = dropdown.value

            if not selected_value:
                all_answered = False
                break

            user_answers[label] = selected_value

        # Check if all blanks are filled
        if not all_answered or len(user_answers) < len(blanks):
            window.console.warn("Not all blanks answered")

            # Show warning
            feedback_div = document.querySelector(f"#stepFeedback{current_prob_idx}_{step_idx}")
            if feedback_div:
                feedback_div.innerHTML = """
                    <div style='background:#fef2f2;color:#dc2626;padding:12px;border-radius:8px;margin-top:12px;'>
                        ‚ö†Ô∏è Please fill in all blanks
                    </div>
                """
            return

        # Check correctness for each blank
        all_correct = True
        incorrect_blanks = []
        correct_count = 0
        for label in blanks.keys():
            correct_answer = blanks[label].get("correct", "")
            user_answer = user_answers.get(label, "")

            if user_answer == correct_answer:
                correct_count += 1
            else:
                all_correct = False
                incorrect_blanks.append(label)

        is_correct = all_correct
        must_correct = step_data.get("requireCorrect", False)

        # ‚úÖ Calculate proportional score percentage
        total_blanks = len(blanks)
        score_percentage = (correct_count / total_blanks * 100.0) if total_blanks > 0 else 0.0

        window.console.log(f"Multi-MC: user_answers={user_answers}, correct={correct_count}/{total_blanks}, score={score_percentage:.1f}%, is_correct={is_correct}, must_correct={must_correct}")

        # ‚è±Ô∏è Get elapsed time for this attempt
        import js
        current_time = js.Date.now()
        time_taken = 0
        if hasattr(self, 'step_timers') and current_prob_idx in self.step_timers:
            step_time = self.step_timers[current_prob_idx].get(step_idx, {})
            start_time = step_time.get("start", None)
            if start_time:
                time_taken = (current_time - start_time) / 1000.0  # Convert to seconds

        # ‚úÖ CRITICAL: Update BOTH solve_state AND problem_states
        if current_prob_idx in self.solve_states and step_idx < len(self.solve_states[current_prob_idx]):
            self.solve_states[current_prob_idx][step_idx]["finished"] = True
            self.solve_states[current_prob_idx][step_idx]["correct"] = is_correct
            self.solve_states[current_prob_idx][step_idx]["score"] = score_percentage
            self.solve_states[current_prob_idx][step_idx]["user_answers"] = user_answers
            window.console.log(f"‚úÖ Updated solve_state: Step {step_idx}, finished=True, score={score_percentage:.1f}%")

        # ‚úÖ CRITICAL: Update problem_states (persisted state)
        if current_prob_idx in self.problem_states and step_idx < len(self.problem_states[current_prob_idx]):
            self.problem_states[current_prob_idx][step_idx]["finished"] = True
            self.problem_states[current_prob_idx][step_idx]["correct"] = is_correct
            self.problem_states[current_prob_idx][step_idx]["score"] = score_percentage
            self.problem_states[current_prob_idx][step_idx]["user_answers"] = user_answers
            attempts = self.problem_states[current_prob_idx][step_idx].get("attempts", 0)
            self.problem_states[current_prob_idx][step_idx]["attempts"] = attempts + 1

            # ‚úÖ Add to attempt_history array
            if "attempt_history" not in self.problem_states[current_prob_idx][step_idx]:
                self.problem_states[current_prob_idx][step_idx]["attempt_history"] = []

            attempt_entry = {
                "timestamp": current_time,
                "time_taken": time_taken,
                "correct": is_correct,
                "score": score_percentage,
                "user_answer": user_answers
            }
            self.problem_states[current_prob_idx][step_idx]["attempt_history"].append(attempt_entry)

            window.console.log(f"‚úÖ Updated problem_states: Problem {current_prob_idx}, Step {step_idx}, finished=True, correct={is_correct}, score={score_percentage:.1f}%, time={time_taken:.1f}s")

        # Mark step as finished
        window.console.log("==================================================")
        window.console.log(f"‚úÖ Step {step_idx} marked as finished")
        window.console.log("Current solve_state status:")
        for i, step in enumerate(self.solve_states[current_prob_idx]):
            status = "‚úÖ DONE" if step.get("finished") else "‚è≥ TODO"
            window.console.log(f"  Step {i}: {status}")
        window.console.log("==================================================")

        # ‚úÖ CRITICAL: Check requireCorrect BEFORE showing feedback
        if not is_correct and must_correct:
            window.console.log("üö´ BLOCKING PROGRESSION: requireCorrect=True and answer is incorrect")
            # Reset finished status if must be correct
            if current_prob_idx in self.solve_states and step_idx < len(self.solve_states[current_prob_idx]):
                self.solve_states[current_prob_idx][step_idx]["finished"] = False
                window.console.log(f"‚úÖ Reset solve_states[{current_prob_idx}][{step_idx}]['finished'] = False")
            if current_prob_idx in self.problem_states and step_idx < len(self.problem_states[current_prob_idx]):
                self.problem_states[current_prob_idx][step_idx]["finished"] = False
                window.console.log(f"‚úÖ Reset problem_states[{current_prob_idx}][{step_idx}]['finished'] = False")

            # üîÑ RESHUFFLE OPTIONS for each blank
            if "blanks" in step_data and len(step_data["blanks"]) > 0:
                window.console.log("üîÑ Reshuffling Multi-MC dropdown options")
                for label in step_data["blanks"].keys():
                    blank_data = step_data["blanks"][label]
                    if "options" in blank_data and len(blank_data["options"]) > 0:
                        self.shuffle_array(blank_data["options"])

                # Recreate the UI with shuffled options
                if current_prob_idx in self.solve_states and step_idx < len(self.solve_states[current_prob_idx]):
                    container = self.solve_states[current_prob_idx][step_idx].get("container")
                    if container:
                        # Get problem data to get total steps
                        problem = self.problem_set[current_prob_idx]
                        total_steps = len(problem.get("steps", []))
                        desc_html = self.render_content_blocks(step_data.get("description", []))

                        # Recreate multi-mc UI with shuffled options
                        self.create_multi_mc_ui(container, current_prob_idx, step_idx, step_data, desc_html, total_steps)
                        window.console.log("‚úÖ Recreated Multi-MC UI with shuffled options")

            # ‚úÖ ALWAYS show feedback - find or create feedback div
            # Scope to current problem container
            problem_container = document.querySelector(f".accordion-problem[data-index='{current_prob_idx}']")
            feedback_div = problem_container.querySelector(f"#stepFeedback{current_prob_idx}_{step_idx}") if problem_container else None
            if not feedback_div:
                # Try to find step container
                if current_prob_idx in self.solve_states and step_idx < len(self.solve_states[current_prob_idx]):
                    container = self.solve_states[current_prob_idx][step_idx].get("container")
                    if container:
                        # Create feedback div
                        feedback_div = document.createElement("div")
                        feedback_div.id = f"stepFeedback{current_prob_idx}_{step_idx}"
                        feedback_div.className = "step-feedback"
                        container.appendChild(feedback_div)
                        window.console.log(f"‚úÖ Created feedback div for step {step_idx}")

            if feedback_div:
                # Build error message with optional hint
                error_html = """
                    <div class='flash-incorrect' style='background:#fef2f2;color:#dc2626;padding:12px;border-radius:8px;margin-top:12px;font-weight:600;'>
                        ‚ùå Incorrect. This step requires all correct answers. Please try again.
                    </div>
                """

                # Add hint if available
                hint = step_data.get("hint", "")
                if hint:
                    hint_blocks = hint if isinstance(hint, list) else [{"type": "text", "content": hint}]
                    hint_html = self.render_content_blocks(hint_blocks)
                    error_html += f"""
                        <div style='background:#eff6ff;color:#1e40af;padding:12px;border-radius:8px;margin-top:8px;'>
                            üí° <strong>Hint:</strong> {hint_html}
                        </div>
                    """
                    window.console.log("‚úÖ Displaying hint for Multi-MC")

                # Set innerHTML without flash class initially
                temp_html = error_html.replace("flash-incorrect", "temp-no-flash")
                feedback_div.innerHTML = temp_html

                # Trigger animation by adding flash class after element is rendered
                def trigger_flash():
                    elem = feedback_div.querySelector(".temp-no-flash")
                    if elem:
                        elem.classList.remove("temp-no-flash")
                        elem.classList.add("flash-incorrect")
                window.setTimeout(create_proxy(trigger_flash), 50)

                # Remove flashing class after animation completes
                def remove_flash_multi_mc():
                    flash_div = feedback_div.querySelector(".flash-incorrect")
                    if flash_div:
                        flash_div.classList.remove("flash-incorrect")
                window.setTimeout(create_proxy(remove_flash_multi_mc), 3000)
                window.console.log("‚úÖ Displayed requireCorrect error message to user")
            else:
                window.console.warn("‚ö†Ô∏è Could not display feedback - no container found")

            self.save_to_storage()
            window.console.log("üö´ RETURNING EARLY - User must submit correct answers to proceed")
            return

        # Show feedback
        # Query within current problem container
        problem_container = document.querySelector(f".accordion-problem[data-index='{current_prob_idx}']")
        feedback_div = problem_container.querySelector(f"#stepFeedback{current_prob_idx}_{step_idx}") if problem_container else None
        if feedback_div:
            if is_correct:
                feedback_div.innerHTML = """
                    <div style='background:#dcfce7;color:#16a34a;padding:12px;border-radius:8px;margin-top:12px;font-weight:600;'>
                        ‚úÖ All correct!
                    </div>
                """
            else:
                # Show which blanks were incorrect
                incorrect_msg = f"Blank(s) {', '.join(incorrect_blanks)} incorrect"
                feedback_div.innerHTML = f"""
                    <div class='flash-incorrect' style='background:#fef2f2;color:#dc2626;padding:12px;border-radius:8px;margin-top:12px;'>
                        ‚ùå {incorrect_msg}
                    </div>
                """
                
                # Remove flashing class after animation completes
                def remove_flash_multi_mc_normal():
                    flash_div = feedback_div.querySelector(".flash-incorrect")
                    if flash_div:
                        flash_div.classList.remove("flash-incorrect")
                window.setTimeout(create_proxy(remove_flash_multi_mc_normal), 3000)

        # Save and check completion
        self.save_to_storage()
        window.console.log("‚úÖ Proceeding to check completion and show next step")
        self._check_problem_completion_and_show_next_step(step_idx)

    def submit_true_false(self, step_idx, step_data):
        """Submit true/false answer"""
        current_prob_idx = self.current_problem_index
        if current_prob_idx is None:
            window.console.error("‚ùå No current problem index")
            return

        # Get selected answer
        selected = document.querySelector(f"input[name='tf_{step_idx}']:checked")
        if not selected:
            window.console.warn("No answer selected")

            # Show warning
            feedback_div = document.querySelector(f"#stepFeedback{current_prob_idx}_{step_idx}")
            if feedback_div:
                feedback_div.innerHTML = """
                    <div style='background:#fef2f2;color:#dc2626;padding:12px;border-radius:8px;margin-top:12px;'>
                        ‚ö†Ô∏è Please select True or False
                    </div>
                """
            return

        user_answer = selected.value  # "true" or "false"
        correct_answer = str(step_data.get("correct_answer", "true")).lower()
        is_correct = (user_answer == correct_answer)
        must_correct = step_data.get("requireCorrect", False)
        score_percentage = 100.0 if is_correct else 0.0

        window.console.log(f"True/False: user={user_answer}, correct={correct_answer}, is_correct={is_correct}, score={score_percentage:.1f}%")

        # ‚è±Ô∏è Get elapsed time for this attempt
        import js
        current_time = js.Date.now()
        time_taken = 0
        if hasattr(self, 'step_timers') and current_prob_idx in self.step_timers:
            step_time = self.step_timers[current_prob_idx].get(step_idx, {})
            start_time = step_time.get("start", None)
            if start_time:
                time_taken = (current_time - start_time) / 1000.0  # Convert to seconds

        # ‚úÖ CRITICAL: Update BOTH solve_state AND problem_states
        if current_prob_idx in self.solve_states and step_idx < len(self.solve_states[current_prob_idx]):
            self.solve_states[current_prob_idx][step_idx]["finished"] = True
            self.solve_states[current_prob_idx][step_idx]["correct"] = is_correct
            self.solve_states[current_prob_idx][step_idx]["score"] = score_percentage
            self.solve_states[current_prob_idx][step_idx]["user_answers"] = [user_answer]
            window.console.log(f"‚úÖ Updated solve_state: Step {step_idx}, finished=True, score={score_percentage:.1f}%")

        # ‚úÖ CRITICAL: Update problem_states (persisted state)
        if current_prob_idx in self.problem_states and step_idx < len(self.problem_states[current_prob_idx]):
            self.problem_states[current_prob_idx][step_idx]["finished"] = True
            self.problem_states[current_prob_idx][step_idx]["correct"] = is_correct
            self.problem_states[current_prob_idx][step_idx]["score"] = score_percentage
            self.problem_states[current_prob_idx][step_idx]["user_answers"] = [user_answer]
            attempts = self.problem_states[current_prob_idx][step_idx].get("attempts", 0)
            self.problem_states[current_prob_idx][step_idx]["attempts"] = attempts + 1

            # ‚úÖ Add to attempt_history array
            if "attempt_history" not in self.problem_states[current_prob_idx][step_idx]:
                self.problem_states[current_prob_idx][step_idx]["attempt_history"] = []

            attempt_entry = {
                "timestamp": current_time,
                "time_taken": time_taken,
                "correct": is_correct,
                "score": score_percentage,
                "user_answer": user_answer
            }
            self.problem_states[current_prob_idx][step_idx]["attempt_history"].append(attempt_entry)

            window.console.log(f"‚úÖ Updated problem_states: Problem {current_prob_idx}, Step {step_idx}, finished=True, correct={is_correct}, score={score_percentage:.1f}%, time={time_taken:.1f}s")

        # Mark step as finished
        window.console.log("==================================================")
        window.console.log(f"‚úÖ Step {step_idx} marked as finished")
        window.console.log("Current solve_state status:")
        for i, step in enumerate(self.solve_states[current_prob_idx]):
            status = "‚úÖ DONE" if step.get("finished") else "‚è≥ TODO"
            window.console.log(f"  Step {i}: {status}")
        window.console.log("==================================================")

        # ‚úÖ CRITICAL: Check requireCorrect BEFORE showing feedback
        # This ensures blocking happens even if feedback_div is not found
        if not is_correct and must_correct:
            window.console.log("üö´ BLOCKING PROGRESSION: requireCorrect=True and answer is incorrect")
            # Reset finished status if must be correct
            if current_prob_idx in self.solve_states and step_idx < len(self.solve_states[current_prob_idx]):
                self.solve_states[current_prob_idx][step_idx]["finished"] = False
                window.console.log(f"‚úÖ Reset solve_states[{current_prob_idx}][{step_idx}]['finished'] = False")
            if current_prob_idx in self.problem_states and step_idx < len(self.problem_states[current_prob_idx]):
                self.problem_states[current_prob_idx][step_idx]["finished"] = False
                window.console.log(f"‚úÖ Reset problem_states[{current_prob_idx}][{step_idx}]['finished'] = False")

            # ‚úÖ ALWAYS show feedback - find or create feedback div
            # Scope to current problem container
            problem_container = document.querySelector(f".accordion-problem[data-index='{current_prob_idx}']")
            feedback_div = problem_container.querySelector(f"#stepFeedback{current_prob_idx}_{step_idx}") if problem_container else None
            if not feedback_div:
                # Try to find step container
                if current_prob_idx in self.solve_states and step_idx < len(self.solve_states[current_prob_idx]):
                    container = self.solve_states[current_prob_idx][step_idx].get("container")
                    if container:
                        # Create feedback div
                        feedback_div = document.createElement("div")
                        feedback_div.id = f"stepFeedback{current_prob_idx}_{step_idx}"
                        feedback_div.className = "step-feedback"
                        container.appendChild(feedback_div)
                        window.console.log(f"‚úÖ Created feedback div for step {step_idx}")

            if feedback_div:
                feedback_div.innerHTML = """
                    <div class='flash-incorrect' style='background:#fef2f2;color:#dc2626;padding:12px;border-radius:8px;margin-top:12px;font-weight:600;'>
                        ‚ùå Incorrect. This step requires the correct answer. Please try again.
                    </div>
                """
                
                # Remove flashing class after animation completes
                def remove_flash_tf():
                    flash_div = feedback_div.querySelector(".flash-incorrect")
                    if flash_div:
                        flash_div.classList.remove("flash-incorrect")
                window.setTimeout(create_proxy(remove_flash_tf), 3000)
                window.console.log("‚úÖ Displayed requireCorrect error message to user")
            else:
                window.console.warn("‚ö†Ô∏è Could not display feedback - no container found")

            self.save_to_storage()
            window.console.log("üö´ RETURNING EARLY - User must submit correct answer to proceed")
            return

        # Show feedback
        # Query within current problem container
        problem_container = document.querySelector(f".accordion-problem[data-index='{current_prob_idx}']")
        feedback_div = problem_container.querySelector(f"#stepFeedback{current_prob_idx}_{step_idx}") if problem_container else None
        if feedback_div:
            if is_correct:
                feedback_div.innerHTML = """
                    <div style='background:#dcfce7;color:#16a34a;padding:12px;border-radius:8px;margin-top:12px;font-weight:600;'>
                        ‚úÖ Correct!
                    </div>
                """
            else:
                correct_display = "True" if correct_answer == "true" else "False"
                feedback_div.innerHTML = f"""
                    <div class='flash-incorrect' style='background:#fef2f2;color:#dc2626;padding:12px;border-radius:8px;margin-top:12px;'>
                        ‚ùå Incorrect. The correct answer was: {correct_display}
                    </div>
                """
                
                # Remove flashing class after animation completes
                def remove_flash_tf_normal():
                    flash_div = feedback_div.querySelector(".flash-incorrect")
                    if flash_div:
                        flash_div.classList.remove("flash-incorrect")
                window.setTimeout(create_proxy(remove_flash_tf_normal), 3000)

        # Save and check completion
        self.save_to_storage()
        window.console.log("‚úÖ Proceeding to check completion and show next step")
        self._check_problem_completion_and_show_next_step(step_idx)


    def submit_fill_blank(self, step_idx, step_data):
        """Submit fill-in-the-blank answers (both single and multi-blank)"""
        current_prob_idx = self.current_problem_index
        if current_prob_idx is None:
            window.console.error("‚ùå No current problem index")
            return

        window.console.log(f"üîò submit_fill_blank called for step {step_idx}")

        # Use unified method to detect blank mode (data-based, not DOM-based)
        is_multi_blank = self._detect_blank_mode(step_data)
        window.console.log(f"üêõ DEBUG: is_multi_blank = {is_multi_blank}")
        window.console.log(f"üêõ DEBUG: step_data.blank_config = {step_data.get('blank_config', 'Not found')}")
        window.console.log(f"üêõ DEBUG: step_data.correct_answers type = {type(step_data.get('correct_answers', [])).__name__}")
        
        # Collect user answers based on mode
        if is_multi_blank:
            # Multi-blank mode: collect as dictionary
            # Query within the current problem container to avoid picking up inputs from other problems
            problem_container = document.querySelector(f".accordion-problem[data-index='{current_prob_idx}']")
            if not problem_container:
                window.console.error(f"‚ùå Problem container not found for problem {current_prob_idx}")
                return

            labeled_inputs = problem_container.querySelectorAll(f"#step{current_prob_idx}_{step_idx} [data-blank-label]")
            window.console.log(f"üìù Multi-blank mode: Found {labeled_inputs.length} labeled inputs")
            user_answers = {}
            for i in range(labeled_inputs.length):
                elem = labeled_inputs[i]
                label = elem.getAttribute("data-blank-label")
                value = elem.value.strip()
                if label:
                    user_answers[label] = value
                    window.console.log(f"  Blank {label}: '{value}'")

            # Check if any answers are empty
            if not all(user_answers.values()):
                window.console.warn("‚ö†Ô∏è Some answers are empty")
                feedback_div = document.querySelector(f"#stepFeedback{current_prob_idx}_{step_idx}")
                if feedback_div:
                    feedback_div.innerHTML = """
                        <div style='background:#fef2f2;color:#dc2626;padding:12px;border-radius:8px;margin-top:12px;'>
                            ‚ö†Ô∏è Please fill in all blanks
                        </div>
                    """
                return
        else:
            # Single-blank mode: collect as list
            window.console.log(f"üìù Single-blank mode detected")
            window.console.log(f"üêõ DEBUG: step_idx = {step_idx}")

            # Query within the current problem container to avoid picking up inputs from other problems
            problem_container = document.querySelector(f".accordion-problem[data-index='{current_prob_idx}']")
            if not problem_container:
                window.console.error(f"‚ùå Problem container not found for problem {current_prob_idx}")
                return

            window.console.log(f"üêõ DEBUG: selector = .accordion-problem[data-index=\'{current_prob_idx}\'] #step{current_prob_idx}_{step_idx} .fill-blank-input")
            try:
                all_inputs = problem_container.querySelectorAll(f"#step{current_prob_idx}_{step_idx} .fill-blank-input")
                window.console.log(f"üêõ DEBUG: querySelectorAll succeeded, found {all_inputs.length} inputs")
                for idx in range(all_inputs.length):
                    inp = all_inputs[idx]
                    window.console.log(f"  Input {idx}: value='{inp.value}', data-blank-label={inp.getAttribute('data-blank-label')}")
            except Exception as e:
                window.console.error(f"‚ùå ERROR in querySelectorAll: {e}")
                import traceback
                window.console.error(traceback.format_exc())
                return
            if all_inputs.length == 0:
                window.console.error(f"‚ùå No input element found for step {step_idx}")
                return
            
            input_element = all_inputs[0]
            window.console.log(f"üêõ DEBUG: all_inputs.length = {all_inputs.length}")
            window.console.log(f"üêõ DEBUG: input_element = {input_element}")
            window.console.log(f"üêõ DEBUG: input_element.value = '{input_element.value}'")
            window.console.log(f"üêõ DEBUG: input_element.id = {input_element.id}")
            window.console.log(f"üêõ DEBUG: input_element.className = {input_element.className}")
            user_answer = input_element.value.strip()
            window.console.log(f"üìù User answer: '{user_answer}'")

            # Check if answer is empty
            if not user_answer:
                window.console.warn("‚ö†Ô∏è Answer is empty")
                feedback_div = document.querySelector(f"#stepFeedback{current_prob_idx}_{step_idx}")
                if feedback_div:
                    feedback_div.innerHTML = """
                        <div style='background:#fef2f2;color:#dc2626;padding:12px;border-radius:8px;margin-top:12px;'>
                            ‚ö†Ô∏è Please enter an answer
                        </div>
                    """
                return
            
            user_answers = [user_answer]

        # Get correct answers
        correct_answers = step_data.get("correct_answers", step_data.get("accepted_answers", {}))
        window.console.log(f"üìã Correct answers (before normalization): {correct_answers}")

        # ‚úÖ NORMALIZE: Convert single-blank to multi-blank format (with 1 blank)
        # This allows us to use the same code path for both cases
        if not is_multi_blank:
            window.console.log("üîÑ Normalizing single-blank to multi-blank format")
            # Convert user_answers from list to dict with label "1"
            user_answers = {"1": user_answers[0]}
            # Convert correct_answers from list to dict with label "1"
            correct_answers = {"1": correct_answers}
            window.console.log(f"üìã Normalized user_answers: {user_answers}")
            window.console.log(f"üìã Normalized correct_answers: {correct_answers}")

        # Check answers (unified logic now handles both single and multi-blank)
        if True:
            # Multi-blank: check each answer
            results = {}
            all_correct = True
            for label, user_answer in user_answers.items():
                if label in correct_answers:
                    expected = correct_answers[label]
                    is_correct = False

                    # Handle both list and string formats
                    if isinstance(expected, list):
                        # Check against each accepted answer
                        for answer in expected:
                            if isinstance(answer, dict):
                                answer_value = answer.get("value", "").strip().lower()
                            else:
                                answer_value = str(answer).strip().lower()

                            if user_answer.lower() == answer_value:
                                is_correct = True
                                break
                    else:
                        # Single answer comparison
                        if isinstance(expected, dict):
                            answer_value = expected.get("value", "").strip().lower()
                        else:
                            answer_value = str(expected).strip().lower()

                        is_correct = user_answer.lower() == answer_value

                    results[label] = is_correct
                    if not is_correct:
                        all_correct = False
                    window.console.log(f"  Blank {label}: {'‚úÖ' if is_correct else '‚ùå'}")

            # Calculate score
            score_percentage = (sum(results.values()) / len(results) * 100) if results else 0
            is_correct = all_correct

        window.console.log(f"üìä Score: {score_percentage:.1f}%")

        # Check if this step requires correct answer
        must_correct = step_data.get("requireCorrect", False)

        # ‚è±Ô∏è Get elapsed time for this attempt
        import js
        current_time = js.Date.now()
        time_taken = 0
        if hasattr(self, 'step_timers') and current_prob_idx in self.step_timers:
            step_time = self.step_timers[current_prob_idx].get(step_idx, {})
            start_time = step_time.get("start", None)
            if start_time:
                time_taken = (current_time - start_time) / 1000.0  # Convert to seconds

        # Record first attempt time
        if current_prob_idx in self.problem_states and step_idx < len(self.problem_states[current_prob_idx]):
            if "first_attempt_time" not in self.problem_states[current_prob_idx][step_idx]:
                self.problem_states[current_prob_idx][step_idx]["first_attempt_time"] = time_taken
                window.console.log(f"‚è±Ô∏è First attempt completed in {time_taken:.1f}s for problem {current_prob_idx}, step {step_idx}")

            # Update state
            self.problem_states[current_prob_idx][step_idx]["finished"] = True
            self.problem_states[current_prob_idx][step_idx]["correct"] = is_correct
            self.problem_states[current_prob_idx][step_idx]["score"] = score_percentage
            self.problem_states[current_prob_idx][step_idx]["user_answers"] = user_answers
            attempts = self.problem_states[current_prob_idx][step_idx].get("attempts", 0)
            self.problem_states[current_prob_idx][step_idx]["attempts"] = attempts + 1

            # Add to attempt history
            if "attempt_history" not in self.problem_states[current_prob_idx][step_idx]:
                self.problem_states[current_prob_idx][step_idx]["attempt_history"] = []

            attempt_entry = {
                "timestamp": current_time,
                "time_taken": time_taken,
                "correct": is_correct,
                "score": score_percentage,
                "user_answers": user_answers
            }
            self.problem_states[current_prob_idx][step_idx]["attempt_history"].append(attempt_entry)

        # Mark step as finished
        window.console.log(f"‚úÖ Step {step_idx} marked as finished")

        # Check requireCorrect BEFORE showing feedback
        if not is_correct and must_correct:
            window.console.log("üö´ BLOCKING: requireCorrect=True and answer is incorrect")
            # Reset finished status
            if current_prob_idx in self.solve_states and step_idx < len(self.solve_states[current_prob_idx]):
                self.solve_states[current_prob_idx][step_idx]["finished"] = False
            if current_prob_idx in self.problem_states and step_idx < len(self.problem_states[current_prob_idx]):
                self.problem_states[current_prob_idx][step_idx]["finished"] = False

            # Show feedback
            # Query within the current problem container to avoid picking feedback from other problems
            problem_container = document.querySelector(f".accordion-problem[data-index='{current_prob_idx}']")
            if not problem_container:
                window.console.error(f"‚ùå Problem container not found for problem {current_prob_idx}")
                return

            feedback_div = problem_container.querySelector(f"#stepFeedback{current_prob_idx}_{step_idx}")

            # Create feedback div if it doesn't exist
            if not feedback_div:
                window.console.warn(f"‚ö†Ô∏è Fill-Blank: feedback_div not found for step {step_idx}, attempting to create it")
                container = problem_container.querySelector(f"#step{current_prob_idx}_{step_idx}")
                if container:
                    feedback_div = document.createElement("div")
                    feedback_div.id = f"stepFeedback{current_prob_idx}_{step_idx}"
                    feedback_div.className = "step-feedback"
                    container.appendChild(feedback_div)
                    window.console.log(f"‚úÖ Fill-Blank: Created feedback_div for step {step_idx}")
                else:
                    window.console.error(f"‚ùå Fill-Blank: Container #step{current_prob_idx}_{step_idx} not found!")

            if feedback_div:
                # Build error message
                error_html = f"""
                    <div class='flash-incorrect' style='background:#fef2f2;color:#dc2626;padding:12px;border-radius:8px;margin-top:12px;font-weight:600;'>
                        ‚ùå Incorrect. This step requires {"all correct answers" if is_multi_blank else "a correct answer"}. Please try again.
                    </div>
                """
    
                # Add hint if available
                hint = step_data.get("hint", "")
                if hint:
                    hint_blocks = hint if isinstance(hint, list) else [{"type": "text", "content": hint}]
                    hint_html = self.render_content_blocks(hint_blocks)
                    error_html += f"""
                        <div style='background:#eff6ff;color:#1e40af;padding:12px;border-radius:8px;margin-top:8px;'>
                            üí° Hint: {hint_html}
                        </div>
                    """
    
                # Add hangman UI when requireCorrect=True (works for both single and multi-blank)
                # Add hangman UI for each incorrect blank
                if True:
                    for label, user_answer in user_answers.items():
                        if label in correct_answers:
                            expected = correct_answers[label]
                            
                            # Check if this blank is incorrect
                            is_blank_correct = False
                            if isinstance(expected, list):
                                for answer in expected:
                                    if isinstance(answer, dict):
                                        answer_value = answer.get("value", "").strip().lower()
                                    else:
                                        answer_value = str(answer).strip().lower()
                                    if user_answer.lower() == answer_value:
                                        is_blank_correct = True
                                        break
                            else:
                                if isinstance(expected, dict):
                                    answer_value = expected.get("value", "").strip().lower()
                                else:
                                    answer_value = str(expected).strip().lower()
                                is_blank_correct = user_answer.lower() == answer_value
    
                            # If incorrect, add hangman UI
                            if not is_blank_correct:
                                # Count total options
                                num_options = len(expected) if isinstance(expected, list) else 1
                                
                                # Create accordion for this blank
                                accordion_id = f"blank_accordion_{current_prob_idx}_{step_idx}_{label}"
                                
                                error_html += f"""
                                    <div class='blank-accordion-item' data-blank-id='{accordion_id}' style='margin-top:12px;border:1px solid #e2e8f0;border-radius:6px;overflow:hidden;background:white;'>
                                        <div class='blank-accordion-header' onclick='window.problem_solver_app.toggle_blank_accordion("{accordion_id}")' style='padding:12px;background:#f8fafc;cursor:pointer;display:flex;justify-content:space-between;align-items:center;'>
                                            <div>
                                                <div style='font-weight:600;color:#334155;'>Blank {label}</div>
                                                <div style='font-size:14px;color:#64748b;margin-top:2px;'>{num_options} possible answer{"s" if num_options > 1 else ""}</div>
                                            </div>
                                            <div class='accordion-icon' style='color:#64748b;font-size:18px;'>‚ñº</div>
                                        </div>
                                        <div class='blank-accordion-content' id='accordion_content_{accordion_id}' style='display:none;padding:12px;background:#ffffff;'>
                                """
                                
                                # Handle both list and single answer formats
                                if isinstance(expected, list) and len(expected) > 0:
                                    # Add all hangman buttons
                                    for idx, answer in enumerate(expected):
                                        if isinstance(answer, dict):
                                            correct_answer_text = answer.get("value", "")
                                        else:
                                            correct_answer_text = str(answer)
    
                                        if correct_answer_text:
                                            hangman_id = f"{current_prob_idx}_{step_idx}_{label}_{idx}"
                                            hangman_content = self.create_hangman_ui(correct_answer_text, hangman_id)
                                            error_html += hangman_content
                                else:
                                    # Single answer
                                    if isinstance(expected, dict):
                                        correct_answer_text = expected.get("value", "")
                                    else:
                                        correct_answer_text = str(expected)
    
                                    if correct_answer_text:
                                        hangman_id = f"{current_prob_idx}_{step_idx}_{label}"
                                        hangman_html = self.create_hangman_ui(correct_answer_text, hangman_id)
                                        error_html += hangman_html
                                
                                error_html += """
                                        </div>
                                    </div>
                                """
    
                window.console.log(f"üêõ DEBUG: About to set feedback_div.innerHTML")
                window.console.log(f"üêõ DEBUG: feedback_div = {feedback_div}")
                window.console.log(f"üêõ DEBUG: feedback_div.id = {feedback_div.id if feedback_div else 'None'}")
                window.console.log(f"üêõ DEBUG: error_html length = {len(error_html)}")
                feedback_div.innerHTML = error_html
                window.console.log("‚ùå Fill-Blank: Shown requireCorrect error message with hint")


            # Don't proceed to next step
            return

        # Show success/failure feedback
        # Query within the current problem container to avoid picking feedback from other problems
        problem_container = document.querySelector(f".accordion-problem[data-index='{current_prob_idx}']")
        if problem_container:
            feedback_div = problem_container.querySelector(f"#stepFeedback{current_prob_idx}_{step_idx}")
        else:
            feedback_div = None
        if feedback_div:
            if is_correct:
                feedback_div.innerHTML = """
                    <div class='flash-correct' style='background:#d1fae5;color:#065f46;padding:12px;border-radius:8px;margin-top:12px;font-weight:600;'>
                        ‚úÖ Correct!
                    </div>
                """
            else:
                # Show simple incorrect message (no hangman for requireCorrect=False)
                feedback_div.innerHTML = """
                    <div class='flash-incorrect' style='background:#fef2f2;color:#dc2626;padding:12px;border-radius:8px;margin-top:12px;font-weight:600;'>
                        ‚ùå Incorrect
                    </div>
                """

        # Save progress
        self.save_to_storage()

        # Update progress
        self.update_problem_progress(current_prob_idx)

        # Proceed to next step
        def delayed_next():
            self.next_step(step_idx)
        window.setTimeout(create_proxy(delayed_next), 800)

        """Submit multi-blank fill-in-the-blank answers"""
        current_prob_idx = self.current_problem_index
        if current_prob_idx is None:
            window.console.error("‚ùå No current problem index")
            return

        window.console.log(f"üîò submit_multi_blank called for step {step_idx}")

        # Get all input fields for this step
        input_elements = document.querySelectorAll(f".fill-blank-input")
        if not input_elements or input_elements.length == 0:
            window.console.error(f"‚ùå No input elements found for multi-blank step {step_idx}")
            return

        window.console.log(f"üìù Found {input_elements.length} input elements")

        # Collect user answers
        user_answers = {}
        for i in range(input_elements.length):
            elem = input_elements[i]
            label = elem.getAttribute("data-blank-label")
            value = elem.value.strip()
            if label:
                user_answers[label] = value
                window.console.log(f"  Blank {label}: '{value}'")

        # Check if any answers are empty
        if not all(user_answers.values()):
            window.console.warn("‚ö†Ô∏è Some answers are empty")
            feedback_div = document.querySelector(f"#stepFeedback{current_prob_idx}_{step_idx}")
            if feedback_div:
                feedback_div.innerHTML = """
                    <div style='background:#fef2f2;color:#dc2626;padding:12px;border-radius:8px;margin-top:12px;'>
                        ‚ö†Ô∏è Please fill in all blanks
                    </div>
                """
            return

        # Get correct answers
        correct_answers = step_data.get("correct_answers", {})
        window.console.log(f"üìã Correct answers: {correct_answers}")

        # Check each answer
        results = {}
        all_correct = True
        for label, user_answer in user_answers.items():
            if label in correct_answers:
                expected = correct_answers[label]
                is_correct = False

                # Handle both list and string formats
                if isinstance(expected, list):
                    # Check against each accepted answer
                    for answer in expected:
                        if isinstance(answer, dict):
                            answer_value = answer.get("value", "").strip().lower()
                        else:
                            answer_value = str(answer).strip().lower()

                        if user_answer.lower() == answer_value:
                            is_correct = True
                            break
                else:
                    # Single answer comparison
                    if isinstance(expected, dict):
                        answer_value = expected.get("value", "").strip().lower()
                    else:
                        answer_value = str(expected).strip().lower()

                    is_correct = user_answer.lower() == answer_value

                results[label] = is_correct
                if not is_correct:
                    all_correct = False
                window.console.log(f"  Blank {label}: {'‚úÖ' if is_correct else '‚ùå'}")

        # Calculate score
        score_percentage = (sum(results.values()) / len(results) * 100) if results else 0
        window.console.log(f"üìä Score: {score_percentage:.1f}%")

        # Check if this step requires correct answer
        must_correct = step_data.get("requireCorrect", False)

        # ‚è±Ô∏è Get elapsed time for this attempt
        import js
        current_time = js.Date.now()
        time_taken = 0
        if hasattr(self, 'step_timers') and current_prob_idx in self.step_timers:
            step_time = self.step_timers[current_prob_idx].get(step_idx, {})
            start_time = step_time.get("start", None)
            if start_time:
                time_taken = (current_time - start_time) / 1000.0  # Convert to seconds

        # Record first attempt time
        if current_prob_idx in self.problem_states and step_idx < len(self.problem_states[current_prob_idx]):
            if "first_attempt_time" not in self.problem_states[current_prob_idx][step_idx]:
                self.problem_states[current_prob_idx][step_idx]["first_attempt_time"] = time_taken
                window.console.log(f"‚è±Ô∏è First attempt completed in {time_taken:.1f}s for problem {current_prob_idx}, step {step_idx}")

            # Update state
            self.problem_states[current_prob_idx][step_idx]["finished"] = True
            self.problem_states[current_prob_idx][step_idx]["correct"] = all_correct
            self.problem_states[current_prob_idx][step_idx]["score"] = score_percentage
            self.problem_states[current_prob_idx][step_idx]["user_answers"] = user_answers
            attempts = self.problem_states[current_prob_idx][step_idx].get("attempts", 0)
            self.problem_states[current_prob_idx][step_idx]["attempts"] = attempts + 1

            # Add to attempt history
            if "attempt_history" not in self.problem_states[current_prob_idx][step_idx]:
                self.problem_states[current_prob_idx][step_idx]["attempt_history"] = []

            attempt_entry = {
                "timestamp": current_time,
                "time_taken": time_taken,
                "correct": all_correct,
                "score": score_percentage,
                "user_answers": user_answers
            }
            self.problem_states[current_prob_idx][step_idx]["attempt_history"].append(attempt_entry)

        # Mark step as finished
        window.console.log(f"‚úÖ Step {step_idx} marked as finished")

        # Check requireCorrect BEFORE showing feedback
        if not all_correct and must_correct:
            window.console.log("üö´ BLOCKING: requireCorrect=True and answer is incorrect")
            # Reset finished status
            if current_prob_idx in self.solve_states and step_idx < len(self.solve_states[current_prob_idx]):
                self.solve_states[current_prob_idx][step_idx]["finished"] = False
            if current_prob_idx in self.problem_states and step_idx < len(self.problem_states[current_prob_idx]):
                self.problem_states[current_prob_idx][step_idx]["finished"] = False

            # Show feedback
            feedback_div = document.querySelector(f"#stepFeedback{current_prob_idx}_{step_idx}")

            # Create feedback div if it doesn't exist (defensive)
            if not feedback_div:
                window.console.warn(f"‚ö†Ô∏è Multi-Blank: feedback_div not found for step {step_idx}, attempting to create it")
                container = document.querySelector(f"#step{current_prob_idx}_{step_idx}")
                if container:
                    feedback_div = document.createElement("div")
                    feedback_div.id = f"stepFeedback{current_prob_idx}_{step_idx}"
                    feedback_div.className = "step-feedback"
                    container.appendChild(feedback_div)
                    window.console.log(f"‚úÖ Multi-Blank: Created feedback_div for step {step_idx}")
                else:
                    window.console.error(f"‚ùå Multi-Blank: Container #step{current_prob_idx}_{step_idx} not found!")

            if feedback_div:
                # Build error message
                error_html = """
                    <div class='flash-incorrect' style='background:#fef2f2;color:#dc2626;padding:12px;border-radius:8px;margin-top:12px;font-weight:600;'>
                        ‚ùå Incorrect. This step requires all correct answers. Please try again.
                    </div>
                """

                # Add hint if available (in parentheses)
                hint = step_data.get("hint", "")
                if hint:
                    hint_blocks = hint if isinstance(hint, list) else [{"type": "text", "content": hint}]
                    hint_html = self.render_content_blocks(hint_blocks)
                    error_html += f"""
                        <div style='background:#eff6ff;color:#1e40af;padding:12px;border-radius:8px;margin-top:8px;'>
                            üí° <strong>Hint:</strong> ({hint_html})
                        </div>
                    """
                    window.console.log("‚úÖ Displaying hint for Multi-Blank")

                # Add hangman UI for each incorrect blank
                for label, is_correct in results.items():
                    if not is_correct and label in correct_answers:
                        # Get the correct answer(s) for this blank
                        expected = correct_answers[label]
                        
                        # Count total options
                        num_options = len(expected) if isinstance(expected, list) else 1
                        
                        # Create accordion for this blank
                        accordion_id = f"blank_accordion_{current_prob_idx}_{step_idx}_{label}"
                        
                        error_html += f"""
                            <div class='blank-accordion-item' data-blank-id='{accordion_id}' style='margin-top:12px;border:1px solid #e2e8f0;border-radius:6px;overflow:hidden;background:white;'>
                                <div class='blank-accordion-header' onclick='window.problem_solver_app.toggle_blank_accordion("{accordion_id}")' style='padding:12px;background:#f8fafc;cursor:pointer;display:flex;justify-content:space-between;align-items:center;'>
                                    <div>
                                        <div style='font-weight:600;color:#334155;'>Blank {label}</div>
                                        <div style='font-size:14px;color:#64748b;margin-top:2px;'>{num_options} possible answer{"s" if num_options > 1 else ""}</div>
                                    </div>
                                    <div class='accordion-icon' style='color:#64748b;font-size:18px;'>‚ñº</div>
                                </div>
                                <div class='blank-accordion-content' id='accordion_content_{accordion_id}' style='display:none;padding:12px;background:#ffffff;'>
                        """
                        
                        # Handle both list and single answer formats
                        if isinstance(expected, list) and len(expected) > 0:
                            # Add all hangman buttons directly (no nested accordions)
                            for idx, answer in enumerate(expected):
                                if isinstance(answer, dict):
                                    correct_answer_text = answer.get("value", "")
                                else:
                                    correct_answer_text = str(answer)

                                if correct_answer_text:
                                    hangman_id = f"{current_prob_idx}_{step_idx}_{label}_{idx}"
                                    hangman_content = self.create_hangman_ui(correct_answer_text, hangman_id)
                                    error_html += hangman_content
                        else:
                            # Single answer
                            if isinstance(expected, dict):
                                correct_answer_text = expected.get("value", "")
                            else:
                                correct_answer_text = str(expected)

                            if correct_answer_text:
                                hangman_id = f"{current_prob_idx}_{step_idx}_{label}"
                                hangman_html = self.create_hangman_ui(correct_answer_text, hangman_id)
                                error_html += hangman_html
                        
                        error_html += """
                                </div>
                            </div>
                        """
                        window.console.log(f"‚úÖ Created accordion for Blank {label} with {num_options} option(s)")

                # Set innerHTML without flash class initially
                temp_html = error_html.replace("flash-incorrect", "temp-no-flash")
                feedback_div.innerHTML = temp_html

                # Trigger animation by adding flash class after element is rendered
                def trigger_flash():
                    elem = feedback_div.querySelector(".temp-no-flash")
                    if elem:
                        elem.classList.remove("temp-no-flash")
                        elem.classList.add("flash-incorrect")
                window.setTimeout(create_proxy(trigger_flash), 50)

                # Remove flashing class after animation completes
                def remove_flash_multi():
                    flash_div = feedback_div.querySelector(".flash-incorrect")
                    if flash_div:
                        flash_div.classList.remove("flash-incorrect")
                window.setTimeout(create_proxy(remove_flash_multi), 3000)

            self.save_to_storage()
            return

        # No feedback display for multi-blank (removed as per user request)

        # Disable all inputs
        for i in range(input_elements.length):
            input_elements[i].disabled = True

        # Save and check completion
        self.save_to_storage()
        window.console.log("‚úÖ Proceeding to check completion and show next step")
        self._check_problem_completion_and_show_next_step(step_idx)

    # ============================================
    # HELPER METHOD - Check completion after each step
    # ============================================

    def _check_problem_completion_and_show_next_step(self, step_idx):
      """Check if problem is complete and show next step or completion banner"""
      current_prob_idx = self.current_problem_index
      if current_prob_idx is None:
          return

      window.console.log("üîç Checking completion status...")

      # ‚úÖ Use your existing method
      problem_completed = self.check_problem_completion(current_prob_idx)

      if problem_completed:
          # This problem is complete!
          window.console.log(f"‚úÖ Problem {current_prob_idx} is now complete!")

          # Save to ensure completion is recorded
          self.save_to_storage()

          # Update progress display in accordion header
          self.update_problem_progress(current_prob_idx)

          # Show completion banner (NO RELOAD!)
          self.show_problem_completion_banner(current_prob_idx)

          # ‚úÖ Use your existing method to check all problems
          all_completed = self.check_all_problems_completion()

          if all_completed:
              window.console.log("üéâ ALL PROBLEMS COMPLETE! Showing review...")

              # Small delay to let user see the completion message
              def show_review_delayed():
                  self.show_review_section()

              window.setTimeout(create_proxy(show_review_delayed), 1500)
          else:
              window.console.log("Some problems remain incomplete")
      else:
          # Problem not complete, show next step
          window.console.log(f"Problem {current_prob_idx} not complete yet")

          # Save progress
          self.save_to_storage()

          # Update progress display in accordion header
          self.update_problem_progress(current_prob_idx)

          # Find and show next unfinished step
          next_step_idx = None
          if current_prob_idx in self.problem_states:
              for i, step_data in enumerate(self.problem_states[current_prob_idx]):
                  if not step_data.get("finished", False):
                      next_step_idx = i
                      break

          if next_step_idx is not None:
              window.console.log(f"üìç Next unfinished step: {next_step_idx}")

              # ‚úÖ Stop timer for current step
              elapsed = self.end_step_timer(current_prob_idx, step_idx, is_first_attempt=True)
              window.console.log(f"‚è±Ô∏è Stopped timer for step {step_idx} (elapsed: {elapsed:.1f}s)")

              # ‚úÖ Start timer for next step
              self.start_step_timer(current_prob_idx, next_step_idx, is_first_attempt=True)
              window.console.log(f"‚è±Ô∏è Started timer for step {next_step_idx}")

              # ‚úÖ Use next_step function with animations
              self.next_step(step_idx)

    def show_problem_completion_banner(self, prob_idx):
        """Show a banner when a problem is completed and hide the problem-solving area"""
        # Find the problem body
        problem_body = document.querySelector(f"#problemBody{prob_idx}")
        if not problem_body:
            return

        # Remove any existing banner
        existing_banner = document.querySelector(f"#completionBanner_{prob_idx}")
        if existing_banner:
            existing_banner.remove()

        # ‚úÖ Hide all step containers (problem-solving area)
        if prob_idx in self.solve_states:
            for step in self.solve_states[prob_idx]:
                container = step.get("container")
                if container:
                    container.classList.add("problem-area-hidden")
                    # After animation completes, set display to none
                    def hide_container(c):
                        def do_hide():
                            c.style.display = "none"
                        return do_hide
                    window.setTimeout(create_proxy(hide_container(container)), 500)

        # ‚úÖ Hide problem description
        problem_desc = problem_body.querySelector(".problem-description")
        if problem_desc:
            problem_desc.classList.add("problem-area-hidden")
            # After animation completes, set display to none
            def hide_desc():
                problem_desc.style.display = "none"
            window.setTimeout(create_proxy(hide_desc), 500)
            window.console.log(f"‚úÖ Problem description hidden for problem {prob_idx}")

        # ‚úÖ Hide global attempt history
        global_history = document.querySelector(f"#globalHistory_{prob_idx}")
        if global_history:
            global_history.classList.add("problem-area-hidden")
            # After animation completes, set display to none
            def hide_history():
                global_history.style.display = "none"
            window.setTimeout(create_proxy(hide_history), 500)
            window.console.log(f"‚úÖ Global attempt history hidden for problem {prob_idx}")

        # Create completion banner
        banner = document.createElement("div")
        banner.id = f"completionBanner_{prob_idx}"
        banner.style.cssText = """
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            padding: 32px;
            border-radius: 12px;
            margin: 20px 0;
            text-align: center;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
            animation: slideIn 0.5s ease-out;
        """

        # ‚úÖ No score displayed, just success message
        banner.innerHTML = f"""
            <div style="font-size: 48px; margin-bottom: 16px;">üéâ</div>
            <div style="font-size: 28px; font-weight: 700; margin-bottom: 12px;">
                Congratulations!
            </div>
            <div style="font-size: 18px; opacity: 0.95;">
                You've completed all steps for Problem {prob_idx + 1}
            </div>
        """

        # Insert at top of problem body
        if problem_body.firstChild:
            problem_body.insertBefore(banner, problem_body.firstChild)
        else:
            problem_body.appendChild(banner)

        window.console.log(f"‚úÖ Completion banner shown and problem area hidden for problem {prob_idx}")

    def _animate_step_numbers(self):
      """Animate step numbers counting up when finalize button is clicked"""
      try:
          current_prob_idx = self.current_problem_index
          if current_prob_idx is None or current_prob_idx not in self.solve_states:
              return

          # Count finished steps
          finished_count = 0
          for step in self.solve_states[current_prob_idx]:
              if step.get("finished", False):
                  finished_count += 1

          total_steps = len(self.solve_states[current_prob_idx])

          # Find the progress summary element in the problem header
          problem_header = document.querySelector(f"#problemHeader{current_prob_idx}")
          if not problem_header:
              return

          progress_summary = problem_header.querySelector(".progress-summary")
          if not progress_summary:
              return

          # Animate counting from current to new count
          start_count = finished_count - 1 if finished_count > 0 else 0
          current_count = start_count

          def count_animation(count):
              def do_count():
                  nonlocal current_count
                  if current_count < finished_count:
                      current_count += 1
                      # Update display with animation class
                      progress_color = "#10b981" if current_count == total_steps else "#f59e0b"
                      progress_summary.innerHTML = f'<span class="step-number-animate">‚úÖ {current_count}/{total_steps} completed</span>'
                      progress_summary.style.color = progress_color

                      # Continue animation
                      if current_count < finished_count:
                          window.setTimeout(create_proxy(count_animation(current_count)), 200)
              return do_count

          # Start animation
          window.setTimeout(create_proxy(count_animation(current_count)), 100)

      except Exception as e:
          window.console.error(f"‚ùå Error animating step numbers: {e}")
          import traceback
          window.console.error(traceback.format_exc())

    def _finalize_step_ui(self, step_idx):
      """Helper method to update UI when step is finalized"""
      if step_idx >= len(self.solve_state):
          return

      step = self.solve_state[step_idx]
      container = step["container"]

      # Disable buttons
      finalize_btn = container.querySelector(".finalize-step")
      if finalize_btn:
          finalize_btn.disabled = True
          finalize_btn.style.opacity = "0.5"

      submit_btn = container.querySelector(".submit-step")
      if submit_btn:
          submit_btn.disabled = True
          submit_btn.style.opacity = "0.5"

      # Show next button
      next_btn = container.querySelector(".next-step")
      if next_btn:
          next_btn.style.display = "block"

      # ‚úÖ Mark step as finished (triggers progress update and completion check)
      self._mark_step_finished(step_idx)


    def check_problem_completion(self, problem_idx):
        """Check if all steps in a problem are completed correctly"""
        if problem_idx >= len(self.problem_set):
            return False

        problem = self.problem_set[problem_idx]
        steps = problem.get('steps', [])
        total_steps = len(steps)

        if total_steps == 0:
            return False

        # Always check problem_states (persisted state)
        if problem_idx in self.problem_states:
            saved_state = self.problem_states[problem_idx]
            completed_count = sum(1 for step in saved_state if step.get("finished", False))
            window.console.log(f"Problem {problem_idx}: {completed_count}/{total_steps} steps finished")
            return completed_count == total_steps

        return False

    def check_all_problems_completion(self):
        """Check if all problems are completed"""
        if not self.problem_set or len(self.problem_set) == 0:
            return False

        for i in range(len(self.problem_set)):
            if not self.check_problem_completion(i):
                window.console.log(f"Problem {i} not yet completed")
                return False

        window.console.log("üéâ All problems completed!")
        return True

    def show_problem_completion_message(self):
        """Show congratulations message for completing a problem"""
        if self.current_problem_index is None:
            return

        # Create or update congratulations section
        congrats_id = f"problemCongrats_{self.current_problem_index}"
        congrats_el = document.querySelector(f"#{congrats_id}")

        if congrats_el:
            # Already shown, don't duplicate
            return

        # Create new congratulations element
        congrats_el = document.createElement("div")
        congrats_el.id = congrats_id

        # Insert after the problem's global history
        global_history = document.querySelector(f"#globalHistory_{self.current_problem_index}")
        if global_history and global_history.parentNode:
            # Insert after global history
            if global_history.nextSibling:
                global_history.parentNode.insertBefore(congrats_el, global_history.nextSibling)
            else:
                global_history.parentNode.appendChild(congrats_el)

        problem_name = self.problem_set[self.current_problem_index].get('title', f'Problem {self.current_problem_index + 1}')

        congrats_el.innerHTML = f"""
        <div style='background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    padding: 24px;
                    border-radius: 12px;
                    margin: 16px 0;
                    text-align: center;
                    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);'>
            <div style='font-size: 48px; margin-bottom: 12px;'>üéâ</div>
            <div style='font-size: 24px; font-weight: 700; margin-bottom: 8px;'>
                Congratulations!
            </div>
            <div style='font-size: 16px; opacity: 0.95;'>
                You've completed all steps for {html.escape(problem_name)}!
            </div>
        </div>
        """

        # Scroll to show the message
        congrats_el.scrollIntoView({'behavior': 'smooth', 'block': 'center'})

        window.console.log(f"‚úÖ Displayed problem completion message for problem {self.current_problem_index}")

    def show_all_problems_completion_message(self):
      """Show congratulations message for completing all problems with total score"""
      window.console.log("üéâ show_all_problems_completion_message called!")

      # Remove existing message first (in case of reload)
      existing = document.querySelector("#allProblemsComplete")
      if existing:
          existing.remove()
          window.console.log("üóëÔ∏è Removed existing all-problems banner")

      # ‚úÖ FIXED: Unpack 3 values, calculate percentage from first 2
      total_score, max_score, problem_scores = self.calculate_total_score()
      percentage = (total_score / max_score * 100.0) if max_score > 0 else 0.0
      window.console.log(f"üìä Score calculated: {percentage:.1f}%")

      # Determine grade/message based on score
      if percentage >= 90:
          grade_emoji = "üèÜ"
          grade_text = "Outstanding!"
          grade_color = "#f59e0b"
      elif percentage >= 80:
          grade_emoji = "üåü"
          grade_text = "Excellent!"
          grade_color = "#10b981"
      elif percentage >= 70:
          grade_emoji = "üëç"
          grade_text = "Good Job!"
          grade_color = "#3b82f6"
      elif percentage >= 60:
          grade_emoji = "‚úì"
          grade_text = "Well Done!"
          grade_color = "#8b5cf6"
      else:
          grade_emoji = "üìö"
          grade_text = "Keep Practicing!"
          grade_color = "#6b7280"

      # Create congratulations element
      all_congrats_el = document.createElement("div")
      all_congrats_el.id = "allProblemsComplete"

      # Find the main content area to append to
      main_content = document.querySelector("#solveProblemsContainer")
      if main_content:
          # Insert at the very top
          if main_content.firstChild:
              main_content.insertBefore(all_congrats_el, main_content.firstChild)
          else:
              main_content.appendChild(all_congrats_el)
      else:
          # Fallback to body
          document.body.appendChild(all_congrats_el)

      total_problems = len(self.problem_set)

      all_congrats_el.innerHTML = f"""
      <div style='background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
                  color: white;
                  padding: 40px;
                  border-radius: 16px;
                  margin: 0 0 24px 0;
                  text-align: center;
                  max-width: 100%;
                  box-shadow: 0 8px 24px rgba(240, 147, 251, 0.4);'>
          <div style='font-size: 64px; margin-bottom: 16px;'>{grade_emoji}</div>
          <div style='font-size: 32px; font-weight: 700; margin-bottom: 12px;'>
              {grade_text}
          </div>
          <div style='font-size: 20px; margin-bottom: 16px;'>
              You've completed all {total_problems} problem{'' if total_problems == 1 else 's'}!
          </div>

          <div style='background: rgba(255,255,255,0.15); 
                      padding: 24px; 
                      border-radius: 12px; 
                      margin: 20px 0;
                      backdrop-filter: blur(10px);'>
              <div style='font-size: 16px; opacity: 0.9; margin-bottom: 12px; font-weight: 600;'>
                  üìä Your Total Score
              </div>
              <div style='font-size: 48px; font-weight: 700; margin-bottom: 8px;'>
                  {percentage:.1f}%
              </div>
              <div style='font-size: 14px; opacity: 0.85;'>
                  {total_score:.0f} / {max_score:.0f} points
              </div>
          </div>

          <div style='font-size: 16px; opacity: 0.95; margin-top: 16px;'>
              Great job on mastering these concepts! üåü
          </div>
      </div>
      """

      # Scroll to the message
      all_congrats_el.scrollIntoView({'behavior': 'smooth', 'block': 'start'})

      window.console.log(f"üéä Displayed completion message with score: {percentage:.1f}%!")
    
    def calculate_step_score(self, step_idx, step_data, step_state):
      """
      Calculate score for a step based on its type and user's answer.
      Returns a score between 0 and 100.
      ‚úÖ FIXED: Re-checks answer correctness instead of using cached value
      ‚úÖ FIXED: Uses cached value for requireCorrect steps (read-only)
      """
      step_type = step_state.get("step_type", "math-expression")

      window.console.log(f"üî¢ Calculating score for step {step_idx}, type: {step_type}")
      window.console.log(f"   Finished: {step_state.get('finished', False)}, Correct: {step_state.get('correct', False)}")
      window.console.log(f"   User answers: {step_state.get('user_answers', [])}")

      # If not finished, score is 0
      if not step_state.get("finished", False):
          window.console.log(f"   Score: 0 (not finished)")
          return 0.0

      # ‚úÖ Check requireCorrect - if true, use cached value (not editable)
      is_require_correct = step_data.get("requireCorrect", False)
      if is_require_correct:
          score = 100.0 if step_state.get("correct", False) else 0.0
          window.console.log(f"   Score: {score} (requireCorrect, cached)")
          return score

      # Math expression and other simple types (use cached value - not editable)
      if step_type == "math-expression" or step_type == "step-by-step":
          score = 100.0 if step_state.get("correct", False) else 0.0
          window.console.log(f"   Score: {score} (math-expression, cached)")
          return score

      # Multiple choice - single answer
      elif step_type == "multiple-choice-single":
          is_correct = self._check_mc_single_correctness(step_data, step_state)
          score = 100.0 if is_correct else 0.0
          window.console.log(f"   Score: {score} (mc-single, re-checked: {is_correct})")
          return score

      # Multiple choice - multiple answers (with negative scoring)
      elif step_type == "multiple-choice-multiple":
          score = self._calculate_mc_multiple_score(step_data, step_state)
          window.console.log(f"   Score: {score} (mc-multiple)")
          return score

      # True/False
      elif step_type == "true-false":
          is_correct = self._check_true_false_correctness(step_data, step_state)
          score = 100.0 if is_correct else 0.0
          window.console.log(f"   Score: {score} (true-false, re-checked: {is_correct})")
          return score

      # Fill in the blank (proportional scoring)
      elif step_type == "fill-blank":
          score = self._calculate_fill_blank_score(step_data, step_state)
          window.console.log(f"   Score: {score} (fill-blank)")
          return score

      # Multi-MC (proportional scoring like fill-blank)
      elif step_type == "multi-mc":
          score = self._calculate_multi_mc_score(step_data, step_state)
          window.console.log(f"   Score: {score} (multi-mc)")
          return score

      # Default
      window.console.log(f"   Score: 0 (unknown type)")
      return 0.0


    def calculate_total_score(self):
      """
      Calculate total score across all problems.
      Returns (total_score, max_score, problem_scores)
      """
      window.console.log("=" * 60)
      window.console.log("üìä CALCULATING TOTAL SCORE")
      window.console.log("=" * 60)

      total_score = 0.0
      max_score = 0.0
      problem_scores = {}  # ‚úÖ Initialize here

      for prob_idx, problem in enumerate(self.problem_set):
          steps = problem.get("steps", [])
          window.console.log(f"\nProblem {prob_idx}: {len(steps)} steps")

          prob_score = 0.0
          prob_max = 0.0

          # Get saved state for this problem
          if prob_idx in self.problem_states:
              saved_state = self.problem_states[prob_idx]
              window.console.log(f"  Found saved state with {len(saved_state)} steps")

              for step_idx, step_data in enumerate(steps):
                  prob_max += 100.0  # Each step worth 100 points

                  if step_idx < len(saved_state):
                      step_state = saved_state[step_idx]
                      step_score = self.calculate_step_score(step_idx, step_data, step_state)
                      prob_score += step_score

                      window.console.log(f"  Problem {prob_idx}, Step {step_idx}: {step_score:.2f}/100")
                  else:
                      window.console.log(f"  Problem {prob_idx}, Step {step_idx}: No saved state")
          else:
              # No saved state, just add to max score
              prob_max = len(steps) * 100.0
              window.console.log(f"  No saved state for problem {prob_idx}")

          # ‚úÖ Store problem score info
          problem_scores[prob_idx] = {
              'score': prob_score,
              'max_score': prob_max,
              'percentage': (prob_score / prob_max * 100.0) if prob_max > 0 else 0.0
          }

          # Add to totals
          total_score += prob_score
          max_score += prob_max

      percentage = (total_score / max_score * 100.0) if max_score > 0 else 0.0

      window.console.log("=" * 60)
      window.console.log(f"üìä TOTAL: {total_score:.2f}/{max_score:.2f} = {percentage:.2f}%")
      window.console.log("=" * 60)

      # ‚úÖ FIXED: Return problem_scores dict instead of percentage
      return (total_score, max_score, problem_scores)


    def _calculate_mc_multiple_score(self, step_data, step_state):
      """
      Calculate score for multiple-choice-multiple with penalty scoring.

      Logic:
      1. Selecting a correct option: +points (100% / num_correct_options)
      2. NOT selecting an incorrect option: 0 points (neutral)
      3. Selecting an incorrect option: -points (100% / num_incorrect_options)
      4. NOT selecting a correct option: 0 points (neutral, miss the +points)

      This ensures:
      - Selecting all options ‚Üí score = 0
      - Selecting nothing ‚Üí score = 0
      - Selecting only correct options ‚Üí score = 100
      """
      correct_answers = step_data.get("correct_answers", [])
      user_answers = step_state.get("user_answers", [])

      if not correct_answers:
          return 0.0

      # Get all options
      all_options = step_data.get("options", [])
      total_options = len(all_options)

      if total_options == 0:
          return 0.0

      # Determine correct and incorrect option labels
      correct_labels = set(correct_answers)
      all_labels = set([opt.get("label", "") for opt in all_options])
      incorrect_labels = all_labels - correct_labels

      num_correct = len(correct_labels)
      num_incorrect = len(incorrect_labels)

      # Points distribution
      points_per_correct = 100.0 / num_correct if num_correct > 0 else 0.0
      penalty_per_incorrect = 100.0 / num_incorrect if num_incorrect > 0 else 0.0

      # Calculate score based on selections only
      score = 0.0
      user_set = set(user_answers)

      # Add points for each correct option selected
      for label in user_set:
          if label in correct_labels:
              score += points_per_correct
          elif label in incorrect_labels:
              score -= penalty_per_incorrect

      # Clamp score between 0 and 100
      score = max(0.0, min(100.0, score))

      window.console.log(f"MC-Multiple Score: {score:.2f}%")
      window.console.log(f"  Correct selected: {len(user_set & correct_labels)}/{num_correct} (+{points_per_correct:.2f} each)")
      window.console.log(f"  Incorrect selected: {len(user_set & incorrect_labels)}/{num_incorrect} (-{penalty_per_incorrect:.2f} each)")

      return score


    def _calculate_fill_blank_score(self, step_data, step_state):
      """
      Calculate score for fill-in-the-blank questions.
      Supports both single-blank and multi-blank modes.
      
      Single-blank: user_answers is a list, correct_answers is a list
      Multi-blank: user_answers is a dict, correct_answers is a dict
      """
      correct_answers = step_data.get("correct_answers", step_data.get("accepted_answers", []))
      user_answers = step_state.get("user_answers", [])

      if not correct_answers or not user_answers:
          return 0.0

      # Check if multi-blank mode (user_answers is dict)
      if isinstance(user_answers, dict):
          # Multi-blank mode: proportional scoring
          if not isinstance(correct_answers, dict):
              window.console.error("Multi-blank mode detected but correct_answers is not a dict")
              return 0.0
          
          total_blanks = len(correct_answers)
          correct_count = 0
          
          for label, correct_value in correct_answers.items():
              user_value = user_answers.get(label, "")
              
              # Handle both string and list of acceptable answers
              if isinstance(correct_value, list):
                  # Multiple acceptable answers for this blank (list of dicts or strings)
                  user_normalized = str(user_value).strip().lower()
                  matches = False
                  for cv in correct_value:
                      if isinstance(cv, dict):
                          # Extract "value" field from dict
                          cv_value = cv.get("value", "").strip().lower()
                      else:
                          # Plain string
                          cv_value = str(cv).strip().lower()

                      if user_normalized == cv_value:
                          matches = True
                          break
              else:
                  # Single correct answer for this blank (dict or string)
                  if isinstance(correct_value, dict):
                      correct_str = correct_value.get("value", "").strip().lower()
                  else:
                      correct_str = str(correct_value).strip().lower()
                  matches = str(user_value).strip().lower() == correct_str
              
              if matches:
                  correct_count += 1
                  correct_count += 1
          
          score = (correct_count / total_blanks) * 100.0 if total_blanks > 0 else 0.0
          window.console.log(f"Fill-Blank (Multi) Score: {score:.1f}% ({correct_count}/{total_blanks} correct)")
          return score
      
      else:
          # Single-blank mode: all-or-nothing scoring
          user_answer = user_answers[0].strip().lower() if len(user_answers) > 0 else ""

          # Check if user answer matches any correct answer
          for correct_ans in correct_answers:
              if isinstance(correct_ans, dict):
                  # Old format support: {"value": "answer"}
                  correct_value = correct_ans.get("value", "").strip().lower()
              else:
                  # New format: just string
                  correct_value = str(correct_ans).strip().lower()

              if user_answer == correct_value:
                  window.console.log(f"Fill-Blank (Single) Score: 100% (matched '{correct_value}')")
                  return 100.0

          window.console.log(f"Fill-Blank (Single) Score: 0% (no match found)")
          return 0.0


    def _calculate_multi_mc_score(self, step_data, step_state):
      """
      Calculate score for multi-mc questions (fill-blank with dropdowns).
      Proportional scoring: score = (correct_blanks / total_blanks) * 100
      """
      blanks = step_data.get("blanks", {})
      user_answers = step_state.get("user_answers", {})

      print(f"üîç DEBUG _calculate_multi_mc_score:")
      print(f"  step_data keys: {list(step_data.keys())}")
      print(f"  blanks: {blanks}")
      print(f"  user_answers: {user_answers}")

      if not blanks:
          print(f"  ‚ö†Ô∏è No blanks found!")
          # Fallback: if step was marked correct, assume 100%
          is_correct = step_state.get("correct", False)
          if is_correct:
              print(f"  ‚úÖ Fallback: Using correct={is_correct} ‚Üí returning 100.0%")
              return 100.0
          else:
              print(f"  ‚ùå Fallback: Using correct={is_correct} ‚Üí returning 0.0%")
              return 0.0

      total_blanks = len(blanks)
      correct_count = 0

      for label, blank_data in blanks.items():
          correct_answer = blank_data.get("correct", "")
          user_answer = user_answers.get(label, "")
          is_match = (user_answer == correct_answer)
          print(f"  Blank '{label}': user='{user_answer}' vs correct='{correct_answer}' ‚Üí {is_match}")

          if is_match:
              correct_count += 1

      score = (correct_count / total_blanks) * 100.0 if total_blanks > 0 else 0.0
      print(f"  ‚Üí Multi-MC Score: {score:.1f}% ({correct_count}/{total_blanks} correct)\n")
      return score


    def _check_math_expression_correctness(self, step_data, step_state):
      """
      Re-check if a math expression answer is correct by comparing with expected answer.
      Returns True if correct, False otherwise.
      """
      user_answers = step_state.get("user_answers", [])
      if not user_answers:
          return False

      user_latex = user_answers[0] if len(user_answers) > 0 else ""
      expected_latex = step_data.get("expected", "")

      if not user_latex or not expected_latex:
          return False

      try:
          # Parse both answers
          user_expr = self.math_parser.parse_latex(user_latex)
          expected_expr = self.math_parser.parse_latex(expected_latex)

          if user_expr is None or expected_expr is None:
              return False

          # Normalize both
          user_normalized = self.math_parser.normalize_expr(user_expr)
          expected_normalized = self.math_parser.normalize_expr(expected_expr)

          # Check equality
          is_correct = self.math_parser.final_eq(user_normalized, expected_normalized)
          return is_correct

      except Exception as e:
          window.console.error(f"‚ùå Error checking math expression: {e}")
          return False


    def _check_mc_single_correctness(self, step_data, step_state):
      """
      Re-check if a multiple-choice-single answer is correct.
      Returns True if correct, False otherwise.
      """
      user_answers = step_state.get("user_answers", [])
      if not user_answers:
          return False

      user_answer = user_answers[0] if len(user_answers) > 0 else ""
      correct_answer = step_data.get("correct_answer", "")

      return user_answer == correct_answer


    def _check_true_false_correctness(self, step_data, step_state):
      """
      Re-check if a true/false answer is correct.
      Returns True if correct, False otherwise.
      """
      user_answers = step_state.get("user_answers", [])
      if not user_answers:
          return False

      user_answer = user_answers[0] if len(user_answers) > 0 else ""
      # ‚úÖ Convert to string first (could be boolean or string)
      user_answer_str = str(user_answer).lower()
      correct_answer = str(step_data.get("correct_answer", "true")).lower()

      return user_answer_str == correct_answer


    def submit_math_expression(self, step_idx):
      """Handle submission for math expression problems - checks correctness only"""
      if step_idx >= len(self.solve_state):
          return

      step = self.solve_state[step_idx]
      step_data = step.get("step_data") or step.get("step", {})
      container = step["container"]

      # Get answer field
      answer_mf = getattr(container, "answer_mf", None)

      # Get user answer
      user_latex = answer_mf.latex().strip() if answer_mf else ""
      if not user_latex:
          self.show_feedback(step_idx, "‚ö†Ô∏è Please enter an answer", "#92400e")
          return

      # Get expected answer
      expected_latex = step_data.get("expected", "").strip()

      if not expected_latex:
          self.show_feedback(step_idx, "‚ö†Ô∏è No expected answer defined", "#92400e")
          return

      window.console.log(f"üìù User LaTeX: {user_latex}")
      window.console.log(f"üìù Expected LaTeX: {expected_latex}")

      # Try to parse with error recovery
      try:
          window.console.log("Attempting to parse user expression...")
          user_expr = self.math_parser.parse_latex(user_latex)

          # üÜï Update MathQuill field with corrected LaTeX if auto-fixes were applied
          if self.math_parser.last_corrected_latex and answer_mf:
              window.console.log(f"üìù Updating MathQuill with corrected LaTeX: {self.math_parser.last_corrected_latex}")
              answer_mf.latex(self.math_parser.last_corrected_latex)

          if user_expr is None:
              window.console.log("‚ùå Parser returned None, attempting recovery...")
              self.show_parsing_error_with_recovery(step_idx, user_latex, "Parser returned None")
              return

      except Exception as e:
          window.console.log(f"‚ùå Exception during parsing: {e}")
          self.show_parsing_error_with_recovery(step_idx, user_latex, e)
          return

      # Parse expected answer
      try:
          expected_expr = self.math_parser.parse_latex(expected_latex)

          if expected_expr is None:
              self.show_feedback(step_idx, "‚ö†Ô∏è Could not parse expected answer (instructor error)", "#92400e")
              return

      except Exception as e:
          window.console.error(f"‚ùå Expected expression parsing error: {e}")
          self.show_feedback(step_idx, "‚ö†Ô∏è Could not parse expected answer (instructor error)", "#92400e")
          return

      window.console.log(f"‚úÖ User parsed: {user_expr}")
      window.console.log(f"‚úÖ Expected parsed: {expected_expr}")

      # Store for finalize
      step["parsed_user_answer"] = user_expr
      step["parsed_expected_answer"] = expected_expr
      step["last_correct_latex"] = user_latex
      step["user_answers"] = [user_latex]

      # ‚úÖ NEW: Get current problem index
      current_prob_idx = self.current_problem_index

      try:
          user_normalized = self.math_parser.normalize_expr(user_expr)
          expected_normalized = self.math_parser.normalize_expr(expected_expr)

          window.console.log(f"üîÑ User normalized: {user_normalized}")
          window.console.log(f"üîÑ Expected normalized: {expected_normalized}")

          is_correct = self.math_parser.final_eq(user_normalized, expected_normalized)
          window.console.log(f"{'‚úÖ' if is_correct else '‚ùå'} Correctness check: {is_correct}")

      except Exception as e:
          window.console.error(f"‚ùå Validation error: {e}")
          import traceback
          window.console.error(traceback.format_exc())
          self.show_feedback(step_idx, f"‚ö†Ô∏è Error checking answer: {str(e)}", "#92400e")
          return

      step["attempts"] = step.get("attempts", 0) + 1

      # ‚è±Ô∏è Stop timer and get elapsed time for this step
      if current_prob_idx is not None:
          time_taken = self.end_step_timer(current_prob_idx, step_idx, is_first_attempt=True)
          if time_taken is None:
              time_taken = 0
          window.console.log(f"‚è±Ô∏è Step {step_idx} elapsed time: {time_taken:.1f}s")
      else:
          time_taken = 0

      # ‚úÖ Check if this step requires correct answer
      must_correct = step_data.get("requireCorrect", False)

      if is_correct:
          step["correct"] = True

          # ‚úÖ CRITICAL: Update problem_states too
          if current_prob_idx is not None and current_prob_idx in self.problem_states:
              if step_idx < len(self.problem_states[current_prob_idx]):
                  import js
                  current_time = js.Date.now()

                  self.problem_states[current_prob_idx][step_idx]["correct"] = True
                  self.problem_states[current_prob_idx][step_idx]["score"] = 100.0
                  self.problem_states[current_prob_idx][step_idx]["user_answers"] = [user_latex]
                  self.problem_states[current_prob_idx][step_idx]["attempts"] = step["attempts"]

                  # ‚úÖ Add to attempt_history array
                  if "attempt_history" not in self.problem_states[current_prob_idx][step_idx]:
                      self.problem_states[current_prob_idx][step_idx]["attempt_history"] = []

                  attempt_entry = {
                      "timestamp": current_time,
                      "time_taken": time_taken,
                      "correct": True,
                      "score": 100.0,
                      "user_answer": user_latex
                  }
                  self.problem_states[current_prob_idx][step_idx]["attempt_history"].append(attempt_entry)

                  window.console.log(f"‚úÖ Updated problem_states: correct=True, score=100.0%, time={time_taken:.1f}s")

          self.show_feedback(step_idx, "‚úÖ Correct! Now click Finalize to verify your solution method.", "#059669")

          finalize_btn = container.querySelector(".finalize-step")
          if finalize_btn:
              finalize_btn.disabled = False
              finalize_btn.style.opacity = "1"

          submit_btn = container.querySelector(".submit-step")
          if submit_btn:
              submit_btn.disabled = True
              submit_btn.style.opacity = "0.5"

          self.add_to_global_history(step_idx, user_latex, True, time_taken, "submit")
      else:
          step["correct"] = False

          # ‚úÖ CRITICAL: Update problem_states too
          if current_prob_idx is not None and current_prob_idx in self.problem_states:
              if step_idx < len(self.problem_states[current_prob_idx]):
                  import js
                  current_time = js.Date.now()

                  self.problem_states[current_prob_idx][step_idx]["correct"] = False
                  self.problem_states[current_prob_idx][step_idx]["score"] = 0.0
                  self.problem_states[current_prob_idx][step_idx]["user_answers"] = [user_latex]
                  self.problem_states[current_prob_idx][step_idx]["attempts"] = step["attempts"]

                  # ‚úÖ Add to attempt_history array
                  if "attempt_history" not in self.problem_states[current_prob_idx][step_idx]:
                      self.problem_states[current_prob_idx][step_idx]["attempt_history"] = []

                  attempt_entry = {
                      "timestamp": current_time,
                      "time_taken": time_taken,
                      "correct": False,
                      "score": 0.0,
                      "user_answer": user_latex
                  }
                  self.problem_states[current_prob_idx][step_idx]["attempt_history"].append(attempt_entry)

                  window.console.log(f"‚úÖ Updated problem_states: correct=False, score=0.0%, time={time_taken:.1f}s")

          # ‚úÖ Show different message for requireCorrect steps
          if must_correct:
              self.show_feedback(step_idx, "‚ùå Incorrect. This step requires the correct answer. Please try again.", "#b91c1c")
          else:
              self.show_feedback(step_idx, "‚ùå Incorrect. Try again!", "#b91c1c")
          self.add_to_global_history(step_idx, user_latex, False, time_taken, "submit")

      self.save_to_storage()
    
    def show_parsing_error_with_recovery(self, step_idx, latex_str, error):
      """
      Show a helpful parsing error message with attempted recovery.
      """
      error_msg = str(error)
      window.console.log(f"‚ùå Parsing error: {error_msg}")

      # Try to get error position context
      position_info = self.get_error_position_context(latex_str, error_msg)

      # Attempt to recover
      success, fixed_latex, fix_description = self.attempt_latex_recovery(latex_str, error_msg)

      if success:
          # Recovery successful - show what was fixed and ask if they want to use it
          # Escape quotes in fixed_latex for JavaScript
          fixed_latex_escaped = fixed_latex.replace('\\', '\\\\').replace('"', '\\"')

          feedback = f"""
          <div style='background:#fef3c7;border:2px solid #f59e0b;border-radius:8px;padding:16px;'>
              <div style='font-weight:700;color:#92400e;margin-bottom:12px;'>
                  ‚ö†Ô∏è Syntax Error Detected (but we fixed it!)
              </div>
              <div style='margin-bottom:8px;'>
                  <strong>Your input:</strong><br>
                  <code style='background:#fff;padding:4px 8px;border-radius:4px;display:inline-block;margin-top:4px;'>{html.escape(latex_str)}</code>
              </div>
              <div style='margin-bottom:8px;'>
                  <strong>Issue found:</strong> {html.escape(fix_description)}
              </div>
              <div style='margin-bottom:12px;'>
                  <strong>Corrected to:</strong><br>
                  <code style='background:#fff;padding:4px 8px;border-radius:4px;display:inline-block;margin-top:4px;'>{html.escape(fixed_latex)}</code>
              </div>
              <button class='btn' onclick='window.problem_solver_app.use_corrected_latex({step_idx}, "{fixed_latex_escaped}");' 
                      style='background:#059669;color:white;'>
                  Use Corrected Version
              </button>
          </div>
          """
          self.show_feedback(step_idx, feedback, "#f59e0b")

          # Store the corrected version for later use
          step = self.solve_state[step_idx]
          step["suggested_correction"] = fixed_latex

      else:
          # Recovery failed - show helpful error message
          feedback_parts = [
              "<div style='background:#fee2e2;border:2px solid #dc2626;border-radius:8px;padding:16px;'>",
              "<div style='font-weight:700;color:#991b1b;margin-bottom:12px;'>‚ùå Cannot Parse Expression</div>",
              f"<div style='margin-bottom:8px;'><strong>Your input:</strong><br><code style='background:#fff;padding:4px 8px;border-radius:4px;display:inline-block;margin-top:4px;'>{html.escape(latex_str)}</code></div>",
          ]

          if position_info:
              feedback_parts.append(f"<div style='margin-bottom:8px;'><strong>{html.escape(position_info)}</strong></div>")

          feedback_parts.append("<div style='margin-bottom:8px;'><strong>Common issues:</strong></div>")
          feedback_parts.append("<ul style='margin:8px 0;padding-left:20px;'>")
          feedback_parts.append("<li>Check for matching brackets: ( ), { }, [ ]</li>")
          feedback_parts.append("<li>Remove empty power braces: x^{} should be x</li>")
          feedback_parts.append("<li>Remove trailing power symbols: x^ should be x</li>")
          feedback_parts.append("<li>Ensure fractions are complete: \\frac{numerator}{denominator}</li>")
          feedback_parts.append("<li>Check for double operators like ++ or --</li>")
          feedback_parts.append("</ul>")
          feedback_parts.append("<div style='margin-top:12px;font-size:14px;'>Please correct your input and try again.</div>")
          feedback_parts.append("</div>")

          self.show_feedback(step_idx, "".join(feedback_parts), "#dc2626")
    
    def get_error_position_context(self, latex_str, error_msg):
        """
        Try to extract position information from error message and provide context.
        Returns a string showing the error location visually.
        """
        import re

        # Look for patterns like "at position X" or "column X" or "index X"
        position_patterns = [
            r'position\s+(\d+)',
            r'column\s+(\d+)',
            r'index\s+(\d+)',
            r'at\s+(\d+)',
            r'col\s+(\d+)',
        ]

        position = None
        for pattern in position_patterns:
            match = re.search(pattern, str(error_msg), re.IGNORECASE)
            if match:
                position = int(match.group(1))
                break

        if position is not None and 0 <= position < len(latex_str):
            at_error = latex_str[position] if position < len(latex_str) else ''
            context = f"\n{latex_str}\n{' ' * position}^ Error here"
            window.console.log(f"Error position: {position}")
            window.console.log(context)
            return f"Error at position {position}: '{at_error}'"

        return None


    def show_parsing_error_with_recovery(self, step_idx, latex_str, error):
        """
        Show a helpful parsing error message with attempted recovery.
        """
        error_msg = str(error)
        window.console.log(f"‚ùå Parsing error: {error_msg}")

        # Try to get error position context
        position_info = self.get_error_position_context(latex_str, error_msg)

        # Attempt to recover
        success, fixed_latex, fix_description = self.attempt_latex_recovery(latex_str, error_msg)

        if success:
            # Recovery successful - show what was fixed
            fixed_latex_escaped = fixed_latex.replace('\\', '\\\\').replace('"', '\\"')

            feedback = f"""
            <div style='background:#fef3c7;border:2px solid #f59e0b;border-radius:8px;padding:16px;'>
                <div style='font-weight:700;color:#92400e;margin-bottom:12px;'>
                    ‚ö†Ô∏è Syntax Error Detected (but we fixed it!)
                </div>
                <div style='margin-bottom:8px;'>
                    <strong>Your input:</strong><br>
                    <code style='background:#fff;padding:4px 8px;border-radius:4px;display:inline-block;margin-top:4px;'>{html.escape(latex_str)}</code>
                </div>
                <div style='margin-bottom:8px;'>
                    <strong>Issue found:</strong> {html.escape(fix_description)}
                </div>
                <div style='margin-bottom:12px;'>
                    <strong>Corrected to:</strong><br>
                    <code style='background:#fff;padding:4px 8px;border-radius:4px;display:inline-block;margin-top:4px;'>{html.escape(fixed_latex)}</code>
                </div>
                <button class='btn' onclick='window.problem_solver_app.use_corrected_latex({step_idx}, "{fixed_latex_escaped}");' 
                        style='background:#059669;color:white;'>
                    Use Corrected Version
                </button>
            </div>
            """
            self.show_feedback(step_idx, feedback, "#f59e0b")

            # Store the corrected version
            step = self.solve_state[step_idx]
            step["suggested_correction"] = fixed_latex

        else:
            # Recovery failed - show helpful error message
            feedback_parts = [
                "<div style='background:#fee2e2;border:2px solid #dc2626;border-radius:8px;padding:16px;'>",
                "<div style='font-weight:700;color:#991b1b;margin-bottom:12px;'>‚ùå Cannot Parse Expression</div>",
                f"<div style='margin-bottom:8px;'><strong>Your input:</strong><br><code style='background:#fff;padding:4px 8px;border-radius:4px;display:inline-block;margin-top:4px;'>{html.escape(latex_str)}</code></div>",
            ]

            if position_info:
                feedback_parts.append(f"<div style='margin-bottom:8px;'><strong>{html.escape(position_info)}</strong></div>")

            feedback_parts.append("<div style='margin-bottom:8px;'><strong>Common issues:</strong></div>")
            feedback_parts.append("<ul style='margin:8px 0;padding-left:20px;'>")
            feedback_parts.append("<li>Check for matching brackets: ( ), { }, [ ]</li>")
            feedback_parts.append("<li>Remove empty power braces: x^{} should be x</li>")
            feedback_parts.append("<li>Remove trailing power symbols: x^ should be x</li>")
            feedback_parts.append("<li>Ensure fractions are complete: \\frac{numerator}{denominator}</li>")
            feedback_parts.append("</ul>")
            feedback_parts.append("<div style='margin-top:12px;font-size:14px;'>Please correct your input and try again.</div>")
            feedback_parts.append("</div>")

            self.show_feedback(step_idx, "".join(feedback_parts), "#dc2626")


    def use_corrected_latex(self, step_idx, corrected_latex):
        """
        Use the suggested corrected LaTeX string and submit it.
        """
        window.console.log(f"use_corrected_latex called: step={step_idx}, latex={corrected_latex}")

        if step_idx >= len(self.solve_state):
            window.console.error(f"Invalid step index: {step_idx}")
            return

        step = self.solve_state[step_idx]
        container = step["container"]

        # Get the MathQuill field and set the corrected value
        answer_mf = getattr(container, "answer_mf", None)
        if answer_mf:
            answer_mf.latex(corrected_latex)
            window.console.log(f"‚úÖ Applied corrected LaTeX: {corrected_latex}")

            # Clear the feedback
            self.show_feedback(step_idx, "üîÑ Using corrected version...", "#3b82f6")

            # Auto-submit after a short delay
            def delayed_submit():
                self.submit_math_expression(step_idx)

            window.setTimeout(create_proxy(delayed_submit), 100)
        else:
            window.console.error("Could not find MathQuill field")
    
    def attempt_latex_recovery(self, latex_str, error_msg):
      """
      Attempt to recover from LaTeX parsing errors by trying common fixes.
      Returns (success, fixed_latex, fix_description) or (False, None, None)
      """
      window.console.log(f"üîß Attempting to recover from error: {error_msg}")
      window.console.log(f"üîß Original LaTeX: {latex_str}")

      import re

      # ===== FIX FUNCTIONS =====

      def fix_empty_power_braces(s):
          """Fix empty power braces like x^{} or x^{ } to x"""
          try:
              original = s
              # Remove ^{} (no space)
              s = s.replace('^{}', '')

              # Remove ^{ } (with any whitespace)
              pattern = r'\^\{\s*\}'
              s = re.sub(pattern, '', s)

              if s != original:
                  window.console.log(f"  Fixed: Removed empty power braces")
              return s
          except Exception as e:
              window.console.log(f"  Error in fix_empty_power_braces: {e}")
              return s

      def remove_trailing_power_symbol(s):
          """Remove trailing ^ at the end of expression or before operators"""
          try:
              original = s
              # Remove ^ at end
              if s.endswith('^'):
                  s = s[:-1]
              # Remove ^ before operators
              for op in ['+', '-', '*', '/', ')', ']', '}', ' ', '\\']:
                  s = s.replace('^' + op, op)
              if s != original:
                  window.console.log(f"  Fixed: Removed trailing power symbol(s)")
          except Exception as e:
              window.console.log(f"  Error in remove_trailing_power_symbol: {e}")
          return s

      def fix_double_power_symbol(s):
          """Fix double power symbols like x^^2 to x^2"""
          try:
              if '^^' in s:
                  fixed = s.replace('^^', '^')
                  window.console.log(f"  Fixed: Double power symbol (^^)")
                  return fixed
          except Exception as e:
              window.console.log(f"  Error in fix_double_power_symbol: {e}")
          return s

      def remove_empty_power(s):
          """Remove power symbol with no exponent like x^ y"""
          try:
              # Look for ^ followed by space or operator
              fixed = s
              fixed = fixed.replace('^ ', ' ')
              fixed = fixed.replace('^+', '+')
              fixed = fixed.replace('^-', '-')
              fixed = fixed.replace('^*', '*')
              fixed = fixed.replace('^/', '/')
              if fixed != s:
                  window.console.log(f"  Fixed: Removed empty power symbol(s)")
                  return fixed
          except Exception as e:
              window.console.log(f"  Error in remove_empty_power: {e}")
          return s

      def smart_bracket_balance(s):
          """Balance all types of brackets"""
          try:
              fixed = s

              # Parentheses
              open_p = fixed.count('(')
              close_p = fixed.count(')')
              if open_p > close_p:
                  fixed = fixed + ')' * (open_p - close_p)
              elif close_p > open_p:
                  for _ in range(close_p - open_p):
                      fixed = fixed.replace(')', '', 1)

              # Braces
              open_b = fixed.count('{')
              close_b = fixed.count('}')
              if open_b > close_b:
                  fixed = fixed + '}' * (open_b - close_b)
              elif close_b > open_b:
                  for _ in range(close_b - open_b):
                      fixed = fixed.replace('}', '', 1)

              if fixed != s:
                  window.console.log(f"  Fixed: Balanced brackets")
              return fixed
          except Exception as e:
              window.console.log(f"  Error in smart_bracket_balance: {e}")
              return s

      def fix_row_operation_subscripts(s):
          """Fix R1, R2, etc. to R_1, R_2"""
          try:
              fixed = s
              # Simple replacement for common cases
              for i in range(1, 10):
                  # Don't replace if already has underscore
                  if f'R{i}' in fixed and f'R_{i}' not in fixed:
                      # Check if R is followed by digit but not preceded by underscore
                      parts = fixed.split(f'R{i}')
                      result = []
                      for j, part in enumerate(parts):
                          result.append(part)
                          if j < len(parts) - 1:
                              # Check if previous part doesn't end with underscore
                              if not part.endswith('_'):
                                  result.append(f'R_{{{i}}}')
                              else:
                                  result.append(f'R{i}')
                      fixed = ''.join(result)

              if fixed != s:
                  window.console.log(f"  Fixed: Row operation subscripts")
              return fixed
          except Exception as e:
              window.console.log(f"  Error in fix_row_operation_subscripts: {e}")
              return s

      def fix_row_operation_pipes(s):
          """Fix missing closing pipe in row operations like [[matrix]]|ops -> [[matrix]]|ops|"""
          try:
              if '|' in s and 'R_' in s:
                  # Check if we have unbalanced pipes
                  pipe_count = s.count('|') + s.count(r'\left|') + s.count(r'\right|')

                  # Look for pattern: matrix followed by single pipe and row operation but no closing pipe
                  # Pattern: ]]|R_... without closing |
                  if pipe_count % 2 == 1:  # Odd number of pipes suggests missing closing
                      # If ends with R_n or operation without closing pipe, add it
                      if not s.rstrip().endswith('|') and not s.rstrip().endswith(r'\right|'):
                          fixed = s + '|'
                          window.console.log(f"  Fixed: Added missing closing pipe for row operation")
                          return fixed
              return s
          except Exception as e:
              window.console.log(f"  Error in fix_row_operation_pipes: {e}")
              return s

      def fix_row_operation_brackets(s):
          """Fix unbalanced square brackets in row operations"""
          try:
              # Count square brackets (ignoring LaTeX commands like \left[ \right])
              open_brackets = s.count('[')
              close_brackets = s.count(']')

              if open_brackets > close_brackets:
                  # Add missing closing brackets before the pipe if there's a row operation
                  if '|' in s and 'R_' in s:
                      # Find the first pipe
                      pipe_pos = s.find('|')
                      if pipe_pos > 0:
                          # Insert missing ] before the pipe
                          missing = open_brackets - close_brackets
                          fixed = s[:pipe_pos] + (']' * missing) + s[pipe_pos:]
                          window.console.log(f"  Fixed: Added {missing} missing closing bracket(s)")
                          return fixed
                  else:
                      # Just add at the end
                      fixed = s + (']' * (open_brackets - close_brackets))
                      window.console.log(f"  Fixed: Balanced square brackets")
                      return fixed
              elif close_brackets > open_brackets:
                  # Remove extra closing brackets
                  for _ in range(close_brackets - open_brackets):
                      s = s.replace(']', '', 1)
                  window.console.log(f"  Fixed: Removed extra closing bracket(s)")
                  return s
              return s
          except Exception as e:
              window.console.log(f"  Error in fix_row_operation_brackets: {e}")
              return s

      # ===== LIST OF FIXES =====

      fixes = [
          (fix_empty_power_braces, "Removed empty power braces (^{} or ^{ })"),
          (remove_trailing_power_symbol, "Removed trailing power symbol (^)"),
          (fix_double_power_symbol, "Fixed double power symbol (^^)"),
          (remove_empty_power, "Removed empty power symbol"),
          (fix_row_operation_subscripts, "Fixed row operation subscripts"),
          (fix_row_operation_brackets, "Fixed unbalanced brackets in row operations"),
          (fix_row_operation_pipes, "Added missing closing pipe for row operation"),
          (smart_bracket_balance, "Balanced brackets and parentheses"),
      ]

      # ===== TRY EACH FIX =====

      for fix_func, description in fixes:
          try:
              fixed = fix_func(latex_str)
              if fixed != latex_str:
                  window.console.log(f"  Trying: {description}")
                  window.console.log(f"    Original: {latex_str}")
                  window.console.log(f"    Fixed: {fixed}")

                  # Try to parse
                  try:
                      parsed = self.math_parser.parse_latex(fixed)
                      if parsed is not None:
                          window.console.log(f"  ‚úÖ SUCCESS: {description}")
                          return (True, fixed, description)
                      else:
                          window.console.log(f"  ‚ùå Parser returned None")
                  except Exception as parse_error:
                      window.console.log(f"  ‚ùå Parse failed: {parse_error}")
          except Exception as e:
              window.console.log(f"  ‚ùå Fix error: {e}")

      # Try combined fixes
      window.console.log("  Trying combined fixes...")
      try:
          combined = latex_str
          combined = fix_empty_power_braces(combined)
          combined = remove_trailing_power_symbol(combined)
          combined = fix_double_power_symbol(combined)
          combined = remove_empty_power(combined)
          combined = fix_row_operation_subscripts(combined)
          combined = fix_row_operation_brackets(combined)
          combined = fix_row_operation_pipes(combined)
          combined = smart_bracket_balance(combined)

          if combined != latex_str:
              window.console.log(f"    Original: {latex_str}")
              window.console.log(f"    Combined result: {combined}")
              parsed = self.math_parser.parse_latex(combined)
              if parsed is not None:
                  window.console.log(f"  ‚úÖ Combined fix successful!")
                  return (True, combined, "Fixed brackets, pipes, and power symbols")
              else:
                  window.console.log(f"  ‚ùå Combined fix: Parser returned None")
      except Exception as e:
          window.console.log(f"  ‚ùå Combined fix failed: {e}")

      window.console.log("‚ùå No successful recovery found")
      return (False, None, None)
    
    def show_feedback(self, step_idx, message, color):
        """Show feedback message with flashing effect for incorrect answers"""
        if step_idx >= len(self.solve_state):
            return
        
        step = self.solve_state[step_idx]
        feedback = step["container"].querySelector(".step-feedback")
        if feedback:
            # Check if this is an incorrect answer (red color or contains error indicators)
            is_incorrect = (
                "‚ùå" in message or 
                "Incorrect" in message or 
                "Wrong" in message or
                "wrong" in message or
                color.lower() in ["#b91c1c", "#ef4444", "#dc2626", "#f87171"]
            )
            
            feedback.innerHTML = f"<div style='color:{color};background:{color}20;padding:12px;border-radius:6px;'>{message}</div>"
            
            # Add flashing animation for incorrect answers
            if is_incorrect:
                # Get the inner div that was just created
                inner_div = feedback.querySelector("div")
                if inner_div:
                    inner_div.classList.add("flash-incorrect")
                    
                    # Remove the flashing class after animation completes (3 seconds)
                    def remove_flash():
                        if inner_div:
                            inner_div.classList.remove("flash-incorrect")
                    window.setTimeout(create_proxy(remove_flash), 3000)
    
    def next_step(self, step_idx):
      """Move to next step with prominent transition animations"""
      if step_idx >= len(self.solve_state):
          return

      # Get current and next step containers
      current_container = self.solve_state[step_idx]["container"]

      if step_idx + 1 >= len(self.solve_state):
          # No next step available
          current_container.style.display = "none"
          current_container.classList.remove("active")
          self.save_to_storage()
          return

      next_container = self.solve_state[step_idx + 1]["container"]
      next_step_number = step_idx + 2  # Display as 1-indexed

      # ‚úÖ SHOW TRANSITION BANNER
      banner = document.getElementById("stepTransitionBanner")
      banner_number = document.getElementById("bannerStepNumber")
      overlay = document.getElementById("transitionOverlay")

      if banner and banner_number and overlay:
          banner_number.textContent = str(next_step_number)

          # Show overlay
          overlay.classList.add("active")

          # Show banner with animation
          banner.classList.add("show")
          window.console.log(f"üéØ Showing transition banner: Moving to Step {next_step_number}")

          # Remove banner animation class after animation completes
          def hide_banner():
              banner.classList.remove("show")
              overlay.classList.remove("active")

          window.setTimeout(create_proxy(hide_banner), 1500)

      # ‚úÖ ANIMATE CURRENT STEP OUT
      current_container.classList.add("sliding-out")

      def complete_transition():
          # Hide current step
          current_container.style.display = "none"
          current_container.classList.remove("active", "sliding-out")

          # Show and animate next step in
          next_container.style.display = "block"
          next_container.classList.add("active", "sliding-in")

          # Remove sliding-in class after animation
          def remove_slide_class():
              next_container.classList.remove("sliding-in")
          window.setTimeout(create_proxy(remove_slide_class), 600)

          # ‚úÖ Animate step number transition
          self.animate_step_number(step_idx, step_idx + 1)

          # ‚úÖ Render MathJax for the newly visible step
          def render_step_mathjax(retry_count=0):
              max_retries = 3
              try:
                  if hasattr(window, 'MathJax') and hasattr(window.MathJax, 'typesetPromise'):
                      window.console.log("üé® Rendering MathJax for next step...")
                      window.MathJax.typesetPromise([next_container]).then(
                          create_proxy(lambda result: window.console.log("‚úÖ Step MathJax rendered"))
                      )
                  elif retry_count < max_retries:
                      window.setTimeout(create_proxy(lambda: render_step_mathjax(retry_count + 1)), 200)
              except Exception as e:
                  window.console.error(f"Step MathJax render error: {e}")

          window.setTimeout(create_proxy(render_step_mathjax), 100)

      # Wait for slide-out animation to complete before showing next step
      window.setTimeout(create_proxy(complete_transition), 500)

      self.save_to_storage()
    
    def export_progress(self, event):
        """Export progress"""
        if not self.problem_set:
            window.alert("No problems to submit")
            return
        
        try:
            # Build export data
            export_data = {
                "problem_set_id": self.current_problem_set_uuid,
                "problem_set": self.problem_set,
                "problem_states": self.problem_states,
                "export_date": window.Date.new().toISOString()
            }
            
            json_str = json.dumps(export_data)
            
            # Compress
            import brotli
            compressed = brotli.compress(json_str.encode('utf-8'))
            b64_str = base64.b64encode(compressed).decode('utf-8')
            
            # Create file
            output = f"=== STUDENT PROGRESS EXPORT ===\n{b64_str}\n=== END EXPORT ==="
            
            blob = window.Blob.new([output], {"type": "text/plain"})
            url = window.URL.createObjectURL(blob)
            a = document.createElement("a")
            a.href = url
            a.download = f"progress_{window.Date.new().toISOString().split('T')[0]}.txt"
            document.body.appendChild(a)
            a.click()
            a.remove()
            
            window.setTimeout(create_proxy(lambda: window.URL.revokeObjectURL(url)), 1000)
            
            window.alert("‚úÖ Progress exported successfully!")
            
        except Exception as e:
            window.console.error(f"Export failed: {e}")
            window.alert(f"‚ùå Export failed: {e}")

    def share_via_whatsapp(self, event):
        """Share progress via WhatsApp"""
        if not self.problem_set:
            window.alert("No problems to share")
            return

        try:
            # Get teacher's WhatsApp number
            teacher_number = getattr(self, 'teacher_whatsapp_number', None)
            if not teacher_number:
                teacher_number = window.prompt(
                    "Enter teacher's WhatsApp number (include country code):",
                    "+62"
                )
                if not teacher_number:
                    return  # User cancelled

                # Clean and save number
                teacher_number = teacher_number.replace("+", "").replace("-", "").replace(" ", "")
                self.teacher_whatsapp_number = teacher_number
                window.console.log(f"‚úÖ Teacher WhatsApp number saved: +{teacher_number}")

            # Build export data
            export_data = {
                "problem_set_id": self.current_problem_set_uuid,
                "problem_set": self.problem_set,
                "problem_states": self.problem_states,
                "export_date": window.Date.new().toISOString()
            }

            json_str = json.dumps(export_data)

            # Compress
            import brotli
            compressed = brotli.compress(json_str.encode('utf-8'))
            b64_str = base64.b64encode(compressed).decode('utf-8')

            # Create message with standard format (same as file export for analytics compatibility)
            message = f"üéì Student Progress Submission\n\n=== STUDENT PROGRESS EXPORT ===\n{b64_str}\n=== END EXPORT ===\n\nSubmitted via Problem Solver"

            # Check if message needs segmentation (WhatsApp limit: 3500 chars)
            MAX_LENGTH = 3500
            if len(message) > MAX_LENGTH:
                # Segment the message - use standard multi-part format
                header = "üéì Student Progress Submission\n\n"
                content = b64_str
                footer = "\nSubmitted via Problem Solver"

                # Calculate segment size
                segment_marker_size = 50  # Reserve for part markers
                first_segment_size = MAX_LENGTH - len(header) - len("=== STUDENT PROGRESS EXPORT (Part 1/X) ===\n") - segment_marker_size

                segments = []
                pos = 0
                while pos < len(content):
                    segment_content = content[pos:pos + first_segment_size]
                    segments.append(segment_content)
                    pos += first_segment_size

                total_parts = len(segments)

                # Build first segment with standard multi-part format
                first_msg = header + f"=== STUDENT PROGRESS EXPORT (Part 1/{total_parts}) ===\n{segments[0]}\n=== END PART 1 ===" + footer

                # Open WhatsApp with first segment
                url = f"https://wa.me/{teacher_number}?text={window.encodeURIComponent(first_msg)}"
                window.open(url, "_blank")

                # Show remaining segments
                if total_parts > 1:
                    remaining_parts = []
                    for i in range(1, total_parts):
                        part_msg = header + f"=== STUDENT PROGRESS EXPORT (Part {i+1}/{total_parts}) ===\n{segments[i]}\n=== END PART {i+1} ===" + footer
                        remaining_parts.append(part_msg)

                    remaining_text = "\n\n".join([f"=== COPY THIS (Part {i+2}) ===\n{msg}\n" for i, msg in enumerate(remaining_parts)])
                    window.alert(f"‚úÖ Message split into {total_parts} parts!\n\nPart 1 opened in WhatsApp.\n\nCopy and send the remaining parts below:\n\n{remaining_text}")
            else:
                # Message fits in one segment
                url = f"https://wa.me/{teacher_number}?text={window.encodeURIComponent(message)}"
                window.open(url, "_blank")
                window.alert("‚úÖ WhatsApp opened! Send the message to your teacher.")

        except Exception as e:
            window.console.error(f"WhatsApp share failed: {e}")
            window.alert(f"‚ùå Failed to share via WhatsApp: {e}")

    def share_via_telegram(self, event):
        """Share progress via Telegram"""
        if not self.problem_set:
            window.alert("No problems to share")
            return

        try:
            # Get teacher's name
            teacher_name = getattr(self, 'teacher_name', None)
            if not teacher_name:
                teacher_name = window.prompt("Enter teacher's name:", "")
                if not teacher_name:
                    return  # User cancelled
                self.teacher_name = teacher_name

            # Get student's phone number
            student_phone = getattr(self, 'student_phone_number', None)
            if not student_phone:
                student_phone = window.prompt(
                    "Enter your phone number (with country code):",
                    "+62"
                )
                if not student_phone:
                    return  # User cancelled
                self.student_phone_number = student_phone

            # Get teacher's Telegram username
            teacher_username = getattr(self, 'teacher_telegram_username', None)
            if not teacher_username:
                teacher_username = window.prompt(
                    "Enter teacher's Telegram username (without @):",
                    ""
                )
                if not teacher_username:
                    return  # User cancelled
                teacher_username = teacher_username.replace("@", "")
                self.teacher_telegram_username = teacher_username

            window.console.log(f"‚úÖ Info saved - Teacher: {teacher_name}, Student Phone: {student_phone}, Telegram: @{teacher_username}")

            # Build export data
            export_data = {
                "problem_set_id": self.current_problem_set_uuid,
                "problem_set": self.problem_set,
                "problem_states": self.problem_states,
                "export_date": window.Date.new().toISOString()
            }

            json_str = json.dumps(export_data)

            # Compress
            import brotli
            compressed = brotli.compress(json_str.encode('utf-8'))
            b64_str = base64.b64encode(compressed).decode('utf-8')

            # Create message with phone number
            message = f"üéì Progress Report\n\nTo: {teacher_name}\nFrom: Student\nPhone: {student_phone}\n\n{b64_str}\n\n---\nSent via Problem Solver"

            # Check if message needs segmentation (Telegram limit: 4000 chars)
            MAX_LENGTH = 4000
            if len(message) > MAX_LENGTH:
                # Segment the message
                header = f"üéì Progress Report\n\nTo: {teacher_name}\nFrom: Student\nPhone: {student_phone}\n\n"
                footer = "\n\n---\nSent via Problem Solver"
                content = b64_str

                # Calculate how much content fits in first segment
                first_segment_size = MAX_LENGTH - len(header) - len(footer) - 20  # Reserve for part marker

                segments = []
                pos = 0
                while pos < len(content):
                    segment_content = content[pos:pos + first_segment_size]
                    segments.append(segment_content)
                    pos += first_segment_size

                total_parts = len(segments)

                # Build first segment with part marker
                first_msg = header + segments[0] + f"\n\n[Part 1/{total_parts}]" + footer

                # Open Telegram with first segment
                url = f"https://t.me/{teacher_username}?text={window.encodeURIComponent(first_msg)}"
                window.open(url, "_blank")

                # Show remaining segments
                if total_parts > 1:
                    remaining_parts = []
                    for i in range(1, total_parts):
                        part_msg = header + segments[i] + f"\n\n[Part {i+1}/{total_parts}]" + footer
                        remaining_parts.append(f"--- Part {i+1} ---\n{part_msg}")

                    window.alert(f"‚úÖ Message split into {total_parts} parts!\n\nPart 1 opened in Telegram.\n\nPlease copy and send remaining parts:\n\n" + "\n\n".join(remaining_parts))
            else:
                # Message fits in one segment
                url = f"https://t.me/{teacher_username}?text={window.encodeURIComponent(message)}"
                window.open(url, "_blank")
                window.alert("‚úÖ Telegram opened! Send the message to your teacher.")

        except Exception as e:
            window.console.error(f"Telegram share failed: {e}")
            window.alert(f"‚ùå Failed to share via Telegram: {e}")

    def handle_freestyle_input(self, action):
        """Handle keyboard input for freestyle practice"""
        try:
            # Determine which field to target
            if self.freestyle_problem:
                target_field = self.freestyle_answer_mf
            else:
                target_field = self.freestyle_problem_mf

            if not target_field:
                return

            # Use the comprehensive KeyboardInputHandler
            KeyboardInputHandler.handle_action(target_field, action)

        except Exception as e:
            window.console.error(f"Input handler error: {e}")

    def set_freestyle_problem(self, event):
      """Set the freestyle problem with limit validation"""
      window.console.log("=== set_freestyle_problem called ===")

      if not self.freestyle_problem_mf:
          window.alert("‚ö†Ô∏è Problem input not ready")
          return

      problem_latex = self.freestyle_problem_mf.latex().strip()
      window.console.log(f"Problem latex: {problem_latex}")

      if not problem_latex:
          window.alert("‚ö†Ô∏è Please enter a problem first")
          return

      # Check if this is a matrix row operation problem
      # Multiple patterns to catch different formats
      is_matrix_row_op = (
          '|R_' in problem_latex or 
          '|\\mathrm{R}_' in problem_latex or
          '\\left|R_' in problem_latex or
          '\\left|\\mathrm{R}_' in problem_latex or
          '\\right|' in problem_latex  # Closing pipe for row ops
      )

      if is_matrix_row_op:
        window.console.log("üîç Detected matrix row operation problem")
        window.console.log(f"Original LaTeX: {problem_latex}")

        # Parse to validate/check for errors, but don't use the result
        try:
            window.console.log("Parsing row operation to check for errors...")
            parsed_for_validation = self.math_parser.parse_latex(problem_latex)
            window.console.log(f"‚úÖ Parse successful (for validation): {parsed_for_validation}")
            window.console.log("‚ö†Ô∏è BUT we will NOT use this parsed result - only for error checking")
        except Exception as e:
            window.console.error(f"‚ùå Parse error in row operation: {e}")
            import traceback
            window.console.error(traceback.format_exc())
            window.alert(f"‚ö†Ô∏è Parse error: {e}")
            return  # Exit if there's a parse error

        # Store the ORIGINAL LaTeX (not the parsed/solved version)
        self.freestyle_problem = {
            "latex": problem_latex,  # ORIGINAL LaTeX with row operation
            "parsed": None,  # Don't store parsed for row operations
            "is_row_operation": True  # Flag to indicate special handling
        }

        window.console.log(f"‚úÖ Row operation stored with ORIGINAL LaTeX (not solved)")

        # Reset state
        self.freestyle_attempts = []
        self.freestyle_correct = False
        self.freestyle_finalized = False

        if self.freestyle_answer_mf:
            self.freestyle_answer_mf.latex("")

        # Show solve area
        solve_area = document.querySelector("#freestyleSolveArea")
        if solve_area:
            solve_area.style.display = "block"

        # Display problem - convert matrix part, keep operation part
        problem_display = document.querySelector("#freestyleProblemDisplay")
        if problem_display:
            try:
                import sympy as sp
                import re

                # Split at the pipe: matrix part | operation part
                match = re.match(r'(.+?)(\\left\|.*?\\right\|)', problem_latex)

                if match:
                    matrix_part = match.group(1)
                    operation_part = match.group(2)

                    window.console.log(f"Split row operation for display:")
                    window.console.log(f"  Matrix part: {matrix_part}")
                    window.console.log(f"  Operation part: {operation_part}")

                    # Parse and convert only the matrix part (NOT the whole row operation)
                    parsed_matrix = self.math_parser.parse_latex(matrix_part)
                    converted_matrix = self._convert_latex_preserve_order(parsed_matrix)

                    # Combine: converted matrix + original operation
                    display_latex = converted_matrix + operation_part

                    window.console.log(f"  ‚úÖ Combined for display: {display_latex}")
                    problem_display.innerHTML = f"$$\\displaystyle {display_latex}$$"
                else:
                    # Fallback if regex doesn't match
                    window.console.log("Regex didn't match, using original")
                    problem_display.innerHTML = f"$$\\displaystyle {problem_latex}$$"

            except Exception as e:
                window.console.error(f"Error converting row operation for display: {e}")
                import traceback
                window.console.error(traceback.format_exc())
                # Fallback to original
                problem_display.innerHTML = f"$$\\displaystyle {problem_latex}$$"

            if hasattr(window, 'MathJax') and hasattr(window.MathJax, 'typesetPromise'):
                window.MathJax.typesetPromise([problem_display])

        # Clear feedback
        feedback_el = document.querySelector("#freestyleFeedback")
        if feedback_el:
            feedback_el.innerHTML = ""

        history_el = document.querySelector("#freestyleHistory")
        if history_el:
            history_el.innerHTML = ""

        # For row operations, difficulty is always 3 (medium)
        difficulty = 3
        credits_needed = difficulty

        giveup_btn = document.querySelector("#freestyleGiveUp")
        if giveup_btn:
            giveup_btn.textContent = f"Give Up (üíé {credits_needed} credit{'s' if credits_needed != 1 else ''})"

            if self.credit_balance >= credits_needed:
                giveup_btn.disabled = False
                giveup_btn.style.opacity = "1"
                giveup_btn.title = f"Use {credits_needed} credit{'s' if credits_needed != 1 else ''} to reveal solution"
            else:
                giveup_btn.disabled = True
                giveup_btn.style.opacity = "0.5"
                shortage = credits_needed - self.credit_balance
                giveup_btn.title = f"Need {shortage} more credit{'s' if shortage != 1 else ''} to use this (you have {self.credit_balance})"

        # For row operations, disable finalize button (they work manually)
        finalize_btn = document.querySelector("#freestyleFinalize")
        if finalize_btn:
            finalize_btn.disabled = True
            finalize_btn.style.opacity = "0.5"
            finalize_btn.title = "Row operation problems don't need simplification check"

        # Enable submit button
        submit_btn = document.querySelector("#freestyleSubmit")
        if submit_btn:
            submit_btn.disabled = False
            submit_btn.style.opacity = "1"

        window.alert("‚úÖ Matrix row operation problem set! Solve it by performing the operation.")
        return  # Exit early for row operations


      # REGULAR PROBLEMS (not row operations) - parse and normalize as usual
      # Parse the problem to validate it
      try:
          window.console.log("Parsing problem...")
          parsed = self.math_parser.parse_latex(problem_latex)
          window.console.log(f"Parsed: {parsed}")
          window.console.log(f"Parsed type: {type(parsed)}")

          if parsed is None:
              window.alert("‚ö†Ô∏è Could not parse the problem. Please check your input.")
              return
      except Exception as e:
          window.console.error(f"Parse error: {e}")
          import traceback
          window.console.error(traceback.format_exc())
          window.alert(f"‚ö†Ô∏è Parse error: {e}")
          return

      # ‚úÖ VALIDATE LIMIT PROBLEMS
      import sympy as sp
      if isinstance(parsed, sp.Limit):
          try:
              window.console.log("üîç Validating limit problem...")
              is_valid, error_msg = self.math_parser.validate_limit(parsed)

              if not is_valid:
                  window.console.error(f"Invalid limit problem: {error_msg}")

                  full_error_msg = f"""{error_msg}

  Please choose a limit problem with a finite, well-defined value.

  Common issues to avoid:
  - Limits that equal infinity or negative infinity
  - Limits with different left and right values (discontinuities)
  - Oscillating limits that don't converge to a single value
  - Limits that are undefined or indeterminate

  Try using limits that evaluate to specific finite numbers instead."""

                  self._show_limit_validation_error_popup(full_error_msg)
                  return

              window.console.log("‚úÖ Limit validation passed")
          except Exception as e:
              window.console.error(f"Limit validation error: {e}")
              import traceback
              window.console.error(traceback.format_exc())
              pass

      # Normal problems: normalize to check for errors and get expected answer
      try:
          window.console.log("Normalizing to check for errors...")
          normalized = self.math_parser.normalize_expr(parsed)
          window.console.log(f"Normalization check passed. Result: {normalized}")

          # Store the problem with the RAW parsed expression
          self.freestyle_problem = {
              "latex": problem_latex,
              "parsed": parsed,
              "is_row_operation": False
          }
          window.console.log("‚úÖ Problem stored successfully")

      except Exception as e:
          window.console.error(f"Error processing problem: {e}")
          import traceback
          window.console.error(traceback.format_exc())
          window.alert(f"‚ö†Ô∏è Error: {e}")
          return

      # Reset state
      self.freestyle_attempts = []
      self.freestyle_correct = False
      self.freestyle_finalized = False

      if self.freestyle_answer_mf:
          self.freestyle_answer_mf.latex("")

      # Show solve area
      solve_area = document.querySelector("#freestyleSolveArea")
      if solve_area:
          solve_area.style.display = "block"

      # Display problem
      problem_display = document.querySelector("#freestyleProblemDisplay")
      if problem_display:
          # Helper function to check if expression contains a matrix anywhere
          def contains_matrix(expr):
              """Check if expression contains a matrix at any level"""
              try:
                  if isinstance(expr, (sp.Matrix, sp.MutableDenseMatrix, sp.ImmutableDenseMatrix)):
                      return True
                  if hasattr(expr, 'args'):
                      for arg in expr.args:
                          if contains_matrix(arg):
                              return True
              except Exception as e:
                  window.console.error(f"Error in contains_matrix: {e}")
              return False

          # Check if it contains matrices
          has_matrix_in_latex = '[[' in problem_latex or '\\left[\\left[' in problem_latex
          has_matrix_in_tree = contains_matrix(parsed) if parsed else False

          window.console.log(f"=== Display Problem Debug ===")
          window.console.log(f"Problem LaTeX: {problem_latex}")
          window.console.log(f"Has [[ in LaTeX: {has_matrix_in_latex}")
          window.console.log(f"Has matrix in tree: {has_matrix_in_tree}")
          window.console.log(f"Parsed type: {type(parsed)}")
          window.console.log(f"Parsed value: {parsed}")

          # Should we convert?
          should_convert = has_matrix_in_latex or has_matrix_in_tree

          if should_convert:
              try:
                  window.console.log("üîÑ Attempting conversion...")
                  display_latex = self._convert_latex_preserve_order(parsed)
                  window.console.log(f"‚úÖ Conversion successful!")
                  window.console.log(f"Result: {display_latex}")
                  problem_display.innerHTML = f"$$\\displaystyle {display_latex}$$"
              except Exception as e:
                  # Fallback to original if conversion fails
                  window.console.error(f"‚ùå Conversion failed: {e}")
                  import traceback
                  window.console.error(traceback.format_exc())
                  window.console.log("‚ö†Ô∏è Using original LaTeX as fallback")
                  problem_display.innerHTML = f"$$\\displaystyle {problem_latex}$$"
          else:
              # No matrices, use original LaTeX
              window.console.log("No matrix detected, using original LaTeX")
              problem_display.innerHTML = f"$$\\displaystyle {problem_latex}$$"

          # Render with MathJax
          if hasattr(window, 'MathJax') and hasattr(window.MathJax, 'typesetPromise'):
              window.console.log("Rendering with MathJax...")
              window.MathJax.typesetPromise([problem_display])

      # Clear feedback
      feedback_el = document.querySelector("#freestyleFeedback")
      if feedback_el:
          feedback_el.innerHTML = ""

      history_el = document.querySelector("#freestyleHistory")
      if history_el:
          history_el.innerHTML = ""

      # Update Give Up button
      difficulty = self.calculate_problem_difficulty(parsed)
      credits_needed = difficulty

      giveup_btn = document.querySelector("#freestyleGiveUp")
      if giveup_btn:
          giveup_btn.textContent = f"Give Up (üíé {credits_needed} credit{'s' if credits_needed != 1 else ''})"

          if self.credit_balance >= credits_needed:
              giveup_btn.disabled = False
              giveup_btn.style.opacity = "1"
              giveup_btn.title = f"Use {credits_needed} credit{'s' if credits_needed != 1 else ''} to reveal solution"
          else:
              giveup_btn.disabled = True
              giveup_btn.style.opacity = "0.5"
              shortage = credits_needed - self.credit_balance
              giveup_btn.title = f"Need {shortage} more credit{'s' if shortage != 1 else ''} to use this (you have {self.credit_balance})"

      submit_btn = document.querySelector("#freestyleSubmit")
      if submit_btn:
          submit_btn.disabled = False
          submit_btn.style.opacity = "1"

      finalize_btn = document.querySelector("#freestyleFinalize")
      if finalize_btn:
          finalize_btn.disabled = True
          finalize_btn.style.opacity = "0.5"

      window.alert("‚úÖ Problem set! Now solve it below.")

    def freestyle_submit(self, event):
        """Submit an attempt for the freestyle problem"""
        window.console.log("=== freestyle_submit called ===")

        if not self.freestyle_problem:
            window.alert("‚ö†Ô∏è Please set a problem first")
            return

        if not self.freestyle_answer_mf:
            window.alert("‚ö†Ô∏è Answer field not ready")
            return

        answer_latex = self.freestyle_answer_mf.latex().strip()

        if not answer_latex:
            window.alert("‚ö†Ô∏è Please enter your answer")
            return

        # Parse answer
        try:
            import sympy as sp

            parsed_answer = self.math_parser.parse_latex(answer_latex)

            if parsed_answer is None:
                window.alert("‚ö†Ô∏è Could not parse your answer")
                return

            # For row operations, we need to parse the problem LaTeX to get the expected result
            if self.freestyle_problem.get("is_row_operation"):
                window.console.log("üîß Row operation problem: parsing LaTeX to get expected result")
                expected_parsed = self.math_parser.parse_latex(self.freestyle_problem["latex"])
                if expected_parsed is None:
                    window.alert("‚ö†Ô∏è Could not parse problem")
                    return
            else:
                expected_parsed = self.freestyle_problem["parsed"]

            # Normalize both for comparison
            expected_normalized = self.math_parser.normalize_expr(expected_parsed)
            answer_normalized = self.math_parser.normalize_expr(parsed_answer)

            window.console.log(f"üîç Expected normalized: {expected_normalized}")
            window.console.log(f"üîç Expected srepr: {sp.srepr(expected_normalized)}")
            window.console.log(f"üîç Answer normalized: {answer_normalized}")
            window.console.log(f"üîç Answer srepr: {sp.srepr(answer_normalized)}")

            # Check correctness
            is_correct = self.math_parser.final_eq(answer_normalized, expected_normalized)

            # Record attempt
            attempt = {
                "latex": answer_latex,
                "correct": is_correct
            }
            self.freestyle_attempts.append(attempt)

            # Update UI
            feedback_el = document.querySelector("#freestyleFeedback")
            finalize_btn = document.querySelector("#freestyleFinalize")

            if is_correct:
                self.freestyle_correct = True
                
                if feedback_el:
                  feedback_el.innerHTML = "<div style='color:#059669;background:#d1fae5;padding:12px;border-radius:6px;'>‚úÖ Correct! Now click <strong>Check Simplest Form</strong> to verify it's simplified and earn credits.</div>"
                # Enable finalize button
                if finalize_btn:
                    finalize_btn.disabled = False
                    finalize_btn.style.opacity = "1"
                # Disable give up button (no longer needed)
                giveup_btn = document.querySelector("#freestyleGiveUp")
                if giveup_btn:
                    giveup_btn.disabled = True
                    giveup_btn.style.opacity = "0.5"
            else:
                if feedback_el:
                    feedback_el.innerHTML = f"<div style='color:#b91c1c;background:#fee2e2;padding:12px;border-radius:6px;' class='flash-incorrect'>‚ùå Incorrect (Attempt {len(self.freestyle_attempts)}). Try again!</div>"
                    
                    # Remove flashing class after animation completes
                    def remove_flash():
                        inner_div = feedback_el.querySelector("div")
                        if inner_div:
                            inner_div.classList.remove("flash-incorrect")
                    window.setTimeout(create_proxy(remove_flash), 3000)

            # Update history
            self._update_freestyle_history()

        except Exception as e:
            window.console.error(f"Submit error: {e}")
            import traceback
            window.console.error(traceback.format_exc())
            window.alert(f"‚ö†Ô∏è Error: {e}")

    def freestyle_finalize(self, event):
      """Check if answer is in simplest form"""
      window.console.log("=== freestyle_finalize called ===")

      if not self.freestyle_correct:
          window.alert("‚ö†Ô∏è Please submit a correct answer first")
          return

      if self.freestyle_finalized:
          window.alert("‚úÖ Already checked!")
          return

      # Get the last correct answer
      last_attempt = self.freestyle_attempts[-1] if self.freestyle_attempts else None

      if not last_attempt or not last_attempt.get("correct"):
          window.alert("‚ö†Ô∏è No correct answer found")
          return

      try:
          import sympy as sp

          # Parse the answer WITHOUT normalizing (to preserve user's form)
          answer_latex = last_attempt["latex"]
          answer_expr = self.math_parser.parse_latex(answer_latex)

          window.console.log(f"Answer expression: {answer_expr}")
          window.console.log(f"Answer srepr: {sp.srepr(answer_expr)}")

          # Get the expected simplest form by normalizing the original problem
          # For row operations, we need to parse the problem LaTeX to get the expected result
          if self.freestyle_problem.get("is_row_operation"):
              window.console.log("üîß Row operation problem: parsing LaTeX for simplest form check")
              expected_parsed = self.math_parser.parse_latex(self.freestyle_problem["latex"])
              if expected_parsed is None:
                  window.alert("‚ö†Ô∏è Could not parse problem for simplest form check")
                  return
              expected_simplest = self.math_parser.normalize_expr(expected_parsed)
          else:
              expected_simplest = self.math_parser.normalize_expr(self.freestyle_problem["parsed"])

          window.console.log(f"Expected simplest form: {expected_simplest}")
          window.console.log(f"Expected srepr: {sp.srepr(expected_simplest)}")

          feedback_el = document.querySelector("#freestyleFeedback")
          finalize_btn = document.querySelector("#freestyleFinalize")

          # Helper function to normalize only representation (not structure)
          def normalize_representation(expr):
              """
              Normalize only representation issues (like division to rational)
              WITHOUT changing algebraic structure (like expanding or factoring)
              """
              if isinstance(expr, (sp.Matrix, sp.MutableDenseMatrix, sp.ImmutableDenseMatrix)):
                  # For matrices, normalize each element
                  normalized_elements = []
                  for element in expr:
                      normalized_elements.append(normalize_representation(element))

                  # Reconstruct matrix with same shape
                  rows, cols = expr.shape
                  result = sp.Matrix(rows, cols, normalized_elements)
                  return sp.ImmutableMatrix(result)

              elif isinstance(expr, sp.Mul):
                  # Check if this is a division (a * b^(-1))
                  # Convert to Rational if both are integers
                  args = expr.args
                  if len(args) == 2:
                      a, b = args
                      if isinstance(a, sp.Integer) and isinstance(b, sp.Pow):
                          if isinstance(b.base, sp.Integer) and b.exp == -1:
                              # This is division: a * b^(-1) ‚Üí Rational(a, b)
                              return sp.Rational(a, b.base)

                  # Not a simple division, recurse on args
                  new_args = [normalize_representation(arg) for arg in args]
                  return sp.Mul(*new_args)

              elif isinstance(expr, sp.Add):
                  new_args = [normalize_representation(arg) for arg in expr.args]
                  return sp.Add(*new_args)

              elif isinstance(expr, sp.Pow):
                  new_base = normalize_representation(expr.base)
                  new_exp = normalize_representation(expr.exp)
                  return sp.Pow(new_base, new_exp)

              else:
                  # For other types, return as-is
                  return expr

          # Normalize representations for both (fix division notation)
          answer_normalized_repr = normalize_representation(answer_expr)
          expected_normalized_repr = normalize_representation(expected_simplest)

          window.console.log(f"Answer (repr normalized): {answer_normalized_repr}")
          window.console.log(f"Answer (repr normalized) srepr: {sp.srepr(answer_normalized_repr)}")
          window.console.log(f"Expected (repr normalized): {expected_normalized_repr}")
          window.console.log(f"Expected (repr normalized) srepr: {sp.srepr(expected_normalized_repr)}")

          # Compare structures
          answer_srepr = sp.srepr(answer_normalized_repr)
          expected_srepr = sp.srepr(expected_normalized_repr)

          is_simplest = (answer_srepr == expected_srepr)

          window.console.log(f"Structural match: {is_simplest}")
          window.console.log(f"Answer srepr: {answer_srepr}")
          window.console.log(f"Expected srepr: {expected_srepr}")

          if is_simplest:
              # Answer is in simplest form!
              window.console.log("‚úÖ Answer is in simplest form")
              self.freestyle_finalized = True

              # Award credits if not already awarded
              if 'credits_awarded' not in self.freestyle_problem or not self.freestyle_problem['credits_awarded']:
                  difficulty = self.calculate_problem_difficulty(self.freestyle_problem["parsed"])
                  self.award_credits(self.freestyle_problem["latex"], self.freestyle_problem["parsed"], difficulty)
                  self.freestyle_problem['credits_awarded'] = True

                  if feedback_el:
                      feedback_el.innerHTML = f"<div style='color:#059669;background:#d1fae5;padding:12px;border-radius:6px;'>‚úÖ <strong>Simplified!</strong> Your answer is in simplest form.<br><br>üíé <strong>+{difficulty} credit{'s' if difficulty != 1 else ''} earned!</strong></div>"
              else:
                  if feedback_el:
                      feedback_el.innerHTML = "<div style='color:#059669;background:#d1fae5;padding:12px;border-radius:6px;'>‚úÖ <strong>Simplified!</strong> Your answer is in simplest form.</div>"

              if finalize_btn:
                  finalize_btn.disabled = True
                  finalize_btn.style.opacity = "0.5"
          else:
              # Not in simplest form - show structural comparison with operation counts
              window.console.log("‚ö†Ô∏è Answer is not in simplest form")

              # Count operations for both expressions
              def count_operations(expr):
                  """Count different types of operations in an expression"""
                  counts = {
                      'Add': 0,
                      'Mul': 0,
                      'Pow': 0,
                      'Log': 0,
                      'Exp': 0,
                      'Trig': 0,
                      'Hyperbolic': 0,
                      'Derivative': 0,
                      'Integral': 0,
                      'Limit': 0,
                      'Abs': 0,
                      'Sqrt': 0,
                      'Factorial': 0,
                      'Min/Max': 0,
                      'Floor/Ceil': 0,
                      'Complex': 0,
                      'Symbols': 0,
                      'Numbers': 0,
                      'Total': 0
                  }

                  def traverse(e):
                      # Handle matrices - traverse their elements
                      if isinstance(e, (sp.Matrix, sp.MutableDenseMatrix, sp.ImmutableDenseMatrix)):
                          for element in e:
                              traverse(element)
                          return

                      # Get the class name for string matching
                      class_name = type(e).__name__

                      # Basic arithmetic
                      if isinstance(e, sp.Add):
                          counts['Add'] += 1
                          counts['Total'] += 1
                      elif isinstance(e, sp.Mul):
                          counts['Mul'] += 1
                          counts['Total'] += 1
                      elif isinstance(e, sp.Pow):
                          counts['Pow'] += 1
                          counts['Total'] += 1

                      # Logarithms and exponentials (use class name)
                      elif class_name in ['log', 'ln']:
                          counts['Log'] += 1
                          counts['Total'] += 1
                      elif class_name == 'exp':
                          counts['Exp'] += 1
                          counts['Total'] += 1

                      # Trigonometric functions (use class name)
                      elif class_name in ['sin', 'cos', 'tan', 'cot', 'sec', 'csc', 
                                         'asin', 'acos', 'atan', 'acot', 'asec', 'acsc', 'atan2']:
                          counts['Trig'] += 1
                          counts['Total'] += 1

                      # Hyperbolic functions
                      elif class_name in ['sinh', 'cosh', 'tanh', 'coth', 'sech', 'csch',
                                         'asinh', 'acosh', 'atanh', 'acoth', 'asech', 'acsch']:
                          counts['Hyperbolic'] += 1
                          counts['Total'] += 1

                      # Calculus operations
                      elif isinstance(e, sp.Derivative):
                          counts['Derivative'] += 1
                          counts['Total'] += 1
                      elif isinstance(e, sp.Integral):
                          counts['Integral'] += 1
                          counts['Total'] += 1
                      elif isinstance(e, sp.Limit):
                          counts['Limit'] += 1
                          counts['Total'] += 1

                      # Absolute value and sqrt
                      elif isinstance(e, sp.Abs):
                          counts['Abs'] += 1
                          counts['Total'] += 1
                      elif class_name == 'sqrt':
                          counts['Sqrt'] += 1
                          counts['Total'] += 1

                      # Factorial
                      elif class_name in ['factorial', 'factorial2', 'binomial', 'RisingFactorial', 'FallingFactorial']:
                          counts['Factorial'] += 1
                          counts['Total'] += 1

                      # Min/Max
                      elif class_name in ['Min', 'Max']:
                          counts['Min/Max'] += 1
                          counts['Total'] += 1

                      # Floor/Ceiling
                      elif class_name in ['floor', 'ceiling', 'frac']:
                          counts['Floor/Ceil'] += 1
                          counts['Total'] += 1

                      # Complex number functions
                      elif class_name in ['re', 'im', 'conjugate', 'arg', 'Abs']:
                          counts['Complex'] += 1
                          counts['Total'] += 1

                      # Symbols and numbers (including Rational)
                      elif isinstance(e, sp.Symbol):
                          counts['Symbols'] += 1
                      elif isinstance(e, (sp.Integer, sp.Float, sp.Rational, sp.Number)):
                          counts['Numbers'] += 1

                      if hasattr(e, 'args'):
                          for arg in e.args:
                              traverse(arg)

                  traverse(expr)
                  return counts

              # Count using the representation-normalized versions
              user_counts = count_operations(answer_normalized_repr)
              expected_counts = count_operations(expected_normalized_repr)

              if feedback_el:
                  # Build comparison table
                  comparison_html = """
                  <div style='color:#f59e0b;background:#fef3c7;padding:16px;border-radius:6px;'>
                      <div style='font-weight:700;font-size:16px;margin-bottom:12px;'>‚ö†Ô∏è Not in simplest form!</div>

                      <div style='margin-bottom:12px;font-size:14px;color:#92400e;'>
                          Your answer has a different structure than the simplest form. Compare the operation counts:
                      </div>

                      <table style='width:100%;border-collapse:collapse;margin-bottom:12px;background:white;border-radius:6px;overflow:hidden;'>
                          <thead>
                              <tr style='background:#fbbf24;color:#78350f;'>
                                  <th style='padding:10px;text-align:left;font-weight:600;border-bottom:2px solid #f59e0b;'>Operation Type</th>
                                  <th style='padding:10px;text-align:center;font-weight:600;border-bottom:2px solid #f59e0b;'>Your Answer</th>
                                  <th style='padding:10px;text-align:center;font-weight:600;border-bottom:2px solid #f59e0b;'>Expected</th>
                              </tr>
                          </thead>
                          <tbody>
                  """

                  # Add rows for each operation type
                  operations = [
                      ('Additions (+)', 'Add'),
                      ('Multiplications (√ó)', 'Mul'),
                      ('Powers (^)', 'Pow'),
                      ('Square Roots (‚àö)', 'Sqrt'),
                      ('Logarithms (log, ln)', 'Log'),
                      ('Exponentials (e^x)', 'Exp'),
                      ('Trigonometric (sin, cos, tan, etc.)', 'Trig'),
                      ('Hyperbolic (sinh, cosh, etc.)', 'Hyperbolic'),
                      ('Derivatives (d/dx)', 'Derivative'),
                      ('Integrals (‚à´)', 'Integral'),
                      ('Limits (lim)', 'Limit'),
                      ('Absolute Values (|x|)', 'Abs'),
                      ('Factorials (n!)', 'Factorial'),
                      ('Min/Max', 'Min/Max'),
                      ('Floor/Ceiling', 'Floor/Ceil'),
                      ('Complex (re, im, conjugate)', 'Complex'),
                      ('Symbols (x, y, etc.)', 'Symbols'),
                      ('Numbers', 'Numbers'),
                      ('Total Operations', 'Total')
                  ]

                  for label, key in operations:
                      user_val = user_counts[key]
                      expected_val = expected_counts[key]

                      # Skip rows where both are 0 (except Total and basic operations)
                      if user_val == 0 and expected_val == 0 and key not in ['Total', 'Symbols', 'Numbers']:
                          continue

                      # Highlight differences
                      if user_val != expected_val:
                          row_style = 'background:#fef3c7;font-weight:600;'
                          user_cell_style = 'color:#dc2626;'
                          expected_cell_style = 'color:#059669;'
                      else:
                          row_style = 'background:white;'
                          user_cell_style = ''
                          expected_cell_style = ''

                      if key == 'Total':
                          row_style += 'border-top:2px solid #f59e0b;font-weight:700;'

                      comparison_html += f"""
                          <tr style='{row_style}'>
                              <td style='padding:10px;border-bottom:1px solid #fde68a;'>{label}</td>
                              <td style='padding:10px;text-align:center;border-bottom:1px solid #fde68a;{user_cell_style}'>{user_val}</td>
                              <td style='padding:10px;text-align:center;border-bottom:1px solid #fde68a;{expected_cell_style}'>{expected_val}</td>
                          </tr>
                      """

                  comparison_html += """
                          </tbody>
                      </table>

                      <div style='font-size:13px;color:#78350f;background:#fffbeb;padding:10px;border-radius:4px;border-left:3px solid #f59e0b;'>
                          üí° <strong>Tip:</strong> The simplest form has fewer operations. Look for common factors to factor out, or terms to combine.
                      </div>
                  </div>
                  """

                  feedback_el.innerHTML = comparison_html

      except Exception as e:
          window.console.error(f"Finalize error: {e}")
          import traceback
          window.console.error(traceback.format_exc())
          window.alert(f"‚ö†Ô∏è Error: {e}")

    def freestyle_giveup(self, event):
        """Show the solution when user gives up"""
        window.console.log("=== freestyle_giveup called ===")

        if not self.freestyle_problem:
            window.alert("‚ö†Ô∏è Please set a problem first")
            return

        if self.freestyle_correct:
            window.alert("‚úÖ You already solved this problem!")
            return

        # Check if user has enough credits
        difficulty = self.calculate_problem_difficulty(self.freestyle_problem["parsed"])
        credits_needed = difficulty
        
        if self.credit_balance < credits_needed:
            shortage = credits_needed - self.credit_balance
            window.alert(f"‚ö†Ô∏è Not enough credits!\n\nYou need {credits_needed} credit{'s' if credits_needed != 1 else ''} to reveal this solution (Difficulty: {difficulty})\n\nYou have: {self.credit_balance} credit{'s' if self.credit_balance != 1 else ''}\nYou need: {shortage} more credit{'s' if shortage != 1 else ''}\n\nüí° Solve more problems of similar difficulty to earn credits!")
            return

        # Confirm spending credits
        if not window.confirm(f"üíé Use {credits_needed} credit{'s' if credits_needed != 1 else ''} to reveal the solution?\n\n(Difficulty: {difficulty})\nYour balance: {self.credit_balance} ‚Üí {self.credit_balance - credits_needed}"):
            return

        try:
            import sympy as sp

            # Spend the credits
            if not self.spend_credits(credits_needed, self.freestyle_problem["latex"]):
                window.alert("‚ö†Ô∏è Unable to spend credits")
                return

            # Get the solution by normalizing the problem
            solution_expr = self.math_parser.normalize_expr(self.freestyle_problem["parsed"])
            solution_latex = sp.latex(solution_expr)

            window.console.log(f"Solution: {solution_expr}")
            window.console.log(f"Solution LaTeX: {solution_latex}")

            # Display the solution
            feedback_el = document.querySelector("#freestyleFeedback")
            if feedback_el:
                feedback_el.innerHTML = f"""
                <div style='color:#6366f1;background:#e0e7ff;padding:16px;border-radius:8px;border-left:4px solid #6366f1;'>
                    <div style='font-weight:700;font-size:16px;margin-bottom:12px;'>üí° Solution:</div>
                    <div style='font-size:20px;margin-bottom:8px;'>$$\\displaystyle {solution_latex}$$</div>
                    <div style='font-size:14px;color:#4338ca;margin-top:8px;'>You can study this solution and try a similar problem next time!</div>
                </div>
                """

                # Re-render MathJax
                if hasattr(window, 'MathJax') and hasattr(window.MathJax, 'typesetPromise'):
                    window.MathJax.typesetPromise([feedback_el])

            # Disable submit and give-up buttons
            submit_btn = document.querySelector("#freestyleSubmit")
            if submit_btn:
                submit_btn.disabled = True
                submit_btn.style.opacity = "0.5"

            giveup_btn = document.querySelector("#freestyleGiveUp")
            if giveup_btn:
                giveup_btn.disabled = True
                giveup_btn.style.opacity = "0.5"

            # Mark as finalized (can't submit anymore)
            self.freestyle_finalized = True

        except Exception as e:
            window.console.error(f"Give up error: {e}")
            import traceback
            window.console.error(traceback.format_exc())
            window.alert(f"‚ö†Ô∏è Error showing solution: {e}")

    def freestyle_reset(self, event):
        """Reset the freestyle problem"""
        window.console.log("=== freestyle_reset called ===")

        self.freestyle_problem = None
        self.freestyle_attempts = []
        self.freestyle_correct = False
        self.freestyle_finalized = False

        # Clear fields
        if self.freestyle_problem_mf:
            self.freestyle_problem_mf.latex("")

        if self.freestyle_answer_mf:
            self.freestyle_answer_mf.latex("")

        # Hide solve area
        solve_area = document.querySelector("#freestyleSolveArea")
        if solve_area:
            solve_area.style.display = "none"

        # Clear feedback
        feedback_el = document.querySelector("#freestyleFeedback")
        if feedback_el:
            feedback_el.innerHTML = ""

        history_el = document.querySelector("#freestyleHistory")
        if history_el:
            history_el.innerHTML = ""

        # Re-enable submit and give-up buttons
        submit_btn = document.querySelector("#freestyleSubmit")
        if submit_btn:
            submit_btn.disabled = False
            submit_btn.style.opacity = "1"

        giveup_btn = document.querySelector("#freestyleGiveUp")
        if giveup_btn:
            giveup_btn.textContent = "Give Up (Show Solution)"
            giveup_btn.disabled = False
            giveup_btn.style.opacity = "1"
            giveup_btn.title = ""

        window.alert("‚úÖ Problem reset. Enter a new problem!")

    # ============================================
    # STRUCTURE CONVERTER FOR MOODLE
    # ============================================

    def _structure_to_string(self, structure):
        """
        Convert structure dict to a standardized string representation.
        Format: ops:{Add:2,Mul:1}|operands:{x:1,2:1,3:1}|total_ops:3|total_operands:3
        """
        import json

        # Sort dictionaries for consistent output
        ops_str = json.dumps(structure.get("operators", {}), sort_keys=True, separators=(',', ':'))
        operands_str = json.dumps(structure.get("operands", {}), sort_keys=True, separators=(',', ':'))
        matrix_ops_str = json.dumps(structure.get("matrix_ops", []), sort_keys=True, separators=(',', ':'))

        parts = [
            f"ops:{ops_str}",
            f"operands:{operands_str}",
            f"total_ops:{structure.get('total_ops', 0)}",
            f"total_operands:{structure.get('total_operands', 0)}"
        ]

        # Add matrix operations if present
        if structure.get("matrix_ops"):
            parts.append(f"matrix_ops:{matrix_ops_str}")

        return "|".join(parts)

    def get_structure_for_moodle(self, latex_expr):
        """
        Convert LaTeX expression to structure string for Moodle.
        Returns dict with both simplified and expected structures.
        """
        if not latex_expr or not latex_expr.strip():
            return {
                "error": "Empty expression",
                "success": False
            }

        try:
            import sympy as sp

            # Remove $$ markers if present
            clean_expr = latex_expr
            if clean_expr.startswith('$$') and clean_expr.endswith('$$'):
                clean_expr = clean_expr[2:-2].strip()

            # Check if this is a matrix expression
            is_matrix = '[[' in clean_expr or '|R_' in clean_expr or '\\' in clean_expr

            # Parse expression
            if is_matrix:
                window.console.log(f"Detected matrix expression: {clean_expr}")
                parsed = self.math_parser.parse_latex(clean_expr)
            else:
                # Try simple parsing first
                try:
                    from sympy.parsing.sympy_parser import parse_expr
                    sympy_text = clean_expr.replace('^', '**')
                    parsed = parse_expr(sympy_text, local_dict={'sp': sp})
                except:
                    # Fallback to parse_latex
                    parsed = self.math_parser.parse_latex(clean_expr)

            if parsed is None:
                return {
                    "error": "Failed to parse expression",
                    "success": False
                }

            # Get expected structure (as-is)
            expected_structure = self.math_parser.extract_structure(parsed)
            expected_str = self._structure_to_string(expected_structure)

            # Get simplified structure
            try:
                simplified = sp.simplify(parsed)
                simplified_structure = self.math_parser.extract_structure(simplified)
                simplified_str = self._structure_to_string(simplified_structure)
            except:
                # If simplification fails, use expected
                simplified_str = expected_str

            # Check if structures are the same
            same_structure = expected_str == simplified_str

            return {
                "success": True,
                "expected": expected_str,          # 100% credit
                "simplified": simplified_str,      # 50% credit
                "same": same_structure,
                "expected_structure": expected_structure,
                "simplified_structure": simplified_structure if not same_structure else expected_structure
            }

        except Exception as e:
            window.console.error(f"Error in get_structure_for_moodle: {e}")
            import traceback
            window.console.error(traceback.format_exc())
            return {
                "error": str(e),
                "success": False
            }

    def show_structure_modal(self, event):
        """Show modal with structure strings for Moodle submission"""
        window.console.log("=== show_structure_modal called ===")

        # Get current answer from MathQuill field
        if not self.freestyle_answer_mf:
            window.alert("‚ö†Ô∏è Please enter an answer first")
            return

        latex_expr = self.freestyle_answer_mf.latex()
        if not latex_expr or not latex_expr.strip():
            window.alert("‚ö†Ô∏è Please enter an answer first")
            return

        # Generate structures
        result = self.get_structure_for_moodle(latex_expr)

        if not result.get("success"):
            error_msg = result.get("error", "Unknown error")
            window.alert(f"‚ùå Error: {error_msg}")
            return

        # Create modal using JavaScript DOM manipulation
        # Properly serialize result to JSON for JavaScript
        import json
        js_code_replacement = json.dumps(result)

        js_code = """
        (function() {
            // Get data from Python
            const data = %s;

            const expected_str = data.expected;
            const simplified_str = data.simplified;
            const same = data.same;
            const expected_struct = data.expected_structure;

            // Remove old modal if exists
            const oldModal = document.querySelector('#structureModalContainer');
            if (oldModal) oldModal.remove();

            // Create modal container
            const container = document.createElement('div');
            container.id = 'structureModalContainer';

            // Create backdrop
            const backdrop = document.createElement('div');
            backdrop.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.5);
                z-index: 9999;
            `;

            // Create modal
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 50%%;
                left: 50%%;
                transform: translate(-50%%, -50%%);
                background: white;
                border: 2px solid #3b82f6;
                border-radius: 12px;
                padding: 24px;
                max-width: 90%%;
                max-height: 90vh;
                overflow-y: auto;
                z-index: 10000;
                box-shadow: 0 12px 40px rgba(0,0,0,0.3);
            `;

            // Build modal HTML
            let html = `
                <button id="closeStructureModal" style="position:absolute;top:12px;right:12px;background:#ef4444;color:white;border:none;border-radius:6px;width:32px;height:32px;font-size:18px;cursor:pointer;font-weight:bold;">‚úñ</button>

                <h2 style="margin:0 0 16px 0;color:#1e40af;font-size:20px;">üìã Structure String for Moodle</h2>

                <div style="background:#f0f9ff;padding:16px;border-radius:8px;margin-bottom:16px;border:2px solid #93c5fd;">
                    <div style="font-weight:600;margin-bottom:8px;color:#1e40af;">üí° Instructions</div>
                    <div style="font-size:14px;color:#1e3a8a;">Copy the structure string below and paste it into your Moodle fill-in-the-blank answer field.</div>
                </div>
            `;

            if (!same) {
                html += `
                    <div style="background:#fef3c7;padding:12px;border-radius:8px;margin-bottom:16px;border:2px solid #fbbf24;">
                        <div style="font-weight:600;margin-bottom:4px;color:#92400e;">‚ö†Ô∏è Note: Two Structure Formats Available</div>
                        <div style="font-size:13px;color:#92400e;">Your expression has different simplified and expected structures. Use expected for 100%% credit.</div>
                    </div>
                `;
            }

            html += `
                <div style="margin-bottom:20px;">
                    <div style="font-weight:600;margin-bottom:8px;color:#059669;display:flex;align-items:center;gap:8px;">
                        <span>‚úì Expected Structure (100%% Credit)</span>
                    </div>
                    <div style="background:#f9fafb;padding:12px;border-radius:6px;border:1px solid #d1d5db;font-family:monospace;font-size:12px;word-break:break-all;margin-bottom:8px;" id="expectedStructureText">${expected_str}</div>
                    <button id="copyExpected" style="background:#10b981;color:white;border:none;padding:8px 16px;border-radius:6px;cursor:pointer;font-weight:600;font-size:14px;">üìã Copy to Clipboard</button>
                </div>
            `;

            if (!same) {
                html += `
                    <div style="margin-bottom:20px;">
                        <div style="font-weight:600;margin-bottom:8px;color:#f59e0b;display:flex;align-items:center;gap:8px;">
                            <span>‚ö° Simplified Structure (50%% Credit)</span>
                        </div>
                        <div style="background:#f9fafb;padding:12px;border-radius:6px;border:1px solid #d1d5db;font-family:monospace;font-size:12px;word-break:break-all;margin-bottom:8px;" id="simplifiedStructureText">${simplified_str}</div>
                        <button id="copySimplified" style="background:#f59e0b;color:white;border:none;padding:8px 16px;border-radius:6px;cursor:pointer;font-weight:600;font-size:14px;">üìã Copy to Clipboard</button>
                    </div>
                `;
            }

            const ops = Object.entries(expected_struct.operators || {}).map(([k,v]) => `${k} (${v})`).join(', ') || 'None';
            const operands = Object.entries(expected_struct.operands || {}).map(([k,v]) => `${k} (${v})`).join(', ') || 'None';
            const has_matrix = expected_struct.matrix_ops && expected_struct.matrix_ops.length > 0;

            html += `
                <div style="background:#f3f4f6;padding:12px;border-radius:6px;">
                    <div style="font-weight:600;margin-bottom:8px;color:#374151;font-size:14px;">üìä Structure Breakdown (Expected)</div>
                    <div style="font-size:13px;color:#6b7280;font-family:monospace;">
                        <div>‚Ä¢ Operators: ${ops}</div>
                        <div>‚Ä¢ Operands: ${operands}</div>
                        <div>‚Ä¢ Total Operations: ${expected_struct.total_ops || 0}</div>
                        <div>‚Ä¢ Total Operands: ${expected_struct.total_operands || 0}</div>
                        ${has_matrix ? `<div>‚Ä¢ Matrix Operations: ${expected_struct.matrix_ops.length}</div>` : ''}
                    </div>
                </div>
            `;

            modal.innerHTML = html;

            container.appendChild(backdrop);
            container.appendChild(modal);
            document.body.appendChild(container);

            // Close handlers
            function closeModal() {
                container.remove();
            }

            document.getElementById('closeStructureModal').addEventListener('click', closeModal);
            backdrop.addEventListener('click', closeModal);

            // Copy handlers
            function copyToClipboard(text, buttonId) {
                try {
                    if (navigator.clipboard && navigator.clipboard.writeText) {
                        navigator.clipboard.writeText(text).then(() => {
                            showCopySuccess(buttonId);
                        }).catch(() => {
                            fallbackCopy(text, buttonId);
                        });
                    } else {
                        fallbackCopy(text, buttonId);
                    }
                } catch(err) {
                    alert('‚ùå Copy failed. Please select and copy manually.');
                }
            }

            function fallbackCopy(text, buttonId) {
                const textarea = document.createElement('textarea');
                textarea.value = text;
                textarea.style.position = 'fixed';
                textarea.style.opacity = '0';
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                showCopySuccess(buttonId);
            }

            function showCopySuccess(buttonId) {
                const btn = document.getElementById(buttonId);
                if (btn) {
                    const originalText = btn.textContent;
                    const originalBg = btn.style.background;
                    btn.textContent = '‚úì Copied!';
                    btn.style.background = '#059669';
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.style.background = originalBg;
                    }, 2000);
                }
            }

            document.getElementById('copyExpected').addEventListener('click', () => {
                copyToClipboard(expected_str, 'copyExpected');
            });

            if (!same) {
                document.getElementById('copySimplified').addEventListener('click', () => {
                    copyToClipboard(simplified_str, 'copySimplified');
                });
            }
        })();
        """ % js_code_replacement

        # Execute JavaScript
        window.eval(js_code)


    def _update_freestyle_history(self):
      """Update the attempt history display"""
      history_el = document.querySelector("#freestyleHistory")
      if not history_el:
          return

      if not self.freestyle_attempts:
          history_el.innerHTML = ""
          return

      html = "<div style='background:#f8fafc;padding:12px;border-radius:8px;'>"
      html += "<div style='font-weight:700;margin-bottom:8px;'>Attempt History:</div>"

      for idx, attempt in enumerate(self.freestyle_attempts):
          status = "‚úÖ" if attempt["correct"] else "‚ùå"
          color = "#059669" if attempt["correct"] else "#b91c1c"
          bg = "#d1fae5" if attempt["correct"] else "#fee2e2"

          attempt_latex = attempt['latex']

          # Check if this is a row operation (has pipe operators)
          is_row_op = (
              '|R_' in attempt_latex or 
              '|\\mathrm{R}_' in attempt_latex or
              '\\left|R_' in attempt_latex or
              '\\left|\\mathrm{R}_' in attempt_latex or
              '\\right|' in attempt_latex
          )

          # Check if contains matrices (multiple patterns)
          has_matrix = (
              '[[' in attempt_latex or 
              '\\left[\\left[' in attempt_latex or 
              '\\begin{matrix}' in attempt_latex or
              '\\begin{bmatrix}' in attempt_latex or
              '\\begin{pmatrix}' in attempt_latex
          )

          # Handle row operations specially: convert matrix part, keep operation part
          if is_row_op and has_matrix:
              try:
                  import sympy as sp
                  import re

                  # Split at the pipe: matrix part | operation part
                  match = re.match(r'(.+?)(\\left\|.*?\\right\|)', attempt_latex)

                  if match:
                      matrix_part = match.group(1)
                      operation_part = match.group(2)

                      window.console.log(f"Attempt {idx + 1} - Split row operation:")
                      window.console.log(f"  Matrix part: {matrix_part}")
                      window.console.log(f"  Operation part: {operation_part}")

                      # Convert only the matrix part
                      parsed_matrix = self.math_parser.parse_latex(matrix_part)
                      converted_matrix = self._convert_latex_preserve_order(parsed_matrix)

                      # Combine: converted matrix + original operation
                      display_latex = converted_matrix + operation_part

                      window.console.log(f"  ‚úÖ Combined: {display_latex}")
                  else:
                      # Fallback if regex doesn't match
                      window.console.log(f"Attempt {idx + 1} - Regex didn't match, using original")
                      display_latex = attempt_latex

              except Exception as e:
                  window.console.error(f"Row operation conversion error in attempt {idx + 1}: {e}")
                  import traceback
                  window.console.error(traceback.format_exc())
                  display_latex = attempt_latex

          # Regular matrices (not row operations)
          elif has_matrix and not is_row_op:
              try:
                  import sympy as sp

                  window.console.log(f"üìù Converting attempt {idx + 1}: {attempt_latex}")

                  # Parse the expression
                  parsed = self.math_parser.parse_latex(attempt_latex)

                  # Convert using part-by-part strategy
                  display_latex = self._convert_latex_preserve_order(parsed)

                  window.console.log(f"   ‚úÖ Converted to: {display_latex}")

              except Exception as e:
                  # If conversion fails, use original LaTeX
                  window.console.error(f"‚ùå LaTeX conversion error in attempt {idx + 1}: {e}")
                  import traceback
                  window.console.error(traceback.format_exc())
                  display_latex = attempt_latex
          else:
              # No matrices, use original LaTeX
              display_latex = attempt_latex
              window.console.log(f"Attempt {idx + 1} - No conversion needed")

          html += f"""
          <div style='background:{bg};color:{color};padding:8px;border-radius:4px;margin-bottom:6px;'>
              <strong>{status} Attempt {idx + 1}:</strong> 
              <div style='overflow-x:auto;'>$$\\displaystyle {display_latex}$$</div>
          </div>
          """

      html += "</div>"
      history_el.innerHTML = html

      # Render MathJax
      if hasattr(window, 'MathJax') and hasattr(window.MathJax, 'typesetPromise'):
          window.MathJax.typesetPromise([history_el])

    def _convert_latex_preserve_order(self, expr):
        """Convert SymPy expression to LaTeX, preserving order and converting matrices properly"""
        import sympy as sp

        # Helper function to normalize matrix elements
        def normalize_element(elem):
            """Normalize element to canonical form (e.g., 1*(1/2) -> 1/2)"""
            if isinstance(elem, sp.Mul):
                # Check if this is just 1 * fraction
                args = elem.args
                if len(args) == 2:
                    if args[0] == 1 and isinstance(args[1], sp.Pow):
                        # This is 1 * (something^-1), simplify to Rational
                        if isinstance(args[1].base, sp.Integer) and args[1].exp == -1:
                            return sp.Rational(1, args[1].base)
                    elif isinstance(args[0], sp.Integer) and isinstance(args[1], sp.Pow):
                        # This is n * (m^-1), simplify to Rational
                        if isinstance(args[1].base, sp.Integer) and args[1].exp == -1:
                            return sp.Rational(args[0], args[1].base)
            # Try general simplification
            try:
                simplified = sp.simplify(elem)
                # If it's a rational, return it
                if isinstance(simplified, sp.Rational):
                    return simplified
                # Otherwise return original
                return elem
            except:
                return elem

        # Matrix: normalize elements first, then convert to proper LaTeX format
        if isinstance(expr, (sp.Matrix, sp.MutableDenseMatrix, sp.ImmutableDenseMatrix)):
            # Normalize all matrix elements before converting to LaTeX
            normalized_matrix = expr.applyfunc(normalize_element)
            return sp.latex(normalized_matrix)

        # Simple types: direct conversion
        elif isinstance(expr, sp.Symbol):
            return str(expr)

        elif isinstance(expr, (sp.Integer, sp.Rational)):
            return sp.latex(expr)

        elif isinstance(expr, sp.Float):
            return sp.latex(expr)

        # Addition: preserve order of terms
        elif isinstance(expr, sp.Add):
            parts = []
            for i, arg in enumerate(expr.args):
                arg_latex = self._convert_latex_preserve_order(arg)

                # Check if this term is negative
                if isinstance(arg, sp.Mul) and len(arg.args) > 0:
                    if isinstance(arg.args[0], sp.Integer) and arg.args[0] < 0:
                        # Negative term
                        parts.append(arg_latex)
                        continue

                # Add + for non-first positive terms
                if i > 0 and not arg_latex.startswith("-"):
                    parts.append("+" + arg_latex)
                else:
                    parts.append(arg_latex)

            return " ".join(parts)

        # Multiplication: preserve order of factors
        elif isinstance(expr, sp.Mul):
            parts = []
            for arg in expr.args:
                arg_latex = self._convert_latex_preserve_order(arg)

                # Add parentheses if needed
                if isinstance(arg, sp.Add):
                    arg_latex = f"\\left({arg_latex}\\right)"

                parts.append(arg_latex)

            # Use \cdot for multiplication
            return " \\cdot ".join(parts)

        # Power: base^exponent
        elif isinstance(expr, sp.Pow):
            base = self._convert_latex_preserve_order(expr.base)
            exp = self._convert_latex_preserve_order(expr.exp)

            # Add parentheses to base if needed
            if isinstance(expr.base, (sp.Add, sp.Mul)):
                base = f"\\left({base}\\right)"

            # Handle special cases
            if expr.exp == sp.Rational(1, 2):
                return f"\\sqrt{{{base}}}"
            elif isinstance(expr.exp, sp.Rational) and expr.exp.p == 1:
                return f"\\sqrt[{expr.exp.q}]{{{base}}}"
            else:
                return f"{{{base}}}^{{{exp}}}"

        # Derivative
        elif isinstance(expr, sp.Derivative):
            func_latex = self._convert_latex_preserve_order(expr.expr)
            var_latex = self._convert_latex_preserve_order(expr.variables[0])
            return f"\\frac{{d}}{{d{var_latex}}}\\left({func_latex}\\right)"

        # Integral
        elif isinstance(expr, sp.Integral):
            func_latex = self._convert_latex_preserve_order(expr.function)
            var_latex = self._convert_latex_preserve_order(expr.variables[0])
            return f"\\int {func_latex} \\, d{var_latex}"

        # Limit
        elif isinstance(expr, sp.Limit):
            func_latex = self._convert_latex_preserve_order(expr.args[0])
            var_latex = self._convert_latex_preserve_order(expr.args[1])
            point_latex = self._convert_latex_preserve_order(expr.args[2])
            return f"\\lim_{{{var_latex} \\to {point_latex}}} {func_latex}"

        # Trigonometric and other functions
        elif isinstance(expr, sp.Function):
            func_name = type(expr).__name__
            args_latex = ", ".join([self._convert_latex_preserve_order(arg) for arg in expr.args])

            # Map function names to LaTeX
            func_map = {
                'sin': '\\sin', 'cos': '\\cos', 'tan': '\\tan',
                'cot': '\\cot', 'sec': '\\sec', 'csc': '\\csc',
                'asin': '\\arcsin', 'acos': '\\arccos', 'atan': '\\arctan',
                'sinh': '\\sinh', 'cosh': '\\cosh', 'tanh': '\\tanh',
                'log': '\\log', 'ln': '\\ln', 'exp': '\\exp',
                'sqrt': '\\sqrt'
            }

            latex_func = func_map.get(func_name, func_name)

            if func_name == 'sqrt':
                return f"\\sqrt{{{args_latex}}}"
            else:
                return f"{latex_func}\\left({args_latex}\\right)"

        # Absolute value
        elif isinstance(expr, sp.Abs):
            arg_latex = self._convert_latex_preserve_order(expr.args[0])
            return f"\\left|{arg_latex}\\right|"

        # Factorial
        elif hasattr(expr, 'is_factorial') or type(expr).__name__ == 'factorial':
            arg_latex = self._convert_latex_preserve_order(expr.args[0])
            return f"{arg_latex}!"

        # Default: use SymPy's latex (fallback)
        else:
            return sp.latex(expr)


    # ========================================
    # CREDIT SYSTEM METHODS
    # ========================================
    
    def load_credit_data(self):
        """Load credit data from localStorage"""
        try:
            storage = window.localStorage
            credit_data_str = storage.getItem("freestyle_credit_data")
            
            if credit_data_str:
                credit_data = json.loads(credit_data_str)
                self.credit_balance = credit_data.get("balance", 0)
                self.credit_earned_total = credit_data.get("earned_total", 0)
                self.credit_spent_total = credit_data.get("spent_total", 0)
                self.credit_history = credit_data.get("history", [])
                self.freestyle_solved_problems = credit_data.get("solved_problems", [])
                
                window.console.log(f"‚úÖ Loaded credit data: {self.credit_balance} credits")
            else:
                window.console.log("‚ÑπÔ∏è No credit data found, starting fresh")
                
            self.update_credit_display()
            
        except Exception as e:
            window.console.error(f"Error loading credit data: {e}")

    def save_credit_data(self):
        """Save credit data to localStorage"""
        try:
            storage = window.localStorage
            credit_data = {
                "balance": self.credit_balance,
                "earned_total": self.credit_earned_total,
                "spent_total": self.credit_spent_total,
                "history": self.credit_history,
                "solved_problems": self.freestyle_solved_problems
            }
            storage.setItem("freestyle_credit_data", json.dumps(credit_data))
            window.console.log(f"‚úÖ Saved credit data: {self.credit_balance} credits")
        except Exception as e:
            window.console.error(f"Error saving credit data: {e}")

    def calculate_problem_difficulty(self, parsed_expr):
        """Calculate problem difficulty (1-5) based on expression complexity"""
        import sympy as sp

        try:
            difficulty = 1  # Base difficulty

            # Count all operation types
            def count_operations(expr):
                """Count different types of operations"""
                counts = {
                    'Add': 0, 'Mul': 0, 'Pow': 0, 'Sqrt': 0,
                    'Log': 0, 'Exp': 0, 'Trig': 0, 'Hyperbolic': 0,
                    'Derivative': 0, 'Integral': 0, 'Limit': 0,
                    'Abs': 0, 'Factorial': 0, 'Complex': 0,
                    'Total': 0
                }

                def traverse(e):
                    class_name = type(e).__name__

                    if isinstance(e, sp.Add):
                        counts['Add'] += 1
                        counts['Total'] += 1
                    elif isinstance(e, sp.Mul):
                        counts['Mul'] += 1
                        counts['Total'] += 1
                    elif isinstance(e, sp.Pow):
                        counts['Pow'] += 1
                        counts['Total'] += 1
                    elif class_name == 'sqrt':
                        counts['Sqrt'] += 1
                        counts['Total'] += 1
                    elif class_name in ['log', 'ln']:
                        counts['Log'] += 1
                        counts['Total'] += 1
                    elif class_name == 'exp':
                        counts['Exp'] += 1
                        counts['Total'] += 1
                    elif class_name in ['sin', 'cos', 'tan', 'cot', 'sec', 'csc', 
                                       'asin', 'acos', 'atan', 'acot', 'asec', 'acsc', 'atan2']:
                        counts['Trig'] += 1
                        counts['Total'] += 1
                    elif class_name in ['sinh', 'cosh', 'tanh', 'coth', 'sech', 'csch',
                                       'asinh', 'acosh', 'atanh', 'acoth', 'asech', 'acsch']:
                        counts['Hyperbolic'] += 1
                        counts['Total'] += 1
                    elif isinstance(e, sp.Derivative):
                        counts['Derivative'] += 1
                        counts['Total'] += 1
                    elif isinstance(e, sp.Integral):
                        counts['Integral'] += 1
                        counts['Total'] += 1
                    elif isinstance(e, sp.Limit):
                        counts['Limit'] += 1
                        counts['Total'] += 1
                    elif isinstance(e, sp.Abs):
                        counts['Abs'] += 1
                        counts['Total'] += 1
                    elif class_name in ['factorial', 'factorial2', 'binomial']:
                        counts['Factorial'] += 1
                        counts['Total'] += 1
                    elif class_name in ['re', 'im', 'conjugate', 'arg']:
                        counts['Complex'] += 1
                        counts['Total'] += 1

                    if hasattr(e, 'args'):
                        for arg in e.args:
                            traverse(arg)

                traverse(expr)
                return counts

            ops = count_operations(parsed_expr)

            # Calculus operations - highest difficulty boost
            if ops['Limit'] > 0:
                difficulty += 4  # Limits are very difficult
            elif ops['Integral'] > 0:
                difficulty += 3  # Integrals are difficult
            elif ops['Derivative'] > 0:
                difficulty += 2  # Derivatives are moderately difficult

            # Advanced functions - significant difficulty
            if ops['Hyperbolic'] > 0:
                difficulty += 2  # Hyperbolic functions are advanced
            if ops['Complex'] > 0:
                difficulty += 2  # Complex operations are advanced

            # Standard functions - moderate difficulty
            if ops['Trig'] > 0:
                difficulty += 1  # Trigonometric functions
            if ops['Log'] > 0:
                difficulty += 1  # Logarithms
            if ops['Exp'] > 0:
                difficulty += 1  # Exponentials

            # Special operations
            if ops['Factorial'] > 0:
                difficulty += 1  # Factorials
            if ops['Abs'] > 0:
                difficulty += 1  # Absolute values

            # Powers and roots
            if ops['Pow'] > 2:  # More than 2 powers
                difficulty += 1
            if ops['Sqrt'] > 0:
                difficulty += 1

            # Total operation count matters
            total_ops = ops['Total']
            if total_ops > 10:
                difficulty += 2
            elif total_ops > 6:
                difficulty += 1
            elif total_ops > 3:
                difficulty += 1

            # Expression depth/nesting
            depth = self._expr_depth(parsed_expr)
            if depth > 6:
                difficulty += 2
            elif depth > 4:
                difficulty += 1
            elif depth > 2:
                difficulty += 1

            # Cap at 5
            difficulty = min(difficulty, 5)
            # Ensure minimum of 1
            difficulty = max(difficulty, 1)

            window.console.log(f"Difficulty calculation: {difficulty} (Total ops: {total_ops}, Depth: {depth})")
            window.console.log(f"Operation breakdown: Limit={ops['Limit']}, Integral={ops['Integral']}, Derivative={ops['Derivative']}, Trig={ops['Trig']}, Log={ops['Log']}, Exp={ops['Exp']}")

            return difficulty

        except Exception as e:
            window.console.error(f"Error calculating difficulty: {e}")
            return 2  # Default to medium difficulty

    def _expr_depth(self, expr):
        """Calculate the nesting depth of an expression"""
        import sympy as sp
        
        if not hasattr(expr, 'args') or not expr.args:
            return 1
        
        return 1 + max(self._expr_depth(arg) for arg in expr.args)

    def get_problem_canonical_form(self, parsed_expr):
        """Get a canonical string representation of a problem for duplicate detection"""
        import sympy as sp
        
        try:
            # Normalize and simplify the expression
            normalized = self.math_parser.normalize_expr(parsed_expr)
            simplified = sp.simplify(normalized)
            
            # Convert to a canonical string representation
            # Use srepr for structural representation
            canonical = sp.srepr(simplified)
            
            window.console.log(f"Canonical form: {canonical}")
            return canonical
            
        except Exception as e:
            window.console.error(f"Error getting canonical form: {e}")
            # Fallback to string representation
            return str(parsed_expr)

    def is_problem_solved_before(self, parsed_expr):
        """Check if this problem has been solved before"""
        try:
            canonical = self.get_problem_canonical_form(parsed_expr)
            
            # Check against all solved problems
            for solved in self.freestyle_solved_problems:
                if solved.get("canonical_form") == canonical:
                    window.console.log(f"‚ö†Ô∏è Problem already solved before")
                    return True
            
            window.console.log(f"‚úÖ New problem, not solved before")
            return False
            
        except Exception as e:
            window.console.error(f"Error checking if problem solved: {e}")
            # If we can't check, assume it's new
            return False

    def award_credits(self, problem_latex, parsed_expr, difficulty):
        """Award credits for solving a problem"""
        # Award credits equal to difficulty
        credits_earned = difficulty
        
        self.credit_balance += credits_earned
        self.credit_earned_total += credits_earned
        
        # Record transaction
        import datetime
        timestamp = datetime.datetime.now().isoformat()
        
        self.credit_history.append({
            "type": "earned",
            "amount": credits_earned,
            "difficulty": difficulty,
            "problem": problem_latex,
            "timestamp": timestamp
        })
        
        # Record solved problem
        canonical_form = self.get_problem_canonical_form(parsed_expr)
        self.freestyle_solved_problems.append({
            "problem": problem_latex,
            "canonical_form": canonical_form,
            "difficulty": difficulty,
            "credits_earned": credits_earned,
            "timestamp": timestamp
        })
        
        # Save and update display
        self.save_credit_data()
        self.update_credit_display()
        
        # Show notification
        self._show_credit_notification(f"+{credits_earned} credit{'s' if credits_earned != 1 else ''}", "#10b981")
        
        window.console.log(f"‚úÖ Awarded {credits_earned} credits for difficulty {difficulty} problem")

    def spend_credits(self, amount, problem_latex):
        """Spend credits to reveal solution"""
        if self.credit_balance < amount:
            return False
        
        self.credit_balance -= amount
        self.credit_spent_total += amount
        
        # Record transaction
        import datetime
        timestamp = datetime.datetime.now().isoformat()
        
        self.credit_history.append({
            "type": "spent",
            "amount": amount,
            "problem": problem_latex,
            "timestamp": timestamp
        })
        
        # Save and update display
        self.save_credit_data()
        self.update_credit_display()
        
        window.console.log(f"üíé Spent {amount} credits")
        return True

    def update_credit_display(self):
        """Update the credit display UI"""
        balance_el = document.querySelector("#creditBalance")
        if balance_el:
            balance_el.textContent = str(self.credit_balance)
        
        earned_el = document.querySelector("#creditEarned")
        if earned_el:
            earned_el.textContent = str(self.credit_earned_total)
        
        spent_el = document.querySelector("#creditSpent")
        if spent_el:
            spent_el.textContent = str(self.credit_spent_total)

    def _show_credit_notification(self, message, color):
        """Show a brief notification about credit change"""
        notification = document.createElement("div")
        notification.style.cssText = f"""
            position: fixed;
            top: 80px;
            right: 20px;
            background: {color};
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 16px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 10000;
            animation: slideInRight 0.3s ease-out;
        """
        notification.textContent = f"üíé {message}"
        document.body.appendChild(notification)
        
        def remove_notification():
            notification.style.opacity = "0"
            notification.style.transition = "opacity 0.3s"
            window.setTimeout(create_proxy(lambda: notification.remove()), 300)
        
        window.setTimeout(create_proxy(remove_notification), 2000)

    def show_credit_history_modal(self, event):
      """Show the credit history modal"""
      modal = document.querySelector("#creditHistoryModal")
      if not modal:
          return

      # Populate history
      content = document.querySelector("#creditHistoryContent")
      if content:
          if not self.credit_history:
              content.innerHTML = """
                  <div style='text-align:center;padding:40px;color:#64748b;'>
                      <div style='font-size:48px;margin-bottom:16px;'>üìä</div>
                      <div style='font-size:16px;font-weight:600;margin-bottom:8px;'>No Credit History Yet</div>
                      <div style='font-size:14px;'>Start solving problems to earn credits!</div>
                  </div>
              """
          else:
              html = "<div style='display:flex;flex-direction:column;gap:8px;'>"

              # Show in reverse order (most recent first)
              for i in range(len(self.credit_history) - 1, -1, -1):
                  transaction = self.credit_history[i]
                  trans_type = transaction["type"]
                  amount = transaction["amount"]
                  problem = transaction.get("problem", "")
                  timestamp = transaction.get("timestamp", "")

                  # Format timestamp
                  try:
                      import datetime
                      dt = datetime.datetime.fromisoformat(timestamp)
                      time_str = dt.strftime("%m/%d/%Y %H:%M")
                  except:
                      time_str = timestamp[:16] if len(timestamp) > 16 else timestamp

                  if trans_type == "earned":
                      difficulty = transaction.get("difficulty", "?")
                      icon = "‚úÖ"
                      color = "#10b981"
                      bg = "#d1fae5"
                      desc = f"Solved (Difficulty: {difficulty})"
                  else:
                      icon = "üí°"
                      color = "#f59e0b"
                      bg = "#fef3c7"
                      desc = "Revealed solution"

                  # Check if this is a row operation
                  is_row_op = (
                      '|R_' in problem or 
                      '|\\mathrm{R}_' in problem or
                      '\\left|R_' in problem or
                      '\\right|' in problem
                  )

                  # Check if contains matrices
                  has_matrix = (
                      '[[' in problem or 
                      '\\left[\\left[' in problem or 
                      '\\begin{matrix}' in problem or
                      '\\begin{bmatrix}' in problem or
                      '\\begin{pmatrix}' in problem
                  )

                  # Handle row operations specially: convert matrix part, keep operation part
                  if is_row_op and has_matrix:
                      try:
                          import sympy as sp
                          import re

                          # Split at the pipe: matrix part | operation part
                          # Pattern: capture everything before |R_ or |\mathrm{R}_
                          match = re.match(r'(.+?)(\\left\|.*?\\right\|)', problem)

                          if match:
                              matrix_part = match.group(1)
                              operation_part = match.group(2)

                              window.console.log(f"Split row operation:")
                              window.console.log(f"  Matrix part: {matrix_part}")
                              window.console.log(f"  Operation part: {operation_part}")

                              # Convert only the matrix part
                              parsed_matrix = self.math_parser.parse_latex(matrix_part)
                              converted_matrix = self._convert_latex_preserve_order(parsed_matrix)

                              # Combine: converted matrix + original operation
                              problem_display = converted_matrix + operation_part

                              window.console.log(f"  Combined result: {problem_display}")
                          else:
                              # Fallback if regex doesn't match
                              window.console.log("Regex didn't match, using original")
                              problem_display = problem

                      except Exception as e:
                          window.console.error(f"Row operation conversion error: {e}")
                          import traceback
                          window.console.error(traceback.format_exc())
                          problem_display = problem

                  # Regular matrices (not row operations)
                  elif has_matrix and not is_row_op:
                      try:
                          import sympy as sp
                          parsed_problem = self.math_parser.parse_latex(problem)
                          problem_display = self._convert_latex_preserve_order(parsed_problem)
                          window.console.log(f"Credit history - converted: {problem} ‚Üí {problem_display}")
                      except Exception as e:
                          window.console.error(f"Credit history conversion error: {e}")
                          import traceback
                          window.console.error(traceback.format_exc())
                          problem_display = problem
                  else:
                      # No matrices, use original
                      problem_display = problem

                  html += f"""
                  <div style='background:{bg};padding:12px;border-radius:8px;border-left:4px solid {color};'>
                      <div style='display:flex;justify-content:space-between;align-items:start;margin-bottom:6px;'>
                          <div style='font-weight:600;color:{color};'>
                              {icon} {'+' if trans_type == 'earned' else '-'}{amount} credit{'s' if amount != 1 else ''}
                          </div>
                          <div style='font-size:12px;color:#64748b;'>{time_str}</div>
                      </div>
                      <div style='font-size:13px;color:#475569;margin-bottom:4px;'>{desc}</div>
                      <div style='font-size:13px;color:#64748b;padding:6px;background:white;border-radius:4px;overflow-x:auto;max-width:100%;'>
                          $$\\displaystyle {problem_display}$$
                      </div>
                  </div>
                  """

              html += "</div>"
              content.innerHTML = html

              # Render MathJax for all the problems
              if hasattr(window, 'MathJax') and hasattr(window.MathJax, 'typesetPromise'):
                  window.MathJax.typesetPromise([content])

      # Show modal
      modal.style.display = "flex"


    def close_credit_history_modal(self, event):
        """Close the credit history modal"""
        modal = document.querySelector("#creditHistoryModal")
        if modal:
            modal.style.display = "none"

    def _show_limit_validation_error_popup(self, error_msg):
      """Show limit validation error popup with extensive examples"""
      import sympy as sp

      # Valid examples - limits that evaluate to finite numbers
      valid_examples = [
          (r"\lim_{x\to 0}\frac{\sin(x)}{x}", "Evaluates to 1"),
          (r"\lim_{x\to 0}\frac{1-\cos(x)}{x^2}", "Evaluates to 1/2"),
          (r"\lim_{x\to 0}\frac{e^x-1}{x}", "Evaluates to 1"),
          (r"\lim_{x\to 2}(x^2 + 1)", "Evaluates to 5"),
          (r"\lim_{x\to 0}\frac{x^2}{2}", "Evaluates to 0"),
          (r"\lim_{x\to 1}\frac{x^2-1}{x-1}", "Evaluates to 2"),
          (r"\lim_{x\to 0}\frac{\tan(x)}{x}", "Evaluates to 1"),
          (r"\lim_{x\to 0}\frac{\ln(1+x)}{x}", "Evaluates to 1"),
          (r"\lim_{x\to\infty}\frac{3x^2+2x}{x^2+1}", "Evaluates to 3"),
          (r"\lim_{x\to\infty}\frac{5x+3}{2x+1}", "Evaluates to 5/2"),
      ]

      # Invalid examples - limits that don't work
      invalid_examples = [
          (r"\lim_{x\to 0}\frac{1}{x^2}", "Goes to infinity", "The limit approaches ‚àû, not a finite number"),
          (r"\lim_{x\to 0}\frac{1}{x}", "Left/right differ", "Left limit is -‚àû, right limit is +‚àû"),
          (r"\lim_{x\to 0}\sin\left(\frac{1}{x}\right)", "Oscillates", "Oscillates infinitely between -1 and 1"),
          (r"\lim_{x\to\infty}x", "Goes to infinity", "The limit is ‚àû, not a finite value"),
          (r"\lim_{x\to\infty}e^x", "Goes to infinity", "Exponential growth to ‚àû"),
          (r"\lim_{x\to\infty}\sin(x)", "Oscillates", "Does not converge to a single value"),
          (r"\lim_{x\to 1}\frac{1}{x-1}", "Goes to infinity", "Vertical asymptote at x=1"),
          (r"\lim_{x\to 0^+}\ln(x)", "Goes to -infinity", "Logarithm approaches -‚àû"),
          (r"\lim_{x\to\infty}x\sin(x)", "Oscillates unbounded", "Oscillates with increasing amplitude"),
          (r"\lim_{x\to 0}\frac{\sin(x)}{x^2}", "Goes to infinity", "Denominator vanishes faster than numerator"),
          (r"\lim_{x\to\infty}\cos(x)", "Oscillates", "Oscillates between -1 and 1 forever"),
          (r"\lim_{x\to 0^+}\frac{1}{\sqrt{x}}", "Goes to infinity", "Approaches ‚àû as x‚Üí0+"),
      ]

      # Build HTML for valid examples
      valid_html = ""
      for latex, desc in valid_examples:
          valid_html += f"""
          <div style="margin-bottom:8px;padding:8px;background:#f0fdf4;border-left:3px solid #10b981;border-radius:4px;">
              <div style="margin-bottom:4px;">$$\\displaystyle {latex}$$</div>
              <div style="font-size:12px;color:#166534;">‚úì {desc}</div>
          </div>
          """

      # Build HTML for invalid examples
      invalid_html = ""
      for latex, title, reason in invalid_examples:
          invalid_html += f"""
          <div style="margin-bottom:8px;padding:8px;background:#fef2f2;border-left:3px solid #dc2626;border-radius:4px;">
              <div style="margin-bottom:4px;">$$\\displaystyle {latex}$$</div>
              <div style="font-size:12px;color:#991b1b;font-weight:600;">‚ùå {title}</div>
              <div style="font-size:11px;color:#7f1d1d;">{reason}</div>
          </div>
          """

      # Escape error message for display
      error_msg_display = error_msg.replace('<', '&lt;').replace('>', '&gt;')

      # Build complete HTML
      popup_html = f"""
  <div id="limitErrorPopupOverlay" style="position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.7);z-index:10000;display:flex;align-items:center;justify-content:center;padding:20px;">
      <div id="limitErrorPopupContent" style="background:white;border-radius:12px;max-width:900px;max-height:90vh;overflow-y:auto;box-shadow:0 20px 60px rgba(0,0,0,0.3);">

          <div style="padding:24px;border-bottom:2px solid #fee2e2;">
              <div style="display:flex;justify-content:space-between;align-items:start;">
                  <div>
                      <h2 style="margin:0 0 8px 0;color:#dc2626;font-size:24px;">
                          ‚ö†Ô∏è Invalid Limit Problem
                      </h2>
                      <p style="margin:0;color:#991b1b;font-size:14px;">
                          {error_msg_display}
                      </p>
                  </div>
                  <button id="closeLimitPopup" style="background:none;border:none;font-size:28px;cursor:pointer;color:#6b7280;padding:0;width:32px;height:32px;line-height:1;">
                      √ó
                  </button>
              </div>
          </div>

          <div style="padding:24px;">
              <div style="margin-bottom:24px;">
                  <h3 style="margin:0 0 12px 0;color:#059669;font-size:18px;display:flex;align-items:center;">
                      <span style="font-size:24px;margin-right:8px;">‚úÖ</span>
                      Valid Limit Problems
                  </h3>
                  <p style="margin:0 0 12px 0;color:#6b7280;font-size:13px;">
                      These limits evaluate to finite, well-defined numbers:
                  </p>
                  <div style="max-height:300px;overflow-y:auto;padding-right:8px;">
                      {valid_html}
                  </div>
              </div>

              <div style="margin-bottom:24px;padding-top:20px;border-top:2px solid #e5e7eb;">
                  <h3 style="margin:0 0 12px 0;color:#dc2626;font-size:18px;display:flex;align-items:center;">
                      <span style="font-size:24px;margin-right:8px;">‚ùå</span>
                      Invalid Limit Problems
                  </h3>
                  <p style="margin:0 0 12px 0;color:#6b7280;font-size:13px;">
                      These limits do NOT work in freestyle practice:
                  </p>
                  <div style="max-height:400px;overflow-y:auto;padding-right:8px;">
                      {invalid_html}
                  </div>
              </div>

              <div style="background:#eff6ff;padding:16px;border-radius:8px;border-left:4px solid #3b82f6;">
                  <div style="font-weight:600;color:#1e40af;margin-bottom:8px;font-size:14px;">
                      üí° Guidelines for Freestyle Practice Limits
                  </div>
                  <ul style="margin:0;padding-left:20px;color:#1e3a8a;font-size:13px;line-height:1.6;">
                      <li><strong>Must evaluate to a finite number</strong> (not ‚àû, -‚àû, or undefined)</li>
                      <li><strong>Must converge</strong> (not oscillate indefinitely)</li>
                      <li><strong>Left and right limits must match</strong> (no discontinuities)</li>
                      <li><strong>Should be solvable</strong> using standard calculus techniques</li>
                      <li>Use L'H√¥pital's rule, algebraic manipulation, or standard limit formulas</li>
                      <li>Indeterminate forms (0/0, ‚àû/‚àû) are fine if they resolve to a finite value</li>
                  </ul>
              </div>
          </div>

          <div style="padding:16px 24px;background:#f9fafb;border-top:1px solid #e5e7eb;display:flex;justify-content:flex-end;border-radius:0 0 12px 12px;">
              <button id="gotItButton" style="background:#3b82f6;color:white;border:none;padding:10px 24px;border-radius:6px;font-size:14px;font-weight:600;cursor:pointer;box-shadow:0 1px 3px rgba(0,0,0,0.1);">
                  Got it, I'll try a different problem
              </button>
          </div>
      </div>
  </div>
  """

      # Remove existing popup
      existing = document.querySelector('#limitErrorPopupOverlay')
      if existing:
          existing.remove()

      # Create overlay div directly
      overlay = document.createElement('div')
      overlay.innerHTML = popup_html.strip()

      # Get the actual popup element (first child of the innerHTML)
      popup_element = overlay.firstChild

      # Append to body
      document.body.appendChild(popup_element)

      # Add event listeners
      close_btn = document.querySelector('#closeLimitPopup')
      if close_btn:
          close_btn.addEventListener('click', create_proxy(lambda e: popup_element.remove()))

      got_it_btn = document.querySelector('#gotItButton')
      if got_it_btn:
          got_it_btn.addEventListener('click', create_proxy(lambda e: popup_element.remove()))

      # Close on overlay click
      popup_element.addEventListener('click', create_proxy(lambda e: popup_element.remove() if e.target.id == 'limitErrorPopupOverlay' else None))

      # Close on Escape key
      def handle_escape(e):
          if e.key == 'Escape':
              elem = document.querySelector('#limitErrorPopupOverlay')
              if elem:
                  elem.remove()

      escape_proxy = create_proxy(handle_escape)
      document.addEventListener('keydown', escape_proxy)

      # Render MathJax
      try:
          popup_content = document.querySelector('#limitErrorPopupContent')
          if popup_content and hasattr(window, 'MathJax') and hasattr(window.MathJax, 'typesetPromise'):
              window.console.log("Rendering MathJax for limit popup...")
              window.MathJax.typesetPromise([popup_content])
              window.console.log("‚úÖ MathJax rendering initiated")
      except Exception as e:
          window.console.error(f"Error setting up MathJax: {e}")
          import traceback
          window.console.error(traceback.format_exc())
    
    # ========================================
    # FIX FOR MATHQUILL INITIALIZATION
    # Replace the existing methods in your ProblemSolverApp class
    # ========================================

    def show_page(self, page_name):
        """Show page - MODIFIED to initialize freestyle on first view"""
        # Hide all pages
        pages = document.querySelectorAll(".page")
        for i in range(pages.length):
            pages[i].classList.remove("active")

        # Show selected page
        target = document.querySelector(f"#{page_name}Page")
        if target:
            target.classList.add("active")

        # Update nav
        nav_items = document.querySelectorAll(".nav-item")
        for i in range(nav_items.length):
            nav_items[i].classList.remove("active")

        active_nav = document.querySelector(f".nav-item[data-page='{page_name}']")
        if active_nav:
            active_nav.classList.add("active")

        # ‚úÖ NEW: Initialize freestyle page when first shown
        if page_name == "freestyle":
            # Use setTimeout to ensure page is visible before initialization
            def delayed_init():
                self.ensure_freestyle_initialized()
            window.setTimeout(create_proxy(delayed_init), 100)

        self.close_sidebar(None)

    def ensure_freestyle_initialized(self):
        """
        Ensure freestyle page is initialized - can be called multiple times safely.
        This is called when the freestyle page is shown.
        """
        window.console.log("üîß Ensuring freestyle page is initialized...")

        # Check if already initialized
        if hasattr(self, '_freestyle_initialized') and self._freestyle_initialized:
            window.console.log("‚úÖ Freestyle already initialized, skipping...")
            return

        try:
            # Initialize MathQuill fields (now that page is visible)
            problem_input = document.querySelector("#freestyleProblemInput")
            answer_input = document.querySelector("#freestyleAnswerInput")

            if not self.MQ:
                window.console.error("‚ùå MathQuill not available")
                window.alert("‚ö†Ô∏è MathQuill not loaded. Please refresh the page.")
                return

            # Initialize problem field
            if problem_input:
              problem_input.innerHTML = ""
              self.freestyle_problem_mf = self.MQ.MathField(problem_input)  # ‚Üê Just this
              window.console.log("‚úÖ Problem MathField initialized")
              # Apply initial keyboard state based on toggle
              if self.soft_keyboard_enabled:
                  self.enable_soft_keyboard(self.freestyle_problem_mf)
              else:
                  self.disable_soft_keyboard(self.freestyle_problem_mf)

              # Add focus event listener to apply keyboard state when focused
              def problem_focus_handler(event):
                  if self.soft_keyboard_enabled:
                      self.enable_soft_keyboard(self.freestyle_problem_mf)
                  else:
                      self.disable_soft_keyboard(self.freestyle_problem_mf)
                  window.console.log(f"‚úÖ Problem field focused - keyboard mode: {'soft' if self.soft_keyboard_enabled else 'minimal'}")

              problem_input.addEventListener("focus", create_proxy(problem_focus_handler), True)
              window.setTimeout(create_proxy(lambda: self.freestyle_problem_mf.focus()), 100)
            else:
                window.console.error("‚ùå Problem input element not found")

            # Initialize answer field
            if answer_input:
              answer_input.innerHTML = ""
              self.freestyle_answer_mf = self.MQ.MathField(answer_input)
              window.console.log("‚úÖ Answer MathField initialized")
              # Apply initial keyboard state based on toggle
              if self.soft_keyboard_enabled:
                  self.enable_soft_keyboard(self.freestyle_answer_mf)
              else:
                  self.disable_soft_keyboard(self.freestyle_answer_mf)

              # Add focus event listener to apply keyboard state when focused
              def answer_focus_handler(event):
                  if self.soft_keyboard_enabled:
                      self.enable_soft_keyboard(self.freestyle_answer_mf)
                  else:
                      self.disable_soft_keyboard(self.freestyle_answer_mf)
                  window.console.log(f"‚úÖ Answer field focused - keyboard mode: {'soft' if self.soft_keyboard_enabled else 'minimal'}")

              answer_input.addEventListener("focus", create_proxy(answer_focus_handler), True)
            else:
                window.console.error("‚ùå Answer input element not found")

            # Initialize state
            if not hasattr(self, 'freestyle_problem'):
                self.freestyle_problem = None
            if not hasattr(self, 'freestyle_attempts'):
                self.freestyle_attempts = []
            if not hasattr(self, 'freestyle_correct'):
                self.freestyle_correct = False
            if not hasattr(self, 'freestyle_finalized'):
                self.freestyle_finalized = False

            # Setup button handlers (only once)
            self._setup_freestyle_buttons()

            # Setup keyboard handlers (only once)
            self._setup_freestyle_keyboard()

            # Update credit display
            self.update_credit_display()

            # Mark as initialized
            self._freestyle_initialized = True
            window.console.log("‚úÖ Freestyle page fully initialized")

        except Exception as e:
            window.console.error(f"‚ùå Freestyle initialization error: {e}")
            import traceback
            window.console.error(traceback.format_exc())
            window.alert(f"‚ö†Ô∏è Error initializing freestyle page: {e}")

    def _setup_freestyle_buttons(self):
        """Setup button event handlers for freestyle page"""
        try:
            # Set problem button
            set_btn = document.querySelector("#setFreestyleProblem")
            if set_btn and not hasattr(set_btn, '_handler_attached'):
                set_btn.addEventListener("click", create_proxy(lambda e: self.set_freestyle_problem(e)))
                set_btn._handler_attached = True
                window.console.log("‚úÖ Set button handler attached")

            # Submit button
            submit_btn = document.querySelector("#freestyleSubmit")
            if submit_btn and not hasattr(submit_btn, '_handler_attached'):
                submit_btn.addEventListener("click", create_proxy(lambda e: self.freestyle_submit(e)))
                submit_btn._handler_attached = True
                window.console.log("‚úÖ Submit button handler attached")

            # Get Structure String button
            structure_btn = document.querySelector("#getStructureString")
            if structure_btn and not hasattr(structure_btn, '_handler_attached'):
                structure_btn.addEventListener("click", create_proxy(lambda e: self.show_structure_modal(e)))
                structure_btn._handler_attached = True
                window.console.log("‚úÖ Structure button handler attached")

            # Give Up button
            giveup_btn = document.querySelector("#freestyleGiveUp")
            if giveup_btn and not hasattr(giveup_btn, '_handler_attached'):
                giveup_btn.addEventListener("click", create_proxy(lambda e: self.freestyle_giveup(e)))
                giveup_btn._handler_attached = True
                window.console.log("‚úÖ Give Up button handler attached")

            # Finalize button
            finalize_btn = document.querySelector("#freestyleFinalize")
            if finalize_btn and not hasattr(finalize_btn, '_handler_attached'):
                finalize_btn.addEventListener("click", create_proxy(lambda e: self.freestyle_finalize(e)))
                finalize_btn._handler_attached = True
                window.console.log("‚úÖ Finalize button handler attached")

            # Reset button
            reset_btn = document.querySelector("#freestyleReset")
            if reset_btn and not hasattr(reset_btn, '_handler_attached'):
                reset_btn.addEventListener("click", create_proxy(lambda e: self.freestyle_reset(e)))
                reset_btn._handler_attached = True
                window.console.log("‚úÖ Reset button handler attached")

        except Exception as e:
            window.console.error(f"Button setup error: {e}")

    def toggle_keyboard_accordion(self, target_id):
        """Toggle keyboard accordion open/close"""
        try:
            body = document.querySelector(f"#{target_id}")
            if not body:
                return

            # Find parent accordion container
            accordion = body.parentElement
            if not accordion:
                return

            # Toggle open class
            if accordion.classList.contains("open"):
                accordion.classList.remove("open")
            else:
                accordion.classList.add("open")

        except Exception as e:
            window.console.error(f"Accordion toggle error: {e}")

    def get_power_svg(self, size="24", color="currentColor"):
        """SVG: Grey-filled box with superscripted white-filled box (for exponent/power)"""
        return f"""<svg width="{size}" height="{size}" viewBox="0 0 24 24" fill="none"
            xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
          <rect x="2" y="10" width="10" height="10" rx="1"
                stroke="{color}" stroke-width="2"
                fill="#9ca3af"/>
          <rect x="13" y="4" width="8" height="8" rx="1"
                stroke="{color}" stroke-width="1.5"
                fill="#ffffff"/>
        </svg>"""

    def get_subscript_svg(self, size="24", color="currentColor"):
        """SVG: Grey-filled box with subscripted white-filled box (for subscript)"""
        return f"""<svg width="{size}" height="{size}" viewBox="0 0 24 24" fill="none"
            xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
          <rect x="2" y="4" width="10" height="10" rx="1"
                stroke="{color}" stroke-width="2"
                fill="#9ca3af"/>
          <rect x="13" y="12" width="8" height="8" rx="1"
                stroke="{color}" stroke-width="1.5"
                fill="#ffffff"/>
        </svg>"""

    def get_move_left_svg(self, size="24", stroke_width=2, color="currentColor"):
        """SVG: left-pointing arrow (move left)"""
        return f"""<svg width="{size}" height="{size}" viewBox="0 0 24 24" fill="none"
            xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
          <path d="M21 12 H11" stroke="{color}" stroke-width="{stroke_width}" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
          <path d="M15 8 L11 12 L15 16" stroke="{color}" stroke-width="{stroke_width}" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
        </svg>"""

    def get_move_right_svg(self, size="24", stroke_width=2, color="currentColor"):
        """SVG: right-pointing arrow (move right)"""
        return f"""<svg width="{size}" height="{size}" viewBox="0 0 24 24" fill="none"
            xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
          <path d="M3 12 H13" stroke="{color}" stroke-width="{stroke_width}" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
          <path d="M9 8 L13 12 L9 16" stroke="{color}" stroke-width="{stroke_width}" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
        </svg>"""

    def get_select_left_svg(self, size="24", stroke_width=2, color="currentColor"):
        """SVG: box followed by a left-pointing arrow (select left)"""
        return f"""<svg width="{size}" height="{size}" viewBox="0 0 24 24" fill="none"
            xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
          <rect x="3" y="6" width="8" height="12" rx="2" stroke="{color}" stroke-width="{stroke_width}" fill="none"/>
          <path d="M21 12 H11" stroke="{color}" stroke-width="{stroke_width}" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
          <path d="M15 8 L11 12 L15 16" stroke="{color}" stroke-width="{stroke_width}" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
        </svg>"""

    def get_select_right_svg(self, size="24", stroke_width=2, color="currentColor"):
        """SVG: right-pointing arrow followed by a box (select right)"""
        return f"""<svg width="{size}" height="{size}" viewBox="0 0 24 24" fill="none"
            xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
          <path d="M3 12 H13" stroke="{color}" stroke-width="{stroke_width}" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
          <path d="M9 8 L13 12 L9 16" stroke="{color}" stroke-width="{stroke_width}" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
          <rect x="13.5" y="6" width="7" height="12" rx="2" stroke="{color}" stroke-width="{stroke_width}" fill="none"/>
        </svg>"""

    def get_keyboard_toggle_svg(self, size="24", is_enabled=True, color="currentColor"):
        """SVG: Keyboard icon with indicator light - bigger and more prominent

        Args:
            size: SVG size
            is_enabled: If True, light is ON (soft keyboard enabled), else light is OFF (minimal mode)
            color: Icon color
        """
        # Light is always green, but opacity changes: visible when ON, hidden when OFF
        light_opacity = "1" if is_enabled else "0.1"
        light_glow = "0 0 10px rgba(16, 185, 129, 1)" if is_enabled else "none"

        return f"""<svg width="{size}" height="{size}" viewBox="0 0 64 64" fill="none"
            xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
          <!-- Indicator light (very top-left corner) -->
          <circle cx="6" cy="6" r="10" fill="#10b981" opacity="{light_opacity}"
                  style="filter: drop-shadow({light_glow})"/>
          <circle cx="6" cy="6" r="6" fill="white" opacity="{light_opacity}" style="opacity: calc({light_opacity} * 0.7)"/>

          <!-- Keyboard base - larger and more prominent -->
          <rect x="4" y="22" width="56" height="38" rx="4"
                stroke="{color}" stroke-width="3" fill="none"/>

          <!-- Keys layout - more realistic and prominent -->
          <!-- Top row (7 keys) -->
          <rect x="8" y="27" width="6" height="5" rx="0.8" fill="{color}"/>
          <rect x="16" y="27" width="6" height="5" rx="0.8" fill="{color}"/>
          <rect x="24" y="27" width="6" height="5" rx="0.8" fill="{color}"/>
          <rect x="32" y="27" width="6" height="5" rx="0.8" fill="{color}"/>
          <rect x="40" y="27" width="6" height="5" rx="0.8" fill="{color}"/>
          <rect x="48" y="27" width="6" height="5" rx="0.8" fill="{color}"/>

          <!-- Middle row (6 keys) -->
          <rect x="8" y="34" width="6" height="5" rx="0.8" fill="{color}"/>
          <rect x="16" y="34" width="6" height="5" rx="0.8" fill="{color}"/>
          <rect x="24" y="34" width="6" height="5" rx="0.8" fill="{color}"/>
          <rect x="32" y="34" width="6" height="5" rx="0.8" fill="{color}"/>
          <rect x="40" y="34" width="6" height="5" rx="0.8" fill="{color}"/>
          <rect x="48" y="34" width="6" height="5" rx="0.8" fill="{color}"/>

          <!-- Third row (5 keys) -->
          <rect x="10" y="41" width="6" height="5" rx="0.8" fill="{color}"/>
          <rect x="18" y="41" width="6" height="5" rx="0.8" fill="{color}"/>
          <rect x="26" y="41" width="6" height="5" rx="0.8" fill="{color}"/>
          <rect x="34" y="41" width="6" height="5" rx="0.8" fill="{color}"/>
          <rect x="42" y="41" width="6" height="5" rx="0.8" fill="{color}"/>

          <!-- Bottom row (spacebar - wide) -->
          <rect x="18" y="48" width="28" height="5" rx="0.8" fill="{color}"/>

          <!-- Side modifier keys -->
          <rect x="8" y="48" width="8" height="5" rx="0.8" fill="{color}"/>
          <rect x="48" y="48" width="8" height="5" rx="0.8" fill="{color}"/>
        </svg>"""

    def detect_handheld_device(self):
        """Detect if device is handheld (small screen)"""
        try:
            # Check screen width - consider < 768px as handheld
            is_small_screen = window.innerWidth < 768

            # Check for touch capability
            is_touch = hasattr(window.navigator, 'maxTouchPoints') and window.navigator.maxTouchPoints > 0

            # Check user agent for mobile indicators
            user_agent = window.navigator.userAgent.lower() if hasattr(window.navigator, 'userAgent') else ""
            is_mobile_ua = any(mobile in user_agent for mobile in ['android', 'iphone', 'ipad', 'mobile'])

            # Consider handheld if small screen OR (touch + mobile UA)
            is_handheld = is_small_screen or (is_touch and is_mobile_ua)

            window.console.log(f"Device detection: width={window.innerWidth}, touch={is_touch}, mobile_ua={is_mobile_ua}, handheld={is_handheld}")
            return is_handheld
        except Exception as e:
            window.console.error(f"Error detecting device: {e}")
            return False  # Default to non-handheld

    def disable_soft_keyboard(self, mathquill_field):
        """Conditionally disable soft keyboard based on toggle state"""
        try:
            if not mathquill_field:
                return

            # Only disable if soft keyboard is toggled off
            if self.soft_keyboard_enabled:
                window.console.log("‚å®Ô∏è Soft keyboard enabled, not disabling")
                return

            # Get the MathQuill element
            el = mathquill_field.el()
            if not el:
                return

            # Find and configure the textarea to prevent soft keyboard
            textarea = el.querySelector('textarea')
            if textarea:
                textarea.setAttribute('readonly', 'readonly')
                textarea.setAttribute('inputmode', 'none')
                textarea.style.caretColor = 'transparent'
                window.console.log("‚úÖ Soft keyboard disabled for field")

        except Exception as e:
            window.console.error(f"Error disabling soft keyboard: {e}")

    def enable_soft_keyboard(self, mathquill_field):
        """Enable soft keyboard for a MathQuill field"""
        try:
            if not mathquill_field:
                return

            # Get the MathQuill element
            el = mathquill_field.el()
            if not el:
                return

            # Find and configure the textarea to allow soft keyboard
            textarea = el.querySelector('textarea')
            if textarea:
                textarea.removeAttribute('readonly')
                textarea.setAttribute('inputmode', 'text')
                textarea.style.caretColor = ''
                window.console.log("‚úÖ Soft keyboard enabled for field")

        except Exception as e:
            window.console.error(f"Error enabling soft keyboard: {e}")

    def toggle_soft_keyboard(self, event):
        """Toggle between soft keyboard and minimal keyboard"""
        try:
            # Toggle state
            self.soft_keyboard_enabled = not self.soft_keyboard_enabled
            window.console.log(f"‚å®Ô∏è Toggled keyboard: soft_keyboard_enabled={self.soft_keyboard_enabled}")

            # Update button appearance with SVG - only change the indicator light, not button color
            toggle_btns = document.querySelectorAll('[data-action="TOGGLE_KEYBOARD"]')
            for i in range(toggle_btns.length):
                btn = toggle_btns[i]
                if self.soft_keyboard_enabled:
                    btn.innerHTML = self.get_keyboard_toggle_svg("60", is_enabled=True, color="white")
                    btn.title = 'Soft Keyboard ON - Click to use Minimal Keyboard'
                else:
                    btn.innerHTML = self.get_keyboard_toggle_svg("60", is_enabled=False, color="white")
                    btn.title = 'Minimal Keyboard - Click to enable Soft Keyboard'

            # Apply to all existing MathQuill fields
            answer_fields = document.querySelectorAll('.step-answer')
            for i in range(answer_fields.length):
                field = answer_fields[i]
                # Get MathQuill instance if it exists
                if hasattr(field, 'mathquill'):
                    if self.soft_keyboard_enabled:
                        self.enable_soft_keyboard(field.mathquill)
                    else:
                        self.disable_soft_keyboard(field.mathquill)

            # Also apply to freestyle fields if they exist
            if hasattr(self, 'freestyle_answer_mf') and self.freestyle_answer_mf:
                if self.soft_keyboard_enabled:
                    self.enable_soft_keyboard(self.freestyle_answer_mf)
                else:
                    self.disable_soft_keyboard(self.freestyle_answer_mf)
                window.console.log("‚úÖ Applied keyboard toggle to freestyle answer field")

            if hasattr(self, 'freestyle_problem_mf') and self.freestyle_problem_mf:
                if self.soft_keyboard_enabled:
                    self.enable_soft_keyboard(self.freestyle_problem_mf)
                else:
                    self.disable_soft_keyboard(self.freestyle_problem_mf)
                window.console.log("‚úÖ Applied keyboard toggle to freestyle problem field")

            # Show notification
            msg = "Soft keyboard enabled" if self.soft_keyboard_enabled else "Minimal keyboard mode"
            window.alert(f"‚å®Ô∏è {msg}")

        except Exception as e:
            window.console.error(f"Error toggling keyboard: {e}")

    def build_minimal_keyboard_from_structure(self, expected_structure, step_data=None):
        """Build truly minimal keyboard - only needed digits + limited distractors"""
        if not expected_structure:
            # Default: just basic digits and controls
            return ['0','1','2','3','BACKSPACE','MOVE_LEFT','MOVE_RIGHT','CLEAR']

        buttons = []
        operators = expected_structure.get('operators', {})
        operands = expected_structure.get('operands', {})

        # Check if this is a matrix or equation by looking at expected answer
        has_matrix = False
        has_equation = False
        if step_data:
            expected_answer = step_data.get('expected', '')
            has_matrix = '[' in expected_answer and ']' in expected_answer
            has_equation = '=' in expected_answer
            window.console.log(f"Detection from expected answer: has_matrix={has_matrix}, has_equation={has_equation}, expected={expected_answer}")

        # Also check for Matrix/Equation in operators
        if not has_matrix and operators:
            has_matrix = any('matrix' in str(op).lower() for op in operators)
            window.console.log(f"Matrix detection from operators: has_matrix={has_matrix}")
        if not has_equation and operators:
            # Check for both "Eq" and "Equality" (SymPy uses Equality)
            has_equation = any('eq' in str(op).lower() or 'equality' in str(op).lower() for op in operators)
            window.console.log(f"Equation detection from operators: has_equation={has_equation}, operators={operators}")

        # Extract ONLY required digits from operands
        required_digits = set()
        has_decimal = False
        has_negative = False

        for operand in operands.keys():
            operand_str = str(operand)

            # Check for negative numbers
            if operand_str.startswith('-') or operand_str.startswith('(-'):
                has_negative = True
                window.console.log(f"Detected negative in operand: {operand_str}")

            # Extract digits
            num_str = operand_str.replace("-", "").replace(".", "").replace("(", "").replace(")", "").replace(" ", "")
            for digit in num_str:
                if digit.isdigit():
                    required_digits.add(digit)
            # Check for decimal
            if "." in operand_str:
                has_decimal = True

        # Check if operands dictionary contains negative numbers
        for operand_key, operand_count in operands.items():
            try:
                # Try to convert to float to check if negative
                num_val = float(operand_key)
                if num_val < 0:
                    has_negative = True
                    window.console.log(f"Detected negative number: {num_val}")
            except:
                pass

        # Add 2-3 distractor digits (NOT in answer)
        all_digits = set("0123456789")
        available_distractors = list(all_digits - required_digits)
        distractor_digits = set()
        if available_distractors:
            import random
            random.seed(hash(str(operands)))  # Consistent distractors
            num_distractors = min(3, len(available_distractors))
            distractors = random.sample(available_distractors, num_distractors)
            distractor_digits = set(distractors)

        # Combine required digits and distractors, then sort to hide the answer
        all_button_digits = required_digits | distractor_digits
        for digit in sorted(all_button_digits):
            buttons.append(digit)

        # Add decimal if needed
        if has_decimal:
            buttons.append('.')

        # Add operators ONLY if present
        # ‚úÖ If there's Add operator, include BOTH + and - (SymPy represents negatives in Add)
        if 'Add' in operators:
            buttons.append('+')
            buttons.append('-')
            window.console.log("Added + and - (Add operator detected)")
        elif has_negative or 'Sub' in operators:
            # Only add minus if no Add operator but negative detected
            buttons.append('-')
            window.console.log("Added minus button (negative detected)")

        if 'Mul' in operators:
            buttons.append('\\times')
        if 'Pow' in operators:
            buttons.append('^')
        if 'Div' in str(operators) or '/' in str(operators):
            buttons.append('/')

        # Add special functions ONLY if present
        if 'frac' in str(operators).lower() or 'Rational' in str(operators):
            buttons.append('\\frac')
        if 'sqrt' in str(operators).lower():
            buttons.append('\\sqrt')
        if 'Pow' in str(operators) and any('_' in str(op) for op in operators):
            buttons.append('_')

        # Check for trigonometry functions - add degree symbol if found
        has_trig = any(trig in str(operators) for trig in ['sin', 'cos', 'tan', 'sec', 'csc', 'cot'])
        if has_trig:
            # Add degree symbol for angle input
            buttons.append('\\circ')
            window.console.log("Added degree symbol (trig function detected)")

        # Add matrix brackets and comma if matrix detected
        if has_matrix:
            buttons.append('[')
            buttons.append(']')
            buttons.append(',')
            window.console.log("Added [, ], and , (matrix detected)")

        # Add equals sign if equation detected
        if has_equation:
            buttons.append('=')
            window.console.log("Added = (equation detected)")

        # Check for matrix row operations
        matrix_ops = expected_structure.get('matrix_ops', [])
        has_row_op = any('row' in str(op).lower() for op in matrix_ops)
        if has_row_op:
            buttons.append('R')
            buttons.append('\\to')
            window.console.log("Added R and ‚Üí (row operation detected)")

        # Add variables from operands
        operands_str = str(operands).lower()
        if 'x' in operands_str and 'x' not in ['exp']:
            buttons.append('x')
        if 'y' in operands_str:
            buttons.append('y')
        if 'pi' in operands_str or 'œÄ' in operands_str:
            buttons.append('\\pi')
        if 'r' in operands_str and has_row_op:
            # R is already added above for row operations
            pass

        # Always include basic controls (navigation and backspace at end)
        buttons.extend(['(', ')', 'MOVE_LEFT', 'MOVE_RIGHT', 'SELECT_LEFT', 'SELECT_RIGHT', 'CLEAR', 'BACKSPACE'])

        # Remove duplicates while preserving order
        seen = set()
        unique_buttons = []
        for b in buttons:
            if b not in seen:
                seen.add(b)
                unique_buttons.append(b)

        # Insert TOGGLE_KEYBOARD as the very first button
        unique_buttons.insert(0, 'TOGGLE_KEYBOARD')

        window.console.log(f"Final buttons: {unique_buttons}")
        return unique_buttons

    def create_keyboard_button_html(self, action):
        """Create HTML for a single keyboard button with SVG support"""
        # Determine button class
        btn_class = 'input-btn'

        if action.isdigit():
            btn_class += ' digit'
            label = action
        elif action in ['BACKSPACE', 'CLEAR']:
            btn_class += ' delete'
            label = '‚å´' if action == 'BACKSPACE' else 'C'
        elif action == 'MOVE_LEFT':
            btn_class += ' navigation'
            label = self.get_move_left_svg("20")
        elif action == 'MOVE_RIGHT':
            btn_class += ' navigation'
            label = self.get_move_right_svg("20")
        elif action == 'SELECT_LEFT':
            btn_class += ' navigation'
            label = self.get_select_left_svg("20")
        elif action == 'SELECT_RIGHT':
            btn_class += ' navigation'
            label = self.get_select_right_svg("20")
        elif action == '^':
            btn_class += ' special'
            label = self.get_power_svg("20")
        elif action == '_':
            btn_class += ' special'
            label = self.get_subscript_svg("20")
        elif action in ['+', '-', '\\times', '/', '=']:
            btn_class += ' operator'
            label_map = {'\\times': '√ó', '/': '√∑'}
            label = label_map.get(action, action)
        elif action in ['x', 'y', 'z', 'n', 'a', 'b', 'c', 't', 'R', 'Œ∏']:
            btn_class += ' symbol'
            # Render variables in italic math style
            label = f'<span class="math-var">{action}</span>'
        elif action == '\\pi':
            btn_class += ' symbol'
            label = '<span class="math-var">œÄ</span>'
        elif action == '\\frac':
            btn_class += ' special'
            label = '<span style="font-size:11px;">a/b</span>'
        elif action == '\\sqrt':
            btn_class += ' special'
            label = '‚àö'
        elif action == '\\infty':
            btn_class += ' operator'
            label = '‚àû'
        elif action == '\\circ':
            btn_class += ' special'
            label = '<span style="font-size:13px;">deg¬∞</span>'
        elif action == '\\to':
            btn_class += ' operator'
            label = '‚Üí'
        elif action == 'TOGGLE_KEYBOARD':
            btn_class += ' navigation keyboard-toggle'
            # Set initial SVG based on current state - button color stays same, only light changes
            if self.soft_keyboard_enabled:
                label = self.get_keyboard_toggle_svg("60", is_enabled=True, color="white")
                title = 'Soft Keyboard ON - Click to use Minimal Keyboard'
            else:
                label = self.get_keyboard_toggle_svg("60", is_enabled=False, color="white")
                title = 'Minimal Keyboard - Click to enable Soft Keyboard'
            return f'<button class="{btn_class}" data-action="{action}" title="{title}" style="background:#3b82f6;padding:8px;">{label}</button>'
        else:
            btn_class += ' special'
            label = action

        return f'<button class="{btn_class}" data-action="{action}">{label}</button>'

    def inject_freestyle_svgs(self):
        """Inject SVG icons into freestyle keyboard buttons"""
        try:
            # Inject navigation SVGs
            move_left = document.querySelector("#freestyleMoveLeft")
            if move_left:
                move_left.innerHTML = self.get_move_left_svg("24")
                window.console.log("‚úÖ Injected move left SVG")

            move_right = document.querySelector("#freestyleMoveRight")
            if move_right:
                move_right.innerHTML = self.get_move_right_svg("24")
                window.console.log("‚úÖ Injected move right SVG")

            # Inject power/subscript SVGs
            power_btn = document.querySelector("#freestylePower")
            if power_btn:
                power_btn.innerHTML = self.get_power_svg("24")
                window.console.log("‚úÖ Injected power SVG")

            subscript_btn = document.querySelector("#freestyleSubscript")
            if subscript_btn:
                subscript_btn.innerHTML = self.get_subscript_svg("24")
                window.console.log("‚úÖ Injected subscript SVG")

            # Inject matrix subscript SVG
            subscript_matrix_btn = document.querySelector("#freestyleSubscriptMatrix")
            if subscript_matrix_btn:
                subscript_matrix_btn.innerHTML = self.get_subscript_svg("24")
                window.console.log("‚úÖ Injected subscript matrix SVG")

            # Inject keyboard toggle SVG
            toggle_keyboard_btn = document.querySelector("#freestyleToggleKeyboard")
            if toggle_keyboard_btn:
                toggle_keyboard_btn.innerHTML = self.get_keyboard_toggle_svg("60", is_enabled=self.soft_keyboard_enabled, color="white")
                toggle_keyboard_btn.style.background = "#3b82f6"
                toggle_keyboard_btn.style.padding = "8px"
                window.console.log("‚úÖ Injected keyboard toggle SVG")

            # Inject select left SVG
            select_left_btn = document.querySelector("#freestyleSelectLeft")
            if select_left_btn:
                select_left_btn.innerHTML = self.get_select_left_svg("24")
                window.console.log("‚úÖ Injected select left SVG")

            window.console.log("‚úÖ All freestyle SVGs injected")

        except Exception as e:
            window.console.error(f"SVG injection error: {e}")

    def _setup_freestyle_keyboard(self):
        """Setup keyboard event handlers for freestyle page"""
        try:
            # Setup keyboard buttons - like version 21
            keyboard_btns = document.querySelectorAll(".keyboard-accordion-body .input-btn")
            window.console.log(f"üîç Found {keyboard_btns.length} keyboard buttons in accordion")

            for i in range(keyboard_btns.length):
                btn = keyboard_btns[i]
                action = btn.getAttribute("data-action")

                if action:
                    def make_keyboard_handler(act):
                        def handler(e):
                            # Prevent default to stop focus change
                            e.preventDefault()
                            # Prevent button from taking focus
                            e.stopPropagation()
                            self.handle_freestyle_input(act)
                        return handler

                    btn.addEventListener("click", create_proxy(make_keyboard_handler(action)))
                    # Also prevent mousedown from taking focus
                    btn.addEventListener("mousedown", create_proxy(lambda e: e.preventDefault()))

            window.console.log(f"‚úÖ Keyboard button handlers attached")

            # Inject SVG icons
            self.inject_freestyle_svgs()

            # Setup keyboard accordion headers
            headers = document.querySelectorAll("#freestyleKeyboard .keyboard-accordion-header")
            window.console.log(f"Found {headers.length} accordion headers")

            for i in range(headers.length):
                header = headers[i]
                target_id = header.getAttribute("data-target")

                if not hasattr(header, '_handler_attached'):
                    def make_accordion_handler(tid):
                        def handler(e):
                            self.toggle_keyboard_accordion(tid)
                        return handler
                    header.addEventListener("click", create_proxy(make_accordion_handler(target_id)))
                    header._handler_attached = True

            window.console.log("‚úÖ Accordion handlers attached")

        except Exception as e:
            window.console.error(f"Keyboard setup error: {e}")
            import traceback
            window.console.error(traceback.format_exc())

    def handle_freestyle_input(self, action):
        """Handle keyboard input for freestyle fields (problem or answer)"""
        window.console.log(f"üéπ handle_freestyle_input called with action: {action}")

        # Determine which field to use
        if self.freestyle_problem:
            # Problem is set, input goes to answer
            target_field = self.freestyle_answer_mf
            window.console.log("üìç Target: Answer field")
        else:
            # No problem yet, input goes to problem input
            target_field = self.freestyle_problem_mf
            window.console.log("üìç Target: Problem field")

        if not target_field:
            window.console.error("‚ùå No target field available")
            return

        window.console.log(f"‚úÖ Calling KeyboardInputHandler.handle_action")
        # Use the common KeyboardInputHandler
        KeyboardInputHandler.handle_action(target_field, action)

# ========================================
# REMOVE THIS METHOD FROM YOUR CODE:
# def init_freestyle_page(self)
# 
# It's no longer needed - initialization happens automatically
# when the page is shown via ensure_freestyle_initialized()
# ========================================

# ========================================
# UPDATE YOUR init() METHOD:
# Remove the call to self.init_freestyle_page()
# The new system initializes automatically when page is shown
# ========================================
# Initialize app
app = ProblemSolverApp()
window.setTimeout(create_proxy(app.init), 700)

print("‚úÖ Problem Solver initialized with multi-type support")
</script>
  
  


  <!-- Auto-hide Header Script -->
  <script>
    (function() {
      const header = document.querySelector('.nonet-step-header');
      const threshold = 10; // Show only when within 10px of top

      window.addEventListener('scroll', function() {
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;

        if (scrollTop <= threshold) {
          // At the very top - show header
          header.classList.remove('hidden');
        } else {
          // Scrolled down - hide header
          header.classList.add('hidden');
        }
      });
    })();
  </script>

</body>
</html>